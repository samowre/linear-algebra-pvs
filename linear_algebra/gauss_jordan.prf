(gauss_jordan (pivot_TCC1 0 (pivot_TCC1-1 nil 3520662628 ("" (skeep :preds? t) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "nonzero_row?") (("" (skosimp) (("" (inst -3 "j!1") (("" (expand "member") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonempty? const-decl "bool" sets nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)) nil)) (pivot_TCC2 0 (pivot_TCC2-1 nil 3522465078 ("" (inst 1 "lambda (d: [M: Matrix, {i: below(M`rows) | nonzero_row?(M, i)}]):
min({j_1: below(d`1`cols) | d`1`matrix(d`2, j_1) /= 0})") (("" (skeep :preds? t) (("" (typepred "d`2") (("" (expand "nonzero_row?") (("" (skosimp :preds? t) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (inst -3 "j!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Matrix type-eq-decl nil matrices nil)) nil)) (pivot_prop_TCC1 0 (pivot_prop_TCC1-1 nil 3522531166 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (/= const-decl "boolean" notequal nil)) nil)) (pivot_prop 0 (pivot_prop-1 nil 3522531182 ("" (skeep :preds? t) (("" (typepred "pivot(M, i)") (("" (typepred "min({j_1: below(M`cols) | M`matrix(i, j_1) /= 0})") (("1" (assert) (("1" (skeep :preds? t) (("1" (inst -3 "j") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "nonzero_row?") (("2" (skosimp :preds? t) (("2" (expand "member") (("2" (inst -2 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Matrix type-eq-decl nil matrices nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (find_pivot_row_TCC1 0 (find_pivot_row_TCC1-1 nil 3522644594 ("" (subtype-tcc) nil nil) nil nil)) (find_pivot_row_TCC2 0 (find_pivot_row_TCC2-1 nil 3522644594 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (assert) nil nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (find_pivot_row_TCC3 0 (find_pivot_row_TCC3-1 nil 3523592171 ("" (inst 1 "lambda (M: Matrix,
                    r: below(M`rows) |
                             exists (i: subrange(r, M`rows - 1)):
                               nonzero_row?(M, i)):
                 let pc = min({c: below(M`cols) 
                                | exists (i: subrange(r, M`rows - 1)):
                                    nonzero_row?(M, i) & pivot(M, i) = c})
                  in choose! (i: subrange(r, M`rows - 1)): 
                       nonzero_row?(M, i) & pivot(M, i) = pc") (("1" (skeep :preds? t) (("1" (split 1) (("1" (typepred "choose! (i: subrange(r, M`rows - 1)):
                     nonzero_row?(M, i) & pivot(M, i) = pc") (("1" (propax) nil nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skosimp -5 :preds? t) (("2" (inst -3 "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (inst -8 "pivot(M, j)") (("2" (assert) (("2" (inst 2 "j") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skosimp -4 :preds? t) (("2" (inst -10 "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (expand "nonempty?") (("3" (expand "empty?") (("3" (expand "member") (("3" (skosimp :preds? t) (("3" (inst -5 "pivot(M, i!1)") (("3" (inst 1 "i!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((i!1 skolem-const-decl "subrange(r, M`rows - 1)" gauss_jordan nil) (r skolem-const-decl "{r: below(M`rows) | EXISTS (i: subrange(r, M`rows - 1)): nonzero_row?(M, i)}" gauss_jordan nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Matrix type-eq-decl nil matrices nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (row_echelon_form?_TCC1 0 (row_echelon_form?_TCC1-1 nil 3520617716 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil)) nil)) (row_echelon_form?_TCC2 0 (row_echelon_form?_TCC2-1 nil 3520617716 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (assert) (("" (skeep 2 :preds? t) (("" (inst -3 "i1" "j1") (("" (assert) (("" (expand "nonzero_row?") (("" (expand "zero_row?") (("" (skosimp) (("" (split) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil) ("2" (skosimp) (("2" (inst 3 "j!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero_row? const-decl "bool" elementary_matrices nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (row_echelon_form_below?_TCC1 0 (row_echelon_form_below?_TCC1-1 nil 3521381291 ("" (subtype-tcc) nil nil) nil nil)) (row_echelon_form_below?_TCC2 0 (row_echelon_form_below?_TCC2-1 nil 3521381291 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil)) nil)) (row_echelon_form_below?_TCC3 0 (row_echelon_form_below?_TCC3-1 nil 3521381291 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil)) nil)) (row_echelon_form_below?_TCC4 0 (row_echelon_form_below?_TCC4-1 nil 3521381291 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (skeep :preds? t) (("" (assert) (("" (inst -4 "i1" "j1") (("" (assert) (("" (use "zero_or_nonzero") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (zero_or_nonzero formula-decl nil elementary_matrices nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (rref_row_inv_TCC1 0 (rref_row_inv_TCC1-1 nil 3523766503 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil)) nil)) (rref_row_inv_TCC2 0 (rref_row_inv_TCC2-1 nil 3525036228 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil)) nil)) (rref?_TCC1 0 (rref?_TCC1-1 nil 3520403327 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil)) nil)) (rref_has_nonzero_row_below_TCC1 0 (rref_has_nonzero_row_below_TCC1-1 nil 3525808870 ("" (subtype-tcc) nil nil) nil nil)) (rref_has_nonzero_row_below_TCC2 0 (rref_has_nonzero_row_below_TCC2-1 nil 3525808870 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (rref_has_nonzero_row_below_TCC3 0 (rref_has_nonzero_row_below_TCC3-1 nil 3525808870 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil)) nil)) (rref_has_nonzero_row_below 0 (rref_has_nonzero_row_below-1 nil 3525808870 ("" (skeep :preds? t) (("" (expand "rref?") (("" (expand "reduced_row_echelon_form?") (("" (expand "row_echelon_form_below?") (("" (flatten) (("" (split 1) (("1" (expand "row_echelon_form?") (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -6 "i" "j") (("1" (assert) nil nil) ("2" (inst 3 "i") (("2" (lemma "zero_isnt_nonzero") (("2" (inst -1 "M" "i") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (inst 3 "i") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (inst 3 "i") (("1" (lemma "zero_or_nonzero") (("1" (inst -1 "M" "i") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep 3 :preds? t) (("2" (inst -5 "i") (("1" (lemma "zero_or_nonzero") (("1" (inst -1 "M" "i") (("1" (assert) (("1" (inst -6 "j") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (inst 2 "r") (("2" (inst -6 "r") (("1" (expand "rref_row_inv") (("1" (split -6) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (skeep :preds? t) (("2" (inst -8 "j") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rref? const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cr skolem-const-decl "{cr: below(M`rows) |
         rref?(M, cr) & (FORALL (i: below(cr)): nonzero_row?(M, i))}" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (i skolem-const-decl "below(M`rows)" gauss_jordan nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (j skolem-const-decl "below(M`rows)" gauss_jordan nil) (zero_isnt_nonzero formula-decl nil elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (i skolem-const-decl "below(M`rows)" gauss_jordan nil) (zero_or_nonzero formula-decl nil elementary_matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (r skolem-const-decl "below(M`rows)" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (j skolem-const-decl "below(r)" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil)) shostak)) (elemM2_fixes_pivots_TCC1 0 (elemM2_fixes_pivots_TCC1-1 nil 3524972275 ("" (subtype-tcc) nil nil) nil nil)) (elemM2_fixes_pivots_TCC2 0 (elemM2_fixes_pivots_TCC2-1 nil 3524972275 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM2? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil)) nil)) (elemM2_fixes_pivots_TCC3 0 (elemM2_fixes_pivots_TCC3-1 nil 3524972275 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (replace -7 :hide? t) (("" (replace -7 :hide? t) (("" (hide -4 -5 -6) (("" (expand "nonzero_row?") (("" (skosimp :preds? t) (("" (lemma "elemM2_prop") (("" (inst -1 "M" "cr" "pr" "cr") (("" (expand "rowV") (("" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (inst 3 "j!1") (("1" (assert) nil nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (reveal -2 -3 -4) (("3" (hide-all-but (-1 -2 -3 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma def-decl "real" sigma "reals/") (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (rowV const-decl "Vector[M`cols]" matrices nil) (elemM2_prop formula-decl nil elementary_matrices nil) (nonzero_row? const-decl "bool" elementary_matrices nil)) nil)) (elemM2_fixes_pivots_TCC4 0 (elemM2_fixes_pivots_TCC4-1 nil 3524972275 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (replace -9) (("" (hide -4 -5 -6) (("" (expand "nonzero_row?") (("" (skosimp :preds? t) (("" (replace -5 :hide? t) (("" (replace -5 :hide? t) (("" (inst 4 "j!1") (("1" (lemma "elemM2_prop") (("1" (inst -1 "M" "cr" "pr" "pr") (("1" (expand "rowV") (("1" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonzero_row? const-decl "bool" elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (j!1 skolem-const-decl "below(M2`cols)" gauss_jordan nil) (M2 skolem-const-decl "Matrix" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (* const-decl "Matrix" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (pr skolem-const-decl "{pr: below(M`rows) | pr /= cr}" gauss_jordan nil) (cr skolem-const-decl "below(M`rows)" gauss_jordan nil) (sigma def-decl "real" sigma "reals/") (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (rowV const-decl "Vector[M`cols]" matrices nil) (elemM2_prop formula-decl nil elementary_matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil)) nil)) (elemM2_fixes_pivots_TCC5 0 (elemM2_fixes_pivots_TCC5-1 nil 3524972275 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (hide -4 -5 -6) (("" (replace -4 :hide? t) (("" (replace -4 :hide? t) (("" (split 4) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (expand "nonzero_row?") (("2" (skosimp :preds? t) (("2" (inst 1 "j!1") (("1" (lemma "elemM2_prop") (("1" (inst -1 "M" "cr" "pr" "i") (("1" (expand "rowV") (("1" (assert) (("1" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonzero_row? const-decl "bool" elementary_matrices nil) (j!1 skolem-const-decl "below((elemM2(M`rows)(cr, pr) * M)`cols)" gauss_jordan nil) (pr skolem-const-decl "{pr: below(M`rows) | pr /= cr}" gauss_jordan nil) (cr skolem-const-decl "below(M`rows)" gauss_jordan nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (rowV const-decl "Vector[M`cols]" matrices nil) (elemM2_prop formula-decl nil elementary_matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (elemM2_fixes_pivots 0 (elemM2_fixes_pivots-1 nil 3524972331 ("" (skeep :preds? t) (("" (assert) (("" (skeep 2 :preds? t) (("" (lift-if) (("" (lemma "elemM2_prop") (("" (expand "rowV") (("" (prop) (("1" (replace -1) (("1" (typepred "pivot(elemM2(M`rows)(cr, pr) * M, cr)") (("1" (typepred "min({j_1: below((elemM2(M`rows)(cr, pr) * M)`cols) |
              (elemM2(M`rows)(cr, pr) * M)`matrix(cr, j_1) /= 0})") (("1" (replace -5 :hide? t :dir rl) (("1" (typepred "pivot(M, pr)") (("1" (typepred "min({j_1: below(M`cols) | M`matrix(pr, j_1) /= 0})") (("1" (replace -5 :hide? t :dir rl) (("1" (inst -3 "pivot(elemM2(M`rows)(cr, pr) * M, cr)") (("1" (split -3) (("1" (inst -7 "pivot(M, pr)") (("1" (split -7) (("1" (assert) nil nil) ("2" (expand "nonzero_row?" -13) (("2" (skosimp :preds? t) (("2" (inst -9 "M" "cr" "pr" "cr") (("2" (decompose-equality -9) (("1" (inst -1 "pivot(M, pr)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (inst -9 "M" "cr" "pr" "cr") (("2" (decompose-equality -9) (("1" (inst -1 "pivot(elemM2(M`rows)(cr, pr) * M, cr)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=" -1) (("2" (inst -1 "pivot(M, pr)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=" -1) (("2" (inst -5 "M" "cr" "pr" "cr") (("2" (decompose-equality -5) (("1" (inst -1 "pivot(M, pr)") (("1" (inst -2 "pivot(M, pr)") (("1" (assert) (("1" (replace -1) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "pr") (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (inst -2 "M" "cr" "pr" "pr") (("2" (assert) (("2" (decompose-equality -2) (("1" (typepred "pivot(elemM2(M`rows)(cr, pr) * M, pr)") (("1" (typepred "min({j_1: below((elemM2(M`rows)(cr, pr) * M)`cols) |
              (elemM2(M`rows)(cr, pr) * M)`matrix(pr, j_1) /= 0})") (("1" (replace -5 :hide? t :dir rl) (("1" (typepred "pivot(M, cr)") (("1" (typepred "min({j_1: below(M`cols) | M`matrix(cr, j_1) /= 0})") (("1" (replace -5 :hide? t :dir rl) (("1" (inst -7 "pivot(M, cr)") (("1" (inst -3 "pivot(elemM2(M`rows)(cr, pr) * M, pr)") (("1" (split -3) (("1" (split -7) (("1" (assert) nil nil) ("2" (inst -8 "pivot(M, cr)") (("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -8 "pivot(elemM2(M`rows)(cr, pr) * M, pr)") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=" -1) (("2" (inst -1 "pivot(M, cr)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=" -1) (("2" (inst -1 "pivot(M, cr)") (("1" (assert) (("1" (inst -4 "pivot(M, cr)") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -1 "M" "cr" "pr" "i") (("3" (assert) (("3" (decompose-equality -1) (("1" (typepred "pivot(elemM2(M`rows)(cr, pr) * M, i)") (("1" (typepred "min({j_1: below((elemM2(M`rows)(cr, pr) * M)`cols) |
              (elemM2(M`rows)(cr, pr) * M)`matrix(i, j_1) /= 0})") (("1" (replace -5 :hide? t :dir rl) (("1" (typepred "pivot(M, i)") (("1" (typepred "min({j_1: below(M`cols) | M`matrix(i, j_1) /= 0})") (("1" (replace -5 :hide? t :dir rl) (("1" (inst -7 "pivot(M, i)") (("1" (inst -3 "pivot(elemM2(M`rows)(cr, pr) * M, i)") (("1" (split -3) (("1" (split -7) (("1" (assert) nil nil) ("2" (inst -8 "pivot(M, i)") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -8 "pivot(elemM2(M`rows)(cr, pr) * M, i)") (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "/=" -1) (("2" (expand "member") (("2" (inst -1 "pivot(M, i)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=" -1) (("2" (inst -1 "pivot(M, i)") (("1" (inst -4 "pivot(M, i)") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "i") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rowV const-decl "Vector[M`cols]" matrices nil) (i skolem-const-decl "below((elemM2(M`rows)(cr, pr) * M)`rows)" gauss_jordan nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma def-decl "real" sigma "reals/") (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (pr skolem-const-decl "{pr: below(M`rows) | pr /= cr}" gauss_jordan nil) (cr skolem-const-decl "below(M`rows)" gauss_jordan nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (pivot_prop formula-decl nil gauss_jordan nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (Matrix type-eq-decl nil matrices nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (* const-decl "Matrix" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (elemM2_prop formula-decl nil elementary_matrices nil)) shostak)) (elemM2_rref_pivot_TCC1 0 (elemM2_rref_pivot_TCC1-1 nil 3524925714 ("" (subtype-tcc) nil nil) nil nil)) (elemM2_rref_pivot_TCC2 0 (elemM2_rref_pivot_TCC2-1 nil 3524925714 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil)) nil)) (elemM2_rref_pivot_TCC3 0 (elemM2_rref_pivot_TCC3-1 nil 3524925714 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil)) nil)) (elemM2_rref_pivot_TCC4 0 (elemM2_rref_pivot_TCC4-1 nil 3524925714 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (elemM2? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil)) nil)) (elemM2_rref_pivot_TCC5 0 (elemM2_rref_pivot_TCC5-1 nil 3524982964 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (zero_row? const-decl "bool" elementary_matrices nil) (elemM2? const-decl "bool" elementary_matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (elemM2_rref_pivot_TCC6 0 (elemM2_rref_pivot_TCC6-1 nil 3524982964 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM2? const-decl "bool" elementary_matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil) (* const-decl "Matrix" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (elemM2_rref_pivot_TCC7 0 (elemM2_rref_pivot_TCC7-1 nil 3524982964 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil) (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (elemM2_rref_pivot_TCC8 0 (elemM2_rref_pivot_TCC8-1 nil 3524982964 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (assert) (("" (inst -14 "cr") nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (elemM2_rref_pivot 0 (elemM2_rref_pivot-3 "" 3549344193 ("" (skeep :preds? t) (("" (assert) (("" (lemma "elemM2_prop") (("" (inst -1 "M" "cr" "pr" "_") (("" (expand "rowV") (("" (expand "rref?") (("" (flatten) (("" (assert) (("" (split 2) (("1" (hide-all-but (1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (expand "row_echelon_form_below?") (("3" (flatten) (("3" (split 1) (("1" (skeep :preds? t) (("1" (inst -7 "i" "j") (("1" (assert) (("1" (inst-cp -9 "i") (("1" (assert) (("1" (inst -5 "j") (("1" (assert) (("1" (decompose-equality -5) (("1" (expand "zero_row?" 2) (("1" (skosimp :preds? t) (("1" (expand "zero_row?" -6) (("1" (inst -6 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (inst -7 "i") (("2" (inst-cp -9 "i") (("2" (assert) (("2" (inst -7 "j") (("2" (assert) (("2" (inst-cp -4 "i") (("2" (assert) (("2" (inst -4 "j") (("2" (assert) (("2" (decompose-equality -5) (("1" (decompose-equality -5) (("1" (use "elemM2_fixes_pivots") (("1" (assert) (("1" (inst-cp -1 "i") (("1" (inst -1 "j") (("1" (assert) (("1" (replace -2 :hide? t) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil) ("2" (inst -10 "j") (("2" (expand "nonzero_row?" -10) (("2" (skosimp :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (inst 1 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (inst -5 "i") (("4" (expand "rref_row_inv") (("4" (flatten) (("4" (assert) (("4" (inst-cp -8 "i") (("4" (assert) (("4" (split -7) (("1" (flatten) (("1" (split 1) (("1" (inst -7 "i") (("1" (lift-if) (("1" (assert) (("1" (decompose-equality -7) (("1" (inst -1 "pivot(M, i)") (("1" (use "elemM2_fixes_pivots") (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (typepred "pivot(M, i)") (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (use "elemM2_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (inst -8 "j") (("1" (lift-if) (("1" (split -8) (("1" (flatten) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (inst -5 "pr") (("1" (assert) (("1" (inst -1 "pivot(M, i)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -5 "cr") (("1" (assert) (("1" (inst -1 "pivot(M, i)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, i)") (("1" (inst -4 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (inst -10 "j") (("1" (lift-if) (("1" (split -10) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -8 "pr" "k") (("1" (inst -1 "k") (("1" (assert) nil nil)) nil) ("2" (use "elemM2_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -8 "cr" "k") (("1" (inst -1 "k") (("1" (assert) nil nil)) nil) ("2" (use "elemM2_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "k") (("1" (assert) (("1" (replace -1) (("1" (inst -7 "j" "k") (("1" (assert) (("1" (use "elemM2_fixes_pivots") (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -3) (("1" (skeep :preds? t) (("1" (inst -6 "j") (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -3 "j") (("1" (expand "nonzero_row?" (-3 1)) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-6 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-4 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-3 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-2 -3 -6 1)) (("7" (grind) nil nil)) nil) ("8" (hide-all-but (-1 -2 -5 1)) (("8" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp -1 :preds? t) (("2" (inst -6 "r!1") (("2" (lift-if) (("2" (split -6) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst 1 "cr") (("1" (expand "nonzero_row?" (-14 1)) (("1" (skosimp -14 :preds? t) (("1" (inst 1 "j!1") (("1" (assert) (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-14 1)) (("5" (lemma "elem_prod") (("5" (inst -1 "M" "elemM2(M`rows)(cr, pr)") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "elemMat?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-12 1)) (("6" (use "elem_prod") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "elemMat?") (("2" (propax) nil nil)) nil)) nil)) nil) ("7" (hide-all-but (-11 1)) (("7" (use "elem_prod") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "elemMat?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (hide 4) (("1" (expand "nonzero_row?" -7) (("1" (skosimp -7 :preds? t) (("1" (inst 2 "i") (("1" (expand "nonzero_row?" 2) (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (1)) (("7" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (hide 5) (("1" (inst 3 "r!1") (("1" (expand "nonzero_row?" (-4 3)) (("1" (skosimp -4 :preds? t) (("1" (inst 3 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-5 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-3 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-2 1)) (("7" (grind) nil nil)) nil) ("8" (hide-all-but (-9 1)) (("8" (grind) nil nil)) nil) ("9" (hide-all-but (-7 1)) (("9" (grind) nil nil)) nil) ("10" (hide-all-but (-6 1)) (("10" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep :preds? t) (("5" (lemma "elemM2_prop") (("5" (inst -1 "M" "cr" "pr" "i") (("5" (expand "rowV") (("5" (assert) (("5" (lift-if) (("5" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (expand "nonzero_row?" -11) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -7 "i") (("1" (expand "nonzero_row?" -7) (("1" (skosimp :preds? t) (("1" (expand "nonzero_row?" 2) (("1" (inst 2 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep :preds? t) (("6" (case-replace "i = pr") (("1" (use "elemM2_fixes_pivots") (("1" (assert) (("1" (inst -1 "pr") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (lemma "elemM2_prop") (("1" (reveal -2) (("1" (inst -1 "cr") (("1" (assert) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nonzero_row?" -5) (("1" (skosimp :preds? t) (("1" (assert) (("1" (inst -2 "M" "cr" "pr" "pr") (("1" (expand "rowV") (("1" (decompose-equality -2) (("1" (inst -1 "j!1") (("1" (replace -1 :hide? t) (("1" (inst -13 "cr") (("1" (assert) (("1" (expand "nonzero_row?" 3) (("1" (inst 3 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonzero_row?" 1) (("2" (inst -1 "M" "cr" "pr" "cr") (("2" (expand "rowV") (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" -13) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "elemM2_fixes_pivots") (("2" (assert) (("2" (inst-cp -1 "i") (("2" (inst -1 "cr") (("2" (assert) (("2" (replace -2 :hide? t) (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -12 "i") (("1" (assert) (("1" (lemma "elemM2_prop") (("1" (inst -1 "M" "cr" "pr" "_") (("1" (expand "rowV") (("1" (inst-cp -1 "i") (("1" (assert) (("1" (decompose-equality -2) (("1" (expand "nonzero_row?" -5) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (replace -2 :hide? t) (("1" (expand "nonzero_row?" 4) (("1" (inst 4 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nonzero_row?" -11) (("2" (skosimp :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (inst 1 "j!1") (("1" (use "elemM2_prop") (("1" (expand "rowV") (("1" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (i skolem-const-decl "subrange(cr, (elemM2(M`rows)(cr, pr) * M)`rows - 1)" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (i skolem-const-decl "upto(cr)" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (r!1 skolem-const-decl "subrange(i, M`rows - 1)" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (elem_prod formula-decl nil elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (k skolem-const-decl "below(pivot(elemM2(M`rows)(cr, pr) * M, i))" gauss_jordan nil) (j skolem-const-decl "subrange(i, (elemM2(M`rows)(cr, pr) * M)`rows - 1)" gauss_jordan nil) (j skolem-const-decl "below((elemM2(M`rows)(cr, pr) * M)`rows)" gauss_jordan nil) (i skolem-const-decl "below(cr)" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (NOT const-decl "[bool -> bool]" booleans nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (cr skolem-const-decl "{cr: below(M`rows) |
         rref?(M, cr) & (FORALL (i: below(cr)): nonzero_row?(M, i))}" gauss_jordan nil) (pr skolem-const-decl "{pr: subrange(cr, M`rows - 1) |
         nonzero_row?(M, pr) &
          (FORALL (i: subrange(cr, M`rows - 1)):
             nonzero_row?(M, i) => pivot(M, pr) <= pivot(M, i))}" gauss_jordan nil) (zero_row? const-decl "bool" elementary_matrices nil) (elemM2_fixes_pivots formula-decl nil gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (* const-decl "Matrix" matrices nil) (sigma def-decl "real" sigma "reals/") (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (rowV const-decl "Vector[M`cols]" matrices nil) (elemM2_prop formula-decl nil elementary_matrices nil)) shostak) (elemM2_rref_pivot-2 "" 3547753742 ("" (skeep :preds? t) (("" (assert) (("" (lemma "elemM2_prop") (("" (inst -1 "M" "cr" "pr" "_") (("" (expand "rowV") (("" (expand "rref?") (("" (flatten) (("" (assert) (("" (split 2) (("1" (hide-all-but (1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (expand "row_echelon_form_below?") (("3" (flatten) (("3" (split 1) (("1" (skeep :preds? t) (("1" (inst -7 "i" "j") (("1" (assert) (("1" (inst-cp -9 "i") (("1" (assert) (("1" (inst -5 "j") (("1" (assert) (("1" (decompose-equality -5) (("1" (expand "zero_row?" 2) (("1" (skosimp :preds? t) (("1" (expand "zero_row?" -6) (("1" (inst -6 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (inst -7 "i") (("2" (inst-cp -9 "i") (("2" (assert) (("2" (inst -7 "j") (("2" (assert) (("2" (inst-cp -4 "i") (("2" (assert) (("2" (inst -4 "j") (("2" (assert) (("2" (decompose-equality -5) (("1" (decompose-equality -5) (("1" (use "elemM2_fixes_pivots") (("1" (assert) (("1" (inst-cp -1 "i") (("1" (inst -1 "j") (("1" (assert) (("1" (replace -2 :hide? t) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil) ("2" (inst -10 "j") (("2" (expand "nonzero_row?" -10) (("2" (skosimp :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (inst 1 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (inst -5 "i") (("4" (expand "rref_row_inv") (("4" (flatten) (("4" (assert) (("4" (inst-cp -8 "i") (("4" (assert) (("4" (split -7) (("1" (flatten) (("1" (split 1) (("1" (inst -7 "i") (("1" (lift-if) (("1" (assert) (("1" (decompose-equality -7) (("1" (inst -1 "pivot(M, i)") (("1" (use "elemM2_fixes_pivots") (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (typepred "pivot(M, i)") (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (use "elemM2_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (inst -8 "j") (("1" (lift-if) (("1" (split -8) (("1" (flatten) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (inst -5 "pr") (("1" (assert) (("1" (inst -1 "pivot(M, i)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -5 "cr") (("1" (assert) (("1" (inst -1 "pivot(M, i)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, i)") (("1" (inst -4 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (inst -10 "j") (("1" (lift-if) (("1" (split -10) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -8 "pr" "k") (("1" (inst -1 "k") (("1" (assert) nil nil)) nil) ("2" (use "elemM2_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -8 "cr" "k") (("1" (inst -1 "k") (("1" (assert) nil nil)) nil) ("2" (use "elemM2_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "k") (("1" (assert) (("1" (replace -1) (("1" (inst -7 "j" "k") (("1" (assert) (("1" (use "elemM2_fixes_pivots") (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-6 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -3) (("1" (skeep :preds? t) (("1" (inst -6 "j") (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -3 "j") (("1" (expand "nonzero_row?" (-3 1)) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-3 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-6 -3 -2 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-5 -1 -2 1)) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp -1 :preds? t) (("2" (inst -6 "r!1") (("2" (lift-if) (("2" (split -6) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst 1 "cr") (("1" (expand "nonzero_row?" (-14 1)) (("1" (skosimp -14 :preds? t) (("1" (inst 1 "j!1") (("1" (assert) (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-14 1)) (("5" (lemma "elem_prod") (("5" (inst -1 "M" "elemM2(M`rows)(cr, pr)") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "elemMat?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-12 1)) (("6" (use "elem_prod") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "elemMat?") (("2" (propax) nil nil)) nil)) nil)) nil) ("7" (hide-all-but (-11 1)) (("7" (use "elem_prod") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "elemMat?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (hide 4) (("1" (expand "nonzero_row?" -7) (("1" (skosimp -7 :preds? t) (("1" (inst 2 "i") (("1" (expand "nonzero_row?" 2) (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (1)) (("7" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (hide 5) (("1" (inst 3 "r!1") (("1" (expand "nonzero_row?" (-4 3)) (("1" (skosimp -4 :preds? t) (("1" (inst 3 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-9 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-7 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-6 1)) (("7" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep :preds? t) (("5" (lemma "elemM2_prop") (("5" (inst -1 "M" "cr" "pr" "i") (("5" (expand "rowV") (("5" (assert) (("5" (lift-if) (("5" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (expand "nonzero_row?" -11) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -7 "i") (("1" (expand "nonzero_row?" -7) (("1" (skosimp :preds? t) (("1" (expand "nonzero_row?" 2) (("1" (inst 2 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep :preds? t) (("6" (case-replace "i = pr") (("1" (use "elemM2_fixes_pivots") (("1" (assert) (("1" (inst -1 "pr") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (lemma "elemM2_prop") (("1" (reveal -2) (("1" (inst -1 "cr") (("1" (assert) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nonzero_row?" -5) (("1" (skosimp :preds? t) (("1" (assert) (("1" (inst -2 "M" "cr" "pr" "pr") (("1" (expand "rowV") (("1" (decompose-equality -2) (("1" (inst -1 "j!1") (("1" (replace -1 :hide? t) (("1" (inst -13 "cr") (("1" (assert) (("1" (expand "nonzero_row?" 3) (("1" (inst 3 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonzero_row?" 1) (("2" (inst -1 "M" "cr" "pr" "cr") (("2" (expand "rowV") (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" -13) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "elemM2_fixes_pivots") (("2" (assert) (("2" (inst-cp -1 "i") (("2" (inst -1 "cr") (("2" (assert) (("2" (replace -2 :hide? t) (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -12 "i") (("1" (assert) (("1" (lemma "elemM2_prop") (("1" (inst -1 "M" "cr" "pr" "_") (("1" (expand "rowV") (("1" (inst-cp -1 "i") (("1" (assert) (("1" (decompose-equality -2) (("1" (expand "nonzero_row?" -5) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (replace -2 :hide? t) (("1" (expand "nonzero_row?" 4) (("1" (inst 4 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nonzero_row?" -11) (("2" (skosimp :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (inst 1 "j!1") (("1" (use "elemM2_prop") (("1" (expand "rowV") (("1" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((elemM2_prop formula-decl nil elementary_matrices nil) (rowV const-decl "Vector[M`cols]" matrices nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") nil (real_times_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) nil (elemM2_fixes_pivots formula-decl nil gauss_jordan nil) nil nil nil nil nil (NOT const-decl "[bool -> bool]" booleans nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) nil nil nil nil (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elem_prod formula-decl nil elementary_matrices nil) nil nil nil (rref_row_inv const-decl "bool" gauss_jordan nil) nil nil nil nil nil nil (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) nil (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak) (elemM2_rref_pivot-1 nil 3524946277 ("" (skeep :preds? t) (("" (assert) (("" (lemma "elemM2_prop") (("" (inst -1 "M" "cr" "pr" "_") (("" (expand "rowV") (("" (expand "rref?") (("" (flatten) (("" (assert) (("" (split 2) (("1" (hide-all-but (1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (expand "row_echelon_form_below?") (("3" (flatten) (("3" (split 1) (("1" (skeep :preds? t) (("1" (inst -7 "i" "j") (("1" (assert) (("1" (inst-cp -9 "i") (("1" (assert) (("1" (inst -5 "j") (("1" (assert) (("1" (decompose-equality -5) (("1" (expand "zero_row?" 2) (("1" (skosimp :preds? t) (("1" (expand "zero_row?" -6) (("1" (inst -6 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (inst -7 "i") (("2" (inst-cp -9 "i") (("2" (assert) (("2" (inst -7 "j") (("2" (assert) (("2" (inst-cp -4 "i") (("2" (assert) (("2" (inst -4 "j") (("2" (assert) (("2" (decompose-equality -5) (("1" (decompose-equality -5) (("1" (use "elemM2_fixes_pivots") (("1" (assert) (("1" (inst-cp -1 "i") (("1" (inst -1 "j") (("1" (assert) (("1" (replace -2 :hide? t) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil) ("2" (inst -10 "j") (("2" (expand "nonzero_row?" -10) (("2" (skosimp :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (inst 1 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (inst -5 "i") (("4" (expand "rref_row_inv") (("4" (flatten) (("4" (assert) (("4" (inst-cp -8 "i") (("4" (assert) (("4" (split -7) (("1" (flatten) (("1" (split 1) (("1" (inst -7 "i") (("1" (lift-if) (("1" (assert) (("1" (decompose-equality -7) (("1" (inst -1 "pivot(M, i)") (("1" (use "elemM2_fixes_pivots") (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (typepred "pivot(M, i)") (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (use "elemM2_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (inst -8 "j") (("1" (lift-if) (("1" (split -8) (("1" (flatten) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (inst -5 "pr") (("1" (assert) (("1" (inst -1 "pivot(M, i)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -5 "cr") (("1" (assert) (("1" (inst -1 "pivot(M, i)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, i)") (("1" (inst -4 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (inst -10 "j") (("1" (lift-if) (("1" (split -10) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -8 "pr" "k") (("1" (inst -1 "k") (("1" (assert) nil nil)) nil) ("2" (use "elemM2_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -8 "cr" "k") (("1" (inst -1 "k") (("1" (assert) nil nil)) nil) ("2" (use "elemM2_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "k") (("1" (assert) (("1" (replace -1) (("1" (inst -7 "j" "k") (("1" (assert) (("1" (use "elemM2_fixes_pivots") (("1" (assert) (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -3) (("1" (skeep :preds? t) (("1" (inst -6 "j") (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -3 "j") (("1" (expand "nonzero_row?" (-3 1)) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-6 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-6 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-4 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-3 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (1)) (("7" (grind) nil nil)) nil) ("8" (hide-all-but (1)) (("8" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp -1 :preds? t) (("2" (inst -6 "r!1") (("2" (lift-if) (("2" (split -6) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst 1 "cr") (("1" (expand "nonzero_row?" (-14 1)) (("1" (skosimp -14 :preds? t) (("1" (inst 1 "j!1") (("1" (assert) (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-14 1)) (("5" (lemma "elem_prod") (("5" (inst -1 "M" "elemM2(M`rows)(cr, pr)") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "elemMat?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-12 1)) (("6" (use "elem_prod") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "elemMat?") (("2" (propax) nil nil)) nil)) nil)) nil) ("7" (hide-all-but (-11 1)) (("7" (use "elem_prod") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "elemMat?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (hide 4) (("1" (expand "nonzero_row?" -7) (("1" (skosimp -7 :preds? t) (("1" (inst 2 "i") (("1" (expand "nonzero_row?" 2) (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (1)) (("7" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (hide 5) (("1" (inst 3 "r!1") (("1" (expand "nonzero_row?" (-4 3)) (("1" (skosimp -4 :preds? t) (("1" (inst 3 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-10 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-8 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-7 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-5 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-3 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-2 1)) (("7" (grind) nil nil)) nil) ("8" (hide-all-but (-9 1)) (("8" (grind) nil nil)) nil) ("9" (hide-all-but (-7 1)) (("9" (grind) nil nil)) nil) ("10" (hide-all-but (-6 1)) (("10" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep :preds? t) (("5" (lemma "elemM2_prop") (("5" (inst -1 "M" "cr" "pr" "i") (("5" (expand "rowV") (("5" (assert) (("5" (lift-if) (("5" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (expand "nonzero_row?" -11) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -7 "i") (("1" (expand "nonzero_row?" -7) (("1" (skosimp :preds? t) (("1" (expand "nonzero_row?" 2) (("1" (inst 2 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep :preds? t) (("6" (case-replace "i = pr") (("1" (use "elemM2_fixes_pivots") (("1" (assert) (("1" (inst -1 "pr") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (lemma "elemM2_prop") (("1" (reveal -2) (("1" (inst -1 "cr") (("1" (assert) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nonzero_row?" -5) (("1" (skosimp :preds? t) (("1" (assert) (("1" (inst -2 "M" "cr" "pr" "pr") (("1" (expand "rowV") (("1" (decompose-equality -2) (("1" (inst -1 "j!1") (("1" (replace -1 :hide? t) (("1" (inst -13 "cr") (("1" (assert) (("1" (expand "nonzero_row?" 3) (("1" (inst 3 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonzero_row?" 1) (("2" (inst -1 "M" "cr" "pr" "cr") (("2" (expand "rowV") (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" -13) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "elemM2_fixes_pivots") (("2" (assert) (("2" (inst-cp -1 "i") (("2" (inst -1 "cr") (("2" (assert) (("2" (replace -2 :hide? t) (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -12 "i") (("1" (assert) (("1" (lemma "elemM2_prop") (("1" (inst -1 "M" "cr" "pr" "_") (("1" (expand "rowV") (("1" (inst-cp -1 "i") (("1" (assert) (("1" (decompose-equality -2) (("1" (expand "nonzero_row?" -5) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (replace -2 :hide? t) (("1" (expand "nonzero_row?" 4) (("1" (inst 4 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nonzero_row?" -11) (("2" (skosimp :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (inst 1 "j!1") (("1" (use "elemM2_prop") (("1" (expand "rowV") (("1" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (elem_prod formula-decl nil elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (NOT const-decl "[bool -> bool]" booleans nil) (elemM2_fixes_pivots formula-decl nil gauss_jordan nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma "reals/") (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (rowV const-decl "Vector[M`cols]" matrices nil) (elemM2_prop formula-decl nil elementary_matrices nil)) shostak)) (elemM3_fixes_pivots_TCC1 0 (elemM3_fixes_pivots_TCC1-1 nil 3524987263 ("" (skeep :preds? t) (("" (assert) (("" (use "pivot_prop") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (pivot_prop formula-decl nil gauss_jordan nil)) nil)) (elemM3_fixes_pivots_TCC2 0 (elemM3_fixes_pivots_TCC2-1 nil 3524987263 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemM3? const-decl "bool" elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil)) nil)) (elemM3_fixes_pivots_TCC3 0 (elemM3_fixes_pivots_TCC3-3 "" 3549344362 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (skeep :preds? t) (("" (skeep :preds? t) (("" (replace -10 :hide? t) (("" (split 1) (("1" (replace -9 :hide? t) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (replace -9) (("2" (expand "nonzero_row?" (-10 1)) (("2" (skosimp :preds? t) (("2" (lemma "elemM3_prop") (("2" (inst -1 "M" "cr" "1/v" "i") (("1" (expand "rowV") (("1" (assert) (("1" (lift-if) (("1" (split -1) (("1" (flatten) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (expand "nonzero_row?" -9) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (replace -1 :hide? t) (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (* const-decl "Matrix" matrices nil) (sigma def-decl "real" sigma "reals/") (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (elemM3_prop formula-decl nil elementary_matrices nil) (rowV const-decl "Vector[M`cols]" matrices nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (Index type-eq-decl nil vectors "vectors/") (* const-decl "Vector" vectors "vectors/") (M skolem-const-decl "Matrix" gauss_jordan nil) (i skolem-const-decl "below(M3`rows)" gauss_jordan nil) (M3 skolem-const-decl "Matrix" gauss_jordan nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)) shostak) (elemM3_fixes_pivots_TCC3-2 "" 3547753915 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (skeep :preds? t) (("" (skeep :preds? t) (("" (replace -10 :hide? t) (("" (split 1) (("1" (replace -9 :hide? t) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (replace -9) (("2" (expand "nonzero_row?" (-10 1)) (("2" (skosimp :preds? t) (("2" (lemma "elemM3_prop") (("2" (inst -1 "M" "cr" "1/v" "i") (("1" (expand "rowV") (("1" (assert) (("1" (lift-if) (("1" (split -1) (("1" (flatten) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (expand "nonzero_row?" -9) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (replace -1 :hide? t) (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) nil nil nil (* const-decl "Vector" vectors "vectors/") (Index type-eq-decl nil vectors "vectors/") (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rowV const-decl "Vector[M`cols]" matrices nil) (elemM3_prop formula-decl nil elementary_matrices nil) nil (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") nil (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak) (elemM3_fixes_pivots_TCC3-1 nil 3524987263 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (skeep :preds? t) (("" (skeep :preds? t) (("" (replace -10 :hide? t) (("" (split 1) (("1" (replace -9 :hide? t) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (replace -9) (("2" (expand "nonzero_row?" (-10 1)) (("2" (skosimp :preds? t) (("2" (lemma "elemM3_prop") (("2" (inst -1 "M" "cr" "1/v" "i") (("1" (expand "rowV") (("1" (assert) (("1" (lift-if) (("1" (split -1) (("1" (flatten) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (expand "nonzero_row?" -9) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (replace -1 :hide? t) (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma "reals/") (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (elemM3_prop formula-decl nil elementary_matrices nil) (rowV const-decl "Vector[M`cols]" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (Index type-eq-decl nil vectors "vectors/") (* const-decl "Vector" vectors "vectors/") (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)) nil)) (elemM3_fixes_pivots 0 (elemM3_fixes_pivots-1 nil 3524987267 ("" (skeep :preds? t) (("" (assert) (("" (skeep :preds? t) (("" (typepred "pivot(M, i)") (("" (typepred "min({j_1: below(M`cols) | M`matrix(i, j_1) /= 0})") (("1" (replace -5 :dir rl :hide? t) (("1" (typepred "pivot(elemM3(M`rows)(cr)(1 / M`matrix(cr, pivot(M, cr))) * M, i)") (("1" (typepred "min({j_1:
                  below((elemM3(M`rows)(cr)(1 / M`matrix(cr, pivot(M, cr))) *
                          M)`cols)
                  |
                  (elemM3(M`rows)(cr)(1 / M`matrix(cr, pivot(M, cr))) *
                    M)`matrix
                      (i, j_1)
                   /= 0})") (("1" (replace -5 :dir rl :hide? t) (("1" (inst -3 "pivot(M, i)") (("1" (split -3) (("1" (inst -7 "pivot(elemM3(M`rows)(cr)(1 / M`matrix(cr, pivot(M, cr))) * M, i)") (("1" (split -7) (("1" (assert) nil nil) ("2" (lemma "elemM3_prop") (("2" (inst -1 "M" "cr" "1 / M`matrix(cr, pivot(M, cr))" "i") (("2" (expand "rowV") (("2" (assert) (("2" (lift-if) (("2" (split -1) (("1" (flatten) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (inst -1 "pivot(elemM3(M`rows)(cr)(1 / M`matrix(cr, pivot(M, cr))) * M,
                                   i)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(elemM3(M`rows)(cr)(1 / M`matrix(cr, pivot(M, cr))) * M,
                                   i)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (lemma "elemM3_prop") (("2" (inst -1 "M" "cr" "1 / M`matrix(cr, pivot(M, cr))" "i") (("2" (expand "rowV") (("2" (expand "*" -1 2) (("2" (lift-if) (("2" (split -1) (("1" (flatten) (("1" (decompose-equality -2) (("1" (inst -1 "pivot(M, cr)") (("1" (assert) nil nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, i)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=" -1) (("2" (skosimp :preds? t) (("2" (expand "nonzero_row?" -10) (("2" (skosimp :preds? t) (("2" (inst -2 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=" -1) (("2" (expand "nonzero_row?" -7) (("2" (skosimp :preds? t) (("2" (lemma "elemM3_prop") (("2" (inst -1 "M" "cr" "1 / M`matrix(cr, pivot(M, cr))" "i") (("2" (expand "rowV") (("2" (assert) (("2" (expand "*" -1 2) (("2" (lift-if) (("2" (split -1) (("1" (flatten) (("1" (decompose-equality -2) (("1" (inst -1 "j!1") (("1" (inst -4 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (inst -3 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (nzreal nonempty-type-eq-decl nil reals nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Matrix type-eq-decl nil matrices nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (i skolem-const-decl "below((elemM3(M`rows)(cr)(1 / M`matrix(cr, pivot(M, cr))) * M)`rows)" gauss_jordan nil) (cr skolem-const-decl "{cr: below(M`rows) | nonzero_row?(M, cr)}" gauss_jordan nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (elemM3_prop formula-decl nil elementary_matrices nil) (rowV const-decl "Vector[M`cols]" matrices nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (Index type-eq-decl nil vectors "vectors/") (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma "reals/") (int_minus_int_is_int application-judgement "int" integers nil) (* const-decl "Vector" vectors "vectors/") (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak)) (elemM3_rref_pivot_TCC1 0 (elemM3_rref_pivot_TCC1-1 nil 3524935424 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (elemM3_rref_pivot_TCC2 0 (elemM3_rref_pivot_TCC2-1 nil 3524935424 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (elemM3_rref_pivot_TCC3 0 (elemM3_rref_pivot_TCC3-1 nil 3524935424 ("" (skeep :preds? t) (("" (inst -3 "cr") nil nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil)) nil)) (elemM3_rref_pivot_TCC4 0 (elemM3_rref_pivot_TCC4-1 nil 3524935424 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (lemma "pivot_prop") (("" (inst -1 "M" "cr") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pivot_prop formula-decl nil gauss_jordan nil)) nil)) (elemM3_rref_pivot_TCC5 0 (elemM3_rref_pivot_TCC5-1 nil 3525036228 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (hide -4 -5 -6 -7 -8 -9 1) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((square? const-decl "bool" matrices nil) (squareMat? const-decl "bool" matrices nil) (/= const-decl "boolean" notequal nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil)) (elemM3_rref_pivot_TCC6 0 (elemM3_rref_pivot_TCC6-1 nil 3525036228 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (elemM3_rref_pivot_TCC7 0 (elemM3_rref_pivot_TCC7-1 nil 3525036228 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil) (* const-decl "Matrix" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (elemM3_rref_pivot_TCC8 0 (elemM3_rref_pivot_TCC8-1 nil 3525036228 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil) (* const-decl "Matrix" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (elemM3_rref_pivot_TCC9 0 (elemM3_rref_pivot_TCC9-1 nil 3525036228 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (assert) (("" (inst -11 "cr") nil nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) nil)) (elemM3_rref_pivot_TCC10 0 (elemM3_rref_pivot_TCC10-1 nil 3525909420 ("" (subtype-tcc) nil nil) ((elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil) (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (elemM3_rref_pivot 0 (elemM3_rref_pivot-3 "" 3549346335 ("" (skeep :preds? t) (("" (assert) (("" (lemma "elemM3_prop") (("" (expand "rowV") (("" (inst -1 "M" "cr" "1 / M`matrix(cr, pivot(M, cr))" "_") (("1" (split 2) (("1" (hide-all-but (1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (expand "rref?") (("3" (flatten) (("3" (split 1) (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -7 "i" "j") (("1" (assert) (("1" (inst-cp -5 "i") (("1" (inst -5 "j") (("1" (assert) (("1" (decompose-equality -5) (("1" (decompose-equality -6) (("1" (split 2) (("1" (expand "nonzero_row?" -5) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (replace -2 :hide? t) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (skosimp :preds? t) (("2" (expand "zero_row?" -7) (("2" (inst -3 "j!1") (("1" (inst -7 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (use "elemM3_fixes_pivots") (("2" (assert) (("2" (inst-cp -1 "i") (("2" (inst -1 "j") (("2" (assert) (("2" (replace -2 :hide? t) (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -7 "i") (("1" (assert) (("1" (inst-cp -9 "i") (("1" (assert) (("1" (inst -7 "j") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -9 "j") (("2" (expand "nonzero_row?" -9) (("2" (skosimp :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (inst 1 "j!1") (("1" (inst -5 "j") (("1" (expand "*" -5 2) (("1" (decompose-equality -5) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (expand "rref_row_inv") (("2" (flatten) (("2" (use "elemM3_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (replace -1 :hide? t :actuals? t) (("2" (inst -7 "i") (("2" (assert) (("2" (split -7) (("1" (flatten) (("1" (split 1) (("1" (inst -7 "i") (("1" (lift-if) (("1" (assert) (("1" (decompose-equality -7) (("1" (inst -1 "pivot(M, i)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (inst -8 "j") (("1" (inst -3 "j") (("1" (lift-if) (("1" (split -8) (("1" (flatten) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (inst -6 "j" "k") (("1" (inst -10 "j") (("1" (expand "*" -10 2) (("1" (lift-if) (("1" (split -10) (("1" (flatten) (("1" (decompose-equality -2) (("1" (inst -1 "k") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "k") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (split -3) (("1" (skosimp 1 :preds? t) (("1" (inst -2 "j!1") (("1" (expand "nonzero_row?" (-2 1)) (("1" (skosimp -2 :preds? t) (("1" (inst -6 "j!1") (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -1 "j!2") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst 2 "j!2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp -1 :preds? t) (("2" (inst 1 "r!1") (("1" (expand "nonzero_row?" (-3 1)) (("1" (skosimp -3 :preds? t) (("1" (inst 1 "j!1") (("1" (inst -6 "r!1") (("1" (assert) (("1" (lift-if) (("1" (split -6) (("1" (flatten) (("1" (replace -1) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (inst -7 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (inst -5 "i") (("4" (expand "nonzero_row?" (-5 1)) (("4" (inst -2 "i") (("4" (assert) (("4" (lift-if) (("4" (split -2) (("1" (flatten) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (skosimp -6 :preds? t) (("1" (inst -2 "j!1") (("1" (assert) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality -7) (("1" (inst -1 "j!1") (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-11 1)) (("3" (grind) nil nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil) ("5" (decompose-equality -6) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-10 1)) (("3" (grind) nil nil)) nil)) nil) ("6" (hide-all-but (-7 1)) (("6" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp :preds? t) (("2" (decompose-equality -2) (("1" (inst 2 "j!1") (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil) ("5" (hide -1 -4 -7 4) (("5" (lemma "pivot_prop") (("5" (inst -1 "M" "cr") (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide-all-but (1)) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (use "elemM3_fixes_pivots") (("5" (assert) (("5" (inst -1 "cr") (("5" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -1 "cr") (("1" (expand "*" -1 2) (("1" (decompose-equality -1) (("1" (inst -1 "pivot(M, cr)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "cr") (("2" (expand "nonzero_row?" (-4 1)) (("2" (skosimp -4 :preds? t) (("2" (inst 1 "j!1") (("1" (inst -2 "cr") (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (inst -1 "j!1") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep :preds? t) (("6" (lemma "elemM3_fixes_pivots") (("6" (inst -1 "M" "cr") (("6" (assert) (("6" (inst-cp -1 "cr") (("6" (inst -1 "i") (("6" (assert) (("6" (replace -1 :hide? t) (("6" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -8 "i") (("1" (assert) (("1" (inst -4 "i") (("1" (assert) (("1" (decompose-equality -4) (("1" (expand "nonzero_row?" (-4 2)) (("1" (skosimp -4 :preds? t) (("1" (inst 3 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -7 "cr") (("2" (inst -4 "cr") (("2" (expand "*" -4 2) (("2" (decompose-equality -4) (("1" (expand "nonzero_row?" (-7 1)) (("1" (skosimp -7 :preds? t) (("1" (inst 1 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "pivot_prop") (("2" (inst -1 "M" "cr") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rowV const-decl "Vector[M`cols]" matrices nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (j skolem-const-decl "below((elemM3(M`rows)(cr)(1 / M`matrix(cr, pivot(M, cr))) * M)`rows)" gauss_jordan nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (Index type-eq-decl nil vectors "vectors/") (i skolem-const-decl "below(cr)" gauss_jordan nil) (j skolem-const-decl "subrange(i,
         (elemM3(M`rows)(cr)(1 / M`matrix(cr, pivot(M, cr))) * M)`rows - 1)" gauss_jordan nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (r!1 skolem-const-decl "subrange(i, M`rows - 1)" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (zero_row? const-decl "bool" elementary_matrices nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (NOT const-decl "[bool -> bool]" booleans nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (* const-decl "Vector" vectors "vectors/") (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (elemM3_fixes_pivots formula-decl nil gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (pivot_prop formula-decl nil gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (j!1 skolem-const-decl "below((elemM3(M`rows)(cr)(1 / M`matrix(cr, pivot(M, cr))) * M)`cols)" gauss_jordan nil) (i skolem-const-decl "subrange(cr,
         (elemM3(M`rows)(cr)(1 / M`matrix(cr, pivot(M, cr))) * M)`rows - 1)" gauss_jordan nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (nzreal nonempty-type-eq-decl nil reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (/= const-decl "boolean" notequal nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (cr skolem-const-decl "{cr: below(M`rows) |
         rref?(M, cr) &
          (FORALL (i: upto(cr)): nonzero_row?(M, i)) &
           (FORALL (i: subrange(cr, M`rows - 1)):
              nonzero_row?(M, i) => pivot(M, cr) <= pivot(M, i))}" gauss_jordan nil) (elemM3_prop formula-decl nil elementary_matrices nil)) shostak) (elemM3_rref_pivot-2 "" 3547754436 ("" (skeep :preds? t) (("" (assert) (("" (lemma "elemM3_prop") (("" (expand "rowV") (("" (inst -1 "M" "cr" "1 / M`matrix(cr, pivot(M, cr))" "_") (("1" (split 2) (("1" (hide-all-but (1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (expand "rref?") (("3" (flatten) (("3" (split 1) (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -7 "i" "j") (("1" (assert) (("1" (inst-cp -5 "i") (("1" (inst -5 "j") (("1" (assert) (("1" (decompose-equality -5) (("1" (decompose-equality -6) (("1" (split 2) (("1" (expand "nonzero_row?" -5) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (replace -2 :hide? t) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (skosimp :preds? t) (("2" (expand "zero_row?" -7) (("2" (inst -3 "j!1") (("1" (inst -7 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (use "elemM3_fixes_pivots") (("2" (assert) (("2" (inst-cp -1 "i") (("2" (inst -1 "j") (("2" (assert) (("2" (replace -2 :hide? t) (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -7 "i") (("1" (assert) (("1" (inst-cp -9 "i") (("1" (assert) (("1" (inst -7 "j") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -9 "j") (("2" (expand "nonzero_row?" -9) (("2" (skosimp :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (inst 1 "j!1") (("1" (inst -5 "j") (("1" (expand "*" -5 2) (("1" (decompose-equality -5) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (expand "rref_row_inv") (("2" (flatten) (("2" (use "elemM3_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (replace -1 :hide? t :actuals? t) (("2" (inst -7 "i") (("2" (assert) (("2" (split -7) (("1" (flatten) (("1" (split 1) (("1" (inst -7 "i") (("1" (lift-if) (("1" (assert) (("1" (decompose-equality -7) (("1" (inst -1 "pivot(M, i)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (inst -8 "j") (("1" (inst -3 "j") (("1" (lift-if) (("1" (split -8) (("1" (flatten) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (inst -6 "j" "k") (("1" (inst -10 "j") (("1" (expand "*" -10 2) (("1" (lift-if) (("1" (split -10) (("1" (flatten) (("1" (decompose-equality -2) (("1" (inst -1 "k") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "k") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (split -3) (("1" (skosimp 1 :preds? t) (("1" (inst -2 "j!1") (("1" (expand "nonzero_row?" (-2 1)) (("1" (skosimp -2 :preds? t) (("1" (inst -6 "j!1") (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -1 "j!2") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst 2 "j!2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp -1 :preds? t) (("2" (inst 1 "r!1") (("1" (expand "nonzero_row?" (-3 1)) (("1" (skosimp -3 :preds? t) (("1" (inst 1 "j!1") (("1" (inst -6 "r!1") (("1" (assert) (("1" (lift-if) (("1" (split -6) (("1" (flatten) (("1" (replace -1) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (inst -7 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (inst -5 "i") (("4" (expand "nonzero_row?" (-5 1)) (("4" (inst -2 "i") (("4" (assert) (("4" (lift-if) (("4" (split -2) (("1" (flatten) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (skosimp -6 :preds? t) (("1" (inst -2 "j!1") (("1" (assert) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality -7) (("1" (inst -1 "j!1") (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-11 1)) (("3" (grind) nil nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil) ("5" (decompose-equality -6) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-10 1)) (("3" (grind) nil nil)) nil)) nil) ("6" (hide-all-but (-7 1)) (("6" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (skosimp -5 :preds? t) (("1" (inst 2 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (1)) (("3" (grind) nil nil)) nil) ("4" (decompose-equality -5) (("1" (inst 2 "j!2") (("1" (inst -1 "j!2") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (1)) (("3" (grind) nil nil)) nil)) nil) ("5" (hide-all-but (1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (use "elemM3_fixes_pivots") (("5" (assert) (("5" (inst -1 "cr") (("5" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -1 "cr") (("1" (expand "*" -1 2) (("1" (decompose-equality -1) (("1" (inst -1 "pivot(M, cr)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "cr") (("2" (expand "nonzero_row?" (-4 1)) (("2" (skosimp -4 :preds? t) (("2" (inst 1 "j!1") (("1" (inst -2 "cr") (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (inst -1 "j!1") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep :preds? t) (("6" (lemma "elemM3_fixes_pivots") (("6" (inst -1 "M" "cr") (("6" (assert) (("6" (inst-cp -1 "cr") (("6" (inst -1 "i") (("6" (assert) (("6" (replace -1 :hide? t) (("6" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -8 "i") (("1" (assert) (("1" (inst -4 "i") (("1" (assert) (("1" (decompose-equality -4) (("1" (expand "nonzero_row?" (-4 2)) (("1" (skosimp -4 :preds? t) (("1" (inst 3 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -7 "cr") (("2" (inst -4 "cr") (("2" (expand "*" -4 2) (("2" (decompose-equality -4) (("1" (expand "nonzero_row?" (-7 1)) (("1" (skosimp -7 :preds? t) (("1" (inst 1 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "pivot_prop") (("2" (inst -1 "M" "cr") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((elemM3_prop formula-decl nil elementary_matrices nil) nil (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) nil (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) nil (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nzreal nonempty-type-eq-decl nil reals nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) nil nil nil nil (pivot_prop formula-decl nil gauss_jordan nil) nil nil (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) nil (elemM3_fixes_pivots formula-decl nil gauss_jordan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "Vector" vectors "vectors/") nil (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (NOT const-decl "[bool -> bool]" booleans nil) nil nil (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) nil nil (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) nil nil (Index type-eq-decl nil vectors "vectors/") (* const-decl "[numfield, numfield -> numfield]" number_fields nil) nil (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) nil (sigma def-decl "real" sigma "reals/") (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (rowV const-decl "Vector[M`cols]" matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak) (elemM3_rref_pivot-1 nil 3524986751 ("" (skeep :preds? t) (("" (assert) (("" (lemma "elemM3_prop") (("" (expand "rowV") (("" (inst -1 "M" "cr" "1 / M`matrix(cr, pivot(M, cr))" "_") (("1" (split 2) (("1" (hide-all-but (1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (expand "rref?") (("3" (flatten) (("3" (split 1) (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -7 "i" "j") (("1" (assert) (("1" (inst-cp -5 "i") (("1" (inst -5 "j") (("1" (assert) (("1" (decompose-equality -5) (("1" (decompose-equality -6) (("1" (split 2) (("1" (expand "nonzero_row?" -5) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (replace -2 :hide? t) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (skosimp :preds? t) (("2" (expand "zero_row?" -7) (("2" (inst -3 "j!1") (("1" (inst -7 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (use "elemM3_fixes_pivots") (("2" (assert) (("2" (inst-cp -1 "i") (("2" (inst -1 "j") (("2" (assert) (("2" (replace -2 :hide? t) (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -7 "i") (("1" (assert) (("1" (inst-cp -9 "i") (("1" (assert) (("1" (inst -7 "j") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -9 "j") (("2" (expand "nonzero_row?" -9) (("2" (skosimp :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (inst 1 "j!1") (("1" (inst -5 "j") (("1" (expand "*" -5 2) (("1" (decompose-equality -5) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (expand "rref_row_inv") (("2" (flatten) (("2" (use "elemM3_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (replace -1 :hide? t :actuals? t) (("2" (inst -7 "i") (("2" (assert) (("2" (split -7) (("1" (flatten) (("1" (split 1) (("1" (inst -7 "i") (("1" (lift-if) (("1" (assert) (("1" (decompose-equality -7) (("1" (inst -1 "pivot(M, i)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (inst -8 "j") (("1" (inst -3 "j") (("1" (lift-if) (("1" (split -8) (("1" (flatten) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (inst -6 "j" "k") (("1" (inst -10 "j") (("1" (expand "*" -10 2) (("1" (lift-if) (("1" (split -10) (("1" (flatten) (("1" (decompose-equality -2) (("1" (inst -1 "k") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "k") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (split -3) (("1" (skosimp 1 :preds? t) (("1" (inst -2 "j!1") (("1" (expand "nonzero_row?" (-2 1)) (("1" (skosimp -2 :preds? t) (("1" (inst -6 "j!1") (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -1 "j!2") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst 2 "j!2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp -1 :preds? t) (("2" (inst 1 "r!1") (("1" (expand "nonzero_row?" (-3 1)) (("1" (skosimp -3 :preds? t) (("1" (inst 1 "j!1") (("1" (inst -6 "r!1") (("1" (assert) (("1" (lift-if) (("1" (split -6) (("1" (flatten) (("1" (replace -1) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (inst -7 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (inst -5 "i") (("4" (expand "nonzero_row?" (-5 1)) (("4" (inst -2 "i") (("4" (assert) (("4" (lift-if) (("4" (split -2) (("1" (flatten) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (skosimp -6 :preds? t) (("1" (inst -2 "j!1") (("1" (assert) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality -7) (("1" (inst -1 "j!1") (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-11 1)) (("3" (grind) nil nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil) ("5" (decompose-equality -6) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-10 1)) (("3" (grind) nil nil)) nil)) nil) ("6" (hide-all-but (-7 1)) (("6" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (skosimp -5 :preds? t) (("1" (inst 2 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil) ("5" (decompose-equality -5) (("1" (inst 2 "j!2") (("1" (inst -1 "j!2") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-9 -10 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-8 -9 1)) (("4" (grind) nil nil)) nil)) nil) ("6" (hide-all-but (-5 -6 1)) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (use "elemM3_fixes_pivots") (("5" (assert) (("5" (inst -1 "cr") (("5" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -1 "cr") (("1" (expand "*" -1 2) (("1" (decompose-equality -1) (("1" (inst -1 "pivot(M, cr)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "cr") (("2" (expand "nonzero_row?" (-4 1)) (("2" (skosimp -4 :preds? t) (("2" (inst 1 "j!1") (("1" (inst -2 "cr") (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (inst -1 "j!1") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep :preds? t) (("6" (lemma "elemM3_fixes_pivots") (("6" (inst -1 "M" "cr") (("6" (assert) (("6" (inst-cp -1 "cr") (("6" (inst -1 "i") (("6" (assert) (("6" (replace -1 :hide? t) (("6" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -8 "i") (("1" (assert) (("1" (inst -4 "i") (("1" (assert) (("1" (decompose-equality -4) (("1" (expand "nonzero_row?" (-4 2)) (("1" (skosimp -4 :preds? t) (("1" (inst 3 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -7 "cr") (("2" (inst -4 "cr") (("2" (expand "*" -4 2) (("2" (decompose-equality -4) (("1" (expand "nonzero_row?" (-7 1)) (("1" (skosimp -7 :preds? t) (("1" (inst 1 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "pivot_prop") (("2" (inst -1 "M" "cr") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((elemM3_prop formula-decl nil elementary_matrices nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nzreal nonempty-type-eq-decl nil reals nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pivot_prop formula-decl nil gauss_jordan nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (elemM3_fixes_pivots formula-decl nil gauss_jordan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "Vector" vectors "vectors/") (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (NOT const-decl "[bool -> bool]" booleans nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Index type-eq-decl nil vectors "vectors/") (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma "reals/") (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (rowV const-decl "Vector[M`cols]" matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak)) (elemM1_fixes_pivots_TCC1 0 (elemM1_fixes_pivots_TCC1-1 nil 3523244963 ("" (skeep :preds? t) (("" (assert) (("" (skeep 4 :preds? t) (("" (assert) (("" (skeep 4 :preds? t) (("" (assert) (("" (split 4) (("1" (hide-all-but (-11 1)) (("1" (grind) nil nil)) nil) ("2" (replace -11 :hide? t) (("2" (expand "nonzero_row?" 1) (("2" (lemma "zero_or_nonzero") (("2" (inst -1 "M" "cr") (("2" (assert) (("2" (flatten) (("2" (inst -10 "i") (("2" (flatten) (("2" (expand "nonzero_row?" -10) (("2" (skosimp) (("2" (inst 1 "pivot(M, i)") (("1" (use "elemM1_fixes_lhs") (("1" (assert) (("1" (inst -1 "i" "pivot(M, i)") (("1" (assert) (("1" (replace -1) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "i") (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (elemM1_fixes_pivots_TCC2 0 (elemM1_fixes_pivots_TCC2-1 nil 3523244963 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil)) nil)) (elemM1_fixes_pivots_TCC3 0 (elemM1_fixes_pivots_TCC3-1 nil 3524197458 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (replace -8) (("" (split 3) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (expand "nonzero_row?") (("2" (skosimp :preds? t) (("2" (use "elemM1_prop") (("2" (expand "rowV") (("2" (assert) (("2" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (* const-decl "Matrix" matrices nil) (sigma def-decl "real" sigma "reals/") (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (rowV const-decl "Vector[M`cols]" matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (a skolem-const-decl "real" gauss_jordan nil) (r skolem-const-decl "{r: below(M`rows) | r /= cr}" gauss_jordan nil) (cr skolem-const-decl "below(M`rows)" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (elemM1_prop formula-decl nil elementary_matrices nil) (nonzero_row? const-decl "bool" elementary_matrices nil)) nil)) (elemM1_fixes_pivots 0 (elemM1_fixes_pivots-1 nil 3523245180 ("" (skeep :preds? t) (("" (assert) (("" (skeep 2 :preds? t) (("" (typepred "pivot(M, i)") (("" (typepred "min({j_1: below(M`cols) | M`matrix(i, j_1) /= 0})") (("1" (assert) (("1" (replace -5 :dir rl) (("1" (typepred "pivot(elemM1(M`rows)(r, cr)(a) * M, i)") (("1" (typepred "min({j_1: below((elemM1(M`rows)(r, cr)(a) * M)`cols) |
              (elemM1(M`rows)(r, cr)(a) * M)`matrix(i, j_1) /= 0})") (("1" (replace -5 :dir rl) (("1" (inst -3 "pivot(M, i)") (("1" (inst -8 "pivot(elemM1(M`rows)(r, cr)(a) * M, i)") (("1" (split -3) (("1" (split -8) (("1" (assert) nil nil) ("2" (use "elemM1_prop") (("2" (expand "rowV") (("2" (decompose-equality -1) (("1" (inst -1 "pivot(elemM1(M`rows)(r, cr)(a) * M, i)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "elemM1_prop") (("2" (expand "rowV") (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, i)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=") (("2" (expand "nonzero_row?" -12) (("2" (skosimp :preds? t) (("2" (use "elemM1_prop") (("2" (expand "rowV") (("2" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (assert) (("1" (inst -3 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=") (("2" (expand "nonzero_row?" -8) (("2" (skosimp :preds? t) (("2" (inst -2 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Matrix type-eq-decl nil matrices nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (member const-decl "bool" sets nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (empty? const-decl "bool" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rowV const-decl "Vector[M`cols]" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma "reals/") (elemM1_prop formula-decl nil elementary_matrices nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (i skolem-const-decl "below(M`rows)" gauss_jordan nil) (cr skolem-const-decl "below(M`rows)" gauss_jordan nil) (r skolem-const-decl "{r: below(M`rows) | r /= cr}" gauss_jordan nil) (a skolem-const-decl "real" gauss_jordan nil)) shostak)) (elemM1_fixes_r_pivot_TCC1 0 (elemM1_fixes_r_pivot_TCC1-1 nil 3525292268 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM1? const-decl "bool" elementary_matrices nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil)) nil)) (elemM1_fixes_r_pivot_TCC2 0 (elemM1_fixes_r_pivot_TCC2-1 nil 3525292268 ("" (skeep :preds? t) (("" (replace -10 :hide? t) (("" (hide -6 -7 -8 -9) (("" (split 2) (("1" (grind) nil nil) ("2" (lemma "elemM1_prop") (("2" (inst -1 "M" "r" "cr" "a" "r") (("2" (expand "rowV") (("2" (expand "+" -1) (("2" (expand "*" -1 2) (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" 1) (("1" (inst -1 "pivot(M, r)") (("1" (inst 1 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) (("1" (inst -1 "pivot(M, r)") (("1" (replace -1) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "r") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (+ const-decl "real" vectors "vectors/") (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (Index type-eq-decl nil vectors "vectors/") (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (cr skolem-const-decl "{cr: below(M`rows) | nonzero_row?(M, cr)}" gauss_jordan nil) (r skolem-const-decl "{r: below(M`rows) |
         r /= cr & nonzero_row?(M, r) & pivot(M, r) < pivot(M, cr)}" gauss_jordan nil) (a skolem-const-decl "real" gauss_jordan nil) (pivot_prop formula-decl nil gauss_jordan nil) (* const-decl "Vector" vectors "vectors/") (rowV const-decl "Vector[M`cols]" matrices nil) (elemM1_prop formula-decl nil elementary_matrices nil)) nil)) (elemM1_fixes_r_pivot 0 (elemM1_fixes_r_pivot-1 nil 3525292275 ("" (skeep :preds? t) (("" (assert) (("" (lemma "pivot_prop") (("" (inst -1 "M" "cr") (("" (flatten) (("" (inst -1 "pivot(M, r)") (("" (lemma "elemM1_prop") (("" (inst -1 "M" "r" "cr" "a" "r") (("" (expand "rowV") (("" (expand "+" -1) (("" (expand "*" -1 2) (("" (decompose-equality -1) (("1" (inst -1 "pivot(M, r)") (("1" (replace -2) (("1" (assert) (("1" (typepred "pivot(elemM1(M`rows)(r, cr)(a) * M, r)") (("1" (typepred "min({j_1: below((elemM1(M`rows)(r, cr)(a) * M)`cols) |
              (elemM1(M`rows)(r, cr)(a) * M)`matrix(r, j_1) /= 0})") (("1" (replace -5 :dir rl :hide? t) (("1" (typepred "pivot(M, r)") (("1" (typepred "min({j_1: below(M`cols) | M`matrix(r, j_1) /= 0})") (("1" (replace -5 :dir rl :hide? t) (("1" (inst -7 "pivot(M, r)") (("1" (inst -3 "pivot(elemM1(M`rows)(r, cr)(a) * M, r)") (("1" (split -3) (("1" (split -7) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (assert) (("2" (flatten) (("2" (reveal -5) (("2" (inst -1 "pivot(elemM1(M`rows)(r, cr)(a) * M, r)") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (replace -1) (("2" (assert) (("2" (lemma "pivot_prop") (("2" (inst -1 "M" "cr") (("2" (flatten) (("2" (inst -1 "pivot(elemM1(M`rows)(r, cr)(a) * M, r)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=") (("2" (inst -1 "pivot(M, r)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=") (("2" (inst -1 "pivot(M, r)") (("2" (assert) (("2" (replace -1) (("2" (lemma "pivot_prop") (("2" (inst -1 "M" "r") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (+ const-decl "real" vectors "vectors/") (* const-decl "Matrix" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (Index type-eq-decl nil vectors "vectors/") (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (sigma def-decl "real" sigma "reals/") (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (a skolem-const-decl "real" gauss_jordan nil) (r skolem-const-decl "{r: below(M`rows) |
         r /= cr & nonzero_row?(M, r) & pivot(M, r) < pivot(M, cr)}" gauss_jordan nil) (cr skolem-const-decl "{cr: below(M`rows) | nonzero_row?(M, cr)}" gauss_jordan nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (* const-decl "Vector" vectors "vectors/") (rowV const-decl "Vector[M`cols]" matrices nil) (elemM1_prop formula-decl nil elementary_matrices nil) (pivot_prop formula-decl nil gauss_jordan nil)) shostak)) (elemM1_rref_pivot_TCC1 0 (elemM1_rref_pivot_TCC1-1 nil 3524201743 ("" (skeep :preds? t) (("" (inst -4 "cr") nil nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (upto nonempty-type-eq-decl nil naturalnumbers nil)) nil)) (elemM1_rref_pivot_TCC2 0 (elemM1_rref_pivot_TCC2-1 nil 3524201743 ("" (skeep :preds? t) (("" (skeep 3 :preds? t) (("" (skeep 3 :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (elemM1_rref_pivot_TCC3 0 (elemM1_rref_pivot_TCC3-1 nil 3524201743 ("" (skeep :preds? t) (("" (inst -5 "cr") nil nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil)) nil)) (elemM1_rref_pivot_TCC4 0 (elemM1_rref_pivot_TCC4-1 nil 3524201743 ("" (skeep :preds? t) (("" (inst -5 "cr") nil nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil)) nil)) (elemM1_rref_pivot_TCC5 0 (elemM1_rref_pivot_TCC5-1 nil 3524201743 ("" (skeep :preds? t) (("" (assert) nil nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (elemM1_rref_pivot_TCC6 0 (elemM1_rref_pivot_TCC6-1 nil 3525036228 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (zero_row? const-decl "bool" elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil)) nil)) (elemM1_rref_pivot_TCC7 0 (elemM1_rref_pivot_TCC7-1 nil 3525036228 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (elemM1? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (elemM1_rref_pivot_TCC8 0 (elemM1_rref_pivot_TCC8-1 nil 3525036228 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (elemM1? const-decl "bool" elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil) (* const-decl "Matrix" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (elemM1_rref_pivot_TCC9 0 (elemM1_rref_pivot_TCC9-1 nil 3525036228 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil) (* const-decl "Matrix" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (elemM1_rref_pivot_TCC10 0 (elemM1_rref_pivot_TCC10-1 nil 3525036228 ("" (skeep :preds? t) (("" (skeep 3 :preds? t) (("" (skeep 3 :preds? t) (("" (skeep 3 :preds? t) (("" (assert) (("" (inst -16 "cr") nil nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (elemM1_rref_pivot_TCC11 0 (elemM1_rref_pivot_TCC11-1 nil 3525036228 ("" (skeep :preds? t) (("" (skeep 3 :preds? t) (("" (skeep 3 :preds? t) (("" (skeep 3 :preds? t) (("" (assert) (("" (inst -16 "cr") nil nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil)) nil)) (elemM1_rref_pivot_TCC12 0 (elemM1_rref_pivot_TCC12-1 nil 3525630396 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM1? const-decl "bool" elementary_matrices nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil) (* const-decl "Matrix" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (elemM1_rref_pivot 0 (elemM1_rref_pivot-3 "" 3549333484 ("" (skeep :preds? t) (("" (assert) (("" (split 3) (("1" (hide-all-but (1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (lemma "elemM1_prop") (("3" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "_") (("3" (expand "rowV") (("3" (expand "+" -1) (("3" (expand "*" -1 2) (("3" (expand "rref?") (("3" (flatten) (("3" (split 1) (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -9 "i" "j") (("1" (assert) (("1" (inst-cp -5 "i") (("1" (inst -5 "j") (("1" (lift-if) (("1" (split -6) (("1" (flatten) (("1" (decompose-equality -2) (("1" (split -7) (("1" (flatten) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (replace -4) (("1" (lemma "zero_isnt_nonzero") (("1" (inst -1 "elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M" "r") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (replace -3) (("1" (expand "nonzero_row?" -6) (("1" (skosimp) (("1" (inst -2 "j!1") (("1" (replace -2 :hide? t) (("1" (expand "zero_row?" -5) (("1" (assert) (("1" (split 4) (("1" (assert) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (skosimp) (("2" (inst -1 "j!2") (("1" (inst -5 "j!2") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (split -6) (("1" (flatten) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (split 3) (("1" (expand "nonzero_row?" -6) (("1" (skosimp) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (inst -3 "j!1") (("1" (assert) nil nil)) nil) ("2" (typepred "j!1") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (expand "zero_row?" -7) (("2" (inst -1 "pivot(M, r)") (("1" (inst -7 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (inst -10 "r") (("1" (assert) (("1" (case-replace "M`matrix(cr, pivot(M, r)) = 0") (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "r") (("1" (flatten) nil nil)) nil)) nil)) nil) ("2" (lemma "pivot_prop") (("2" (inst -1 "M" "cr") (("2" (flatten) (("2" (inst -1 "pivot(M, r)") (("2" (expand "rref_row_inv") (("2" (inst -11 "r") (("2" (assert) (("2" (split -11) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") nil nil)) nil)) nil) ("3" (assert) (("3" (inst -11 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (inst -12 "r") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (decompose-equality -1) (("1" (split 4) (("1" (expand "nonzero_row?" -5) (("1" (skosimp :preds? t) (("1" (inst -3 "j!1") (("1" (replace -3 :hide? t) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (skosimp :preds? t) (("2" (expand "zero_row?" -7) (("2" (inst -7 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst-cp -1 "i") (("2" (inst -1 "j") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -9 "i") (("1" (assert) (("1" (split -9) (("1" (inst -1 "j") nil nil) ("2" (inst -4 "i") (("2" (lift-if) (("2" (split -4) (("1" (flatten) (("1" (replace -1) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" -4) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (replace -2 :hide? t) (("1" (expand "nonzero_row?" 2) (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (use "elemM1_fixes_r_pivot") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -11 "r") (("1" (split -11) (("1" (inst -1 "j") nil nil) ("2" (expand "nonzero_row?" 1) (("2" (inst 1 "pivot(M, cr)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "pivot_prop") (("2" (inst -1 "M" "r") (("2" (flatten) (("2" (inst -1 "pivot(M, cr)") (("2" (assert) (("2" (inst -12 "r") (("2" (expand "rref_row_inv") (("2" (split -12) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -18 "j!1") (("2" (inst -14 "j!1") nil nil)) nil)) nil)) nil) ("3" (inst -12 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -11 "i") nil nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -14 "i") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (lemma "elemM1_fixes_r_pivot") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -10 "i") (("1" (assert) (("1" (inst -10 "r") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst-cp -12 "r") (("2" (assert) (("2" (inst -11 "r") (("2" (expand "rref_row_inv") (("2" (split -11) (("1" (flatten) (("1" (inst -3 "r" "pivot(M, cr)") (("1" (assert) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (inst -12 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (inst -7 "i") (("2" (expand "rref_row_inv") (("2" (flatten) (("2" (split 1) (("1" (case-replace "i = r") (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -5 "r") (("1" (decompose-equality -5) (("1" (inst -1 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (split -9) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -11 "j!1") nil nil)) nil)) nil) ("3" (inst -9 "r") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-1 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-4 1)) (("7" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -11 "r") (("1" (assert) (("1" (split -10) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) (("1" (inst -3 "r" "pivot(M, cr)") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -12 "j!1") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -11 "i") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (inst -4 "i") (("2" (assert) (("2" (decompose-equality -4) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (split -8) (("1" (flatten) nil nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -10 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-4 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (case-replace "i = r") (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -6 "j") (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -1 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (split -10) (("1" (flatten) (("1" (inst -2 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -12 "j!1") nil nil)) nil)) nil) ("3" (inst -10 "r") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-8 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-5 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-5 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-8 1)) (("7" (grind) nil nil)) nil) ("8" (hide-all-but (-1 1)) (("8" (grind) nil nil)) nil) ("9" (hide-all-but (-1 1)) (("9" (grind) nil nil)) nil) ("10" (hide-all-but (-4 1)) (("10" (grind) nil nil)) nil) ("11" (hide-all-but (-1 1)) (("11" (grind) nil nil)) nil) ("12" (hide-all-but (-1 1)) (("12" (grind) nil nil)) nil) ("13" (hide-all-but (-4 1)) (("13" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -12 "r") (("1" (assert) (("1" (split -11) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) (("1" (inst -3 "r" "pivot(M, cr)") nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -12 "i") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (inst -5 "j") (("1" (assert) (("1" (lift-if) (("1" (split -5) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (hide -5) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (split -9) (("1" (flatten) (("1" (inst-cp -2 "r") (("1" (assert) (("1" (replace -3) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -11 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-4 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (hide -3) (("1" (split -8) (("1" (flatten) (("1" (inst -2 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -10 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-8 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-5 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-8 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-1 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-4 1)) (("7" (grind) nil nil)) nil) ("8" (hide-all-but (-1 1)) (("8" (grind) nil nil)) nil) ("9" (hide-all-but (-4 1)) (("9" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (hide -5) (("3" (inst -6 "j") (("1" (assert) (("1" (lift-if) (("1" (split -6) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -1 "k") (("1" (replace -1 :hide? t) (("1" (split -11) (("1" (flatten) (("1" (inst-cp -3 "cr" "k") (("1" (replace -4) (("1" (assert) (("1" (inst -3 "r" "k") (("1" (assert) (("1" (case-replace "i = r") (("1" (assert) (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) nil nil) ("2" (inst-cp -15 "r") (("2" (assert) (("2" (reveal -2) (("2" (inst -1 "r" "pivot(M, cr)") (("2" (assert) (("2" (replace -1) (("2" (inst -3 "cr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -14 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) *
                   M, i) = pivot(M, i)") (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -13 "i") (("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (lemma "elemM1_fixes_r_pivot") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) nil nil) ("2" (reveal -8) (("2" (inst -1 "r") (("2" (expand "rref_row_inv") (("2" (split -1) (("1" (flatten) (("1" (inst -2 "r" "pivot(M, cr)") (("1" (assert) (("1" (inst -1 "cr") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -16 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") nil nil)) nil)) nil) ("3" (inst -11 "i") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "k") (("1" (replace -1 :hide? t) (("1" (split -10) (("1" (flatten) (("1" (inst -3 "j" "k") (("1" (case-replace "i = r") (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) nil nil) ("2" (inst-cp -13 "r") (("1" (assert) (("1" (reveal -2) (("1" (assert) (("1" (inst-cp -1 "cr" "pivot(M, cr)") (("1" (assert) nil nil) ("2" (assert) (("2" (replace -1) (("2" (inst -3 "cr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst -12 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -12 "j!1") nil nil)) nil)) nil) ("3" (inst -10 "i") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "elemM1_prop") (("4" (skeep :preds? t) (("4" (inst -2 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "i") (("4" (expand "rowV") (("4" (assert) (("4" (lift-if) (("4" (split -2) (("1" (flatten) (("1" (expand "+" -2) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (expand "nonzero_row?" 1) (("1" (inst -1 "pivot(M, r)") (("1" (inst 1 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) (("1" (inst -1 "pivot(M, r)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "r") (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "rref?") (("2" (flatten) (("2" (expand "rref_row_inv") (("2" (inst -8 "r") (("2" (split -8) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -10 "j!1") nil nil)) nil)) nil) ("3" (inst -8 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (inst -7 "r") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -7 "i") (("1" (expand "nonzero_row?" (-7 2)) (("1" (skosimp -7 :preds? t) (("1" (inst -2 "j!1") (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (lemma "elemM1_prop") (("5" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "cr") (("5" (expand "rowV") (("5" (decompose-equality -1) (("1" (lemma "elemM1_fixes_pivots") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (inst -1 "cr") (("1" (assert) (("1" (inst-cp -7 "cr") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -1 "pivot(M, cr)") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep :preds? t) (("6" (lemma "elemM1_fixes_pivots") (("6" (lemma "elemM1_prop") (("6" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "_") (("6" (expand "rowV" -1) (("6" (expand "+" -1) (("6" (expand "*" -1 2) (("6" (case-replace "i = r") (("1" (inst -3 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (inst -3 "cr") (("1" (assert) (("1" (inst-cp -11 "cr") (("1" (assert) (("1" (replace -3 :hide? t) (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -13 "r") (("1" (assert) (("1" (expand "nonzero_row?" 2) (("1" (inst 2 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "pivot_prop") (("2" (inst -1 "M" "r") (("2" (flatten) (("2" (inst -1 "pivot(M, cr)") (("2" (assert) (("2" (inst -2 "r") (("2" (decompose-equality -2) (("1" (inst -1 "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, r)") (("1" (assert) (("1" (typepred "pivot(M, r)") (("1" (typepred "min({j_1: below(M`cols) | M`matrix(r, j_1) /= 0})") (("1" (replace -5 :dir rl :hide? t) (("1" (inst -3 "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, r)") (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M" "r") (("1" (flatten) (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (assert) (("1" (inst -1 "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, r)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=") (("2" (inst -1 "pivot(M, cr)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst-cp -2 "cr") (("2" (inst -2 "i") (("1" (assert) (("1" (inst-cp -11 "cr") (("1" (assert) (("1" (replace -3 :hide? t) (("1" (split -2) (("1" (replace -1 :hide? t) (("1" (inst -12 "i") (("1" (assert) (("1" (inst -1 "i") (("1" (assert) (("1" (decompose-equality -1) (("1" (expand "nonzero_row?" (-4 3)) (("1" (skosimp -4 :preds? t) (("1" (inst 4 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -1 "i") (("2" (assert) (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" (-4 1)) (("1" (skosimp -4 :preds? t) (("1" (inst 1 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep :preds? t) (("7" (lemma "elemM1_fixes_pivots") (("7" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("7" (assert) (("7" (inst -1 "cr") (("7" (assert) (("7" (inst-cp -7 "cr") (("7" (assert) (("7" (replace -1 :hide? t) (("7" (lemma "elemM1_prop") (("7" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "_") (("7" (expand "rowV") (("7" (expand "+" -1) (("7" (expand "*" -1 2) (("7" (inst -1 "i") (("7" (lift-if) (("7" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -1 "pivot(M, cr)") (("1" (replace -10) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, cr)") (("1" (replace -1 :hide? t) (("1" (inst -11 "i") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i skolem-const-decl "upto(r)" gauss_jordan nil) (j!1 skolem-const-decl "below((elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M)`cols)" gauss_jordan nil) (j!1 skolem-const-decl "below((elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M)`cols)" gauss_jordan nil) (i skolem-const-decl "subrange(cr,
         (elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M)`rows - 1)" gauss_jordan nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (elemM1_prop formula-decl nil elementary_matrices nil) (rowV const-decl "Vector[M`cols]" matrices nil) (* const-decl "Vector" vectors "vectors/") (j skolem-const-decl "below((elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M)`rows)" gauss_jordan nil) (k skolem-const-decl "below(pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, i))" gauss_jordan nil) (i skolem-const-decl "below(cr)" gauss_jordan nil) (j skolem-const-decl "subrange(i,
         (elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M)`rows - 1)" gauss_jordan nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (j!1 skolem-const-decl "below((elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M)`cols)" gauss_jordan nil) (pivot_prop formula-decl nil gauss_jordan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (zero_isnt_nonzero formula-decl nil elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (r skolem-const-decl "{r: below(M`rows) |
         FORALL (i: below(r)): i /= cr => M`matrix(i, pivot(M, cr)) = 0}" gauss_jordan nil) (cr skolem-const-decl "{cr: below(M`rows) |
         rref?(M, cr) &
          (FORALL (i: upto(cr)): nonzero_row?(M, i)) &
           M`matrix(cr, pivot(M, cr)) = 1 &
            (FORALL (i: subrange(cr, M`rows - 1)):
               nonzero_row?(M, i) => pivot(M, cr) <= pivot(M, i))}" gauss_jordan nil) (j!2 skolem-const-decl "below(M`cols)" gauss_jordan nil) (M skolem-const-decl "{M: Matrix | M`rows = OM`rows AND M`cols = OM`cols}" gauss_jordan nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Index type-eq-decl nil vectors "vectors/") (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (elemM1_fixes_r_pivot formula-decl nil gauss_jordan nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM1_fixes_pivots formula-decl nil gauss_jordan nil) (+ const-decl "real" vectors "vectors/") (- const-decl "[numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (* const-decl "Matrix" matrices nil) (sigma def-decl "real" sigma "reals/") (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil)) shostak) (elemM1_rref_pivot-2 "" 3547754959 ("" (skeep :preds? t) (("" (assert) (("" (split 3) (("1" (hide-all-but (1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (lemma "elemM1_prop") (("3" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "_") (("3" (expand "rowV") (("3" (expand "+" -1) (("3" (expand "*" -1 2) (("3" (expand "rref?") (("3" (flatten) (("3" (split 1) (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -9 "i" "j") (("1" (assert) (("1" (inst-cp -5 "i") (("1" (inst -5 "j") (("1" (lift-if) (("1" (split -6) (("1" (flatten) (("1" (decompose-equality -2) (("1" (split -7) (("1" (flatten) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (replace -4) (("1" (lemma "zero_isnt_nonzero") (("1" (inst -1 "elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M" "r") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (replace -3) (("1" (expand "nonzero_row?" -6) (("1" (skosimp) (("1" (inst -2 "j!1") (("1" (replace -2 :hide? t) (("1" (expand "zero_row?" -5) (("1" (assert) (("1" (split 4) (("1" (assert) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (skosimp) (("2" (inst -1 "j!2") (("1" (inst -5 "j!2") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (split -6) (("1" (flatten) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (split 3) (("1" (expand "nonzero_row?" -6) (("1" (skosimp) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (inst -3 "j!1") (("1" (assert) nil nil)) nil) ("2" (typepred "j!1") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (expand "zero_row?" -7) (("2" (inst -1 "pivot(M, r)") (("1" (inst -7 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (inst -10 "r") (("1" (assert) (("1" (case-replace "M`matrix(cr, pivot(M, r)) = 0") (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "r") (("1" (flatten) nil nil)) nil)) nil)) nil) ("2" (lemma "pivot_prop") (("2" (inst -1 "M" "cr") (("2" (flatten) (("2" (inst -1 "pivot(M, r)") (("2" (expand "rref_row_inv") (("2" (inst -11 "r") (("2" (assert) (("2" (split -11) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") nil nil)) nil)) nil) ("3" (assert) (("3" (inst -11 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (inst -12 "r") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (decompose-equality -1) (("1" (split 4) (("1" (expand "nonzero_row?" -5) (("1" (skosimp :preds? t) (("1" (inst -3 "j!1") (("1" (replace -3 :hide? t) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (skosimp :preds? t) (("2" (expand "zero_row?" -7) (("2" (inst -7 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst-cp -1 "i") (("2" (inst -1 "j") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -9 "i") (("1" (assert) (("1" (split -9) (("1" (inst -1 "j") nil nil) ("2" (inst -4 "i") (("2" (lift-if) (("2" (split -4) (("1" (flatten) (("1" (replace -1) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" -4) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (replace -2 :hide? t) (("1" (expand "nonzero_row?" 2) (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (use "elemM1_fixes_r_pivot") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -11 "r") (("1" (split -11) (("1" (inst -1 "j") nil nil) ("2" (expand "nonzero_row?" 1) (("2" (inst 1 "pivot(M, cr)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "pivot_prop") (("2" (inst -1 "M" "r") (("2" (flatten) (("2" (inst -1 "pivot(M, cr)") (("2" (assert) (("2" (inst -12 "r") (("2" (expand "rref_row_inv") (("2" (split -12) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -18 "j!1") (("2" (inst -14 "j!1") nil nil)) nil)) nil)) nil) ("3" (inst -12 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -11 "i") nil nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -14 "i") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (lemma "elemM1_fixes_r_pivot") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -10 "i") (("1" (assert) (("1" (inst -10 "r") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst-cp -12 "r") (("2" (assert) (("2" (inst -11 "r") (("2" (expand "rref_row_inv") (("2" (split -11) (("1" (flatten) (("1" (inst -3 "r" "pivot(M, cr)") (("1" (assert) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (inst -12 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (inst -7 "i") (("2" (expand "rref_row_inv") (("2" (flatten) (("2" (split 1) (("1" (case-replace "i = r") (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -5 "r") (("1" (decompose-equality -5) (("1" (inst -1 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (split -9) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -11 "j!1") nil nil)) nil)) nil) ("3" (inst -9 "r") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-1 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-4 1)) (("7" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -11 "r") (("1" (assert) (("1" (split -10) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) (("1" (inst -3 "r" "pivot(M, cr)") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -12 "j!1") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -11 "i") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (inst -4 "i") (("2" (assert) (("2" (decompose-equality -4) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (split -8) (("1" (flatten) nil nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -10 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-4 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (case-replace "i = r") (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -6 "j") (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -1 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (split -10) (("1" (flatten) (("1" (inst -2 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -12 "j!1") nil nil)) nil)) nil) ("3" (inst -10 "r") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-8 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-5 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-5 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-8 1)) (("7" (grind) nil nil)) nil) ("8" (hide-all-but (-1 1)) (("8" (grind) nil nil)) nil) ("9" (hide-all-but (-1 1)) (("9" (grind) nil nil)) nil) ("10" (hide-all-but (-4 1)) (("10" (grind) nil nil)) nil) ("11" (hide-all-but (-1 1)) (("11" (grind) nil nil)) nil) ("12" (hide-all-but (-1 1)) (("12" (grind) nil nil)) nil) ("13" (hide-all-but (-4 1)) (("13" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -12 "r") (("1" (assert) (("1" (split -11) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) (("1" (inst -3 "r" "pivot(M, cr)") nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -12 "i") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (inst -5 "j") (("1" (assert) (("1" (lift-if) (("1" (split -5) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (hide -5) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (split -9) (("1" (flatten) (("1" (inst-cp -2 "r") (("1" (assert) (("1" (replace -3) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -11 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-4 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (hide -3) (("1" (split -8) (("1" (flatten) (("1" (inst -2 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -10 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-8 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-5 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-8 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-1 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-4 1)) (("7" (grind) nil nil)) nil) ("8" (hide-all-but (-1 1)) (("8" (grind) nil nil)) nil) ("9" (hide-all-but (-4 1)) (("9" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (hide -5) (("3" (inst -6 "j") (("1" (assert) (("1" (lift-if) (("1" (split -6) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -1 "k") (("1" (replace -1 :hide? t) (("1" (split -11) (("1" (flatten) (("1" (inst-cp -3 "cr" "k") (("1" (replace -4) (("1" (assert) (("1" (inst -3 "r" "k") (("1" (assert) (("1" (case-replace "i = r") (("1" (assert) (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) nil nil) ("2" (inst-cp -15 "r") (("2" (assert) (("2" (reveal -2) (("2" (inst -1 "r" "pivot(M, cr)") (("2" (assert) (("2" (replace -1) (("2" (inst -3 "cr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -14 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) *
                   M, i) = pivot(M, i)") (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -13 "i") (("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (lemma "elemM1_fixes_r_pivot") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) nil nil) ("2" (reveal -8) (("2" (inst -1 "r") (("2" (expand "rref_row_inv") (("2" (split -1) (("1" (flatten) (("1" (inst -2 "r" "pivot(M, cr)") (("1" (assert) (("1" (inst -1 "cr") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -16 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") nil nil)) nil)) nil) ("3" (inst -11 "i") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "k") (("1" (replace -1 :hide? t) (("1" (split -10) (("1" (flatten) (("1" (inst -3 "j" "k") (("1" (case-replace "i = r") (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) nil nil) ("2" (inst-cp -13 "r") (("1" (assert) (("1" (reveal -2) (("1" (assert) (("1" (inst-cp -1 "cr" "pivot(M, cr)") (("1" (assert) nil nil) ("2" (assert) (("2" (replace -1) (("2" (inst -3 "cr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst -12 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -12 "j!1") nil nil)) nil)) nil) ("3" (inst -10 "i") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-6 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-9 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-1 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-4 1)) (("7" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "elemM1_prop") (("4" (skeep :preds? t) (("4" (inst -2 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "i") (("4" (expand "rowV") (("4" (assert) (("4" (lift-if) (("4" (split -2) (("1" (flatten) (("1" (expand "+" -2) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (expand "nonzero_row?" 1) (("1" (inst -1 "pivot(M, r)") (("1" (inst 1 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) (("1" (inst -1 "pivot(M, r)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "r") (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "rref?") (("2" (flatten) (("2" (expand "rref_row_inv") (("2" (inst -8 "r") (("2" (split -8) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -10 "j!1") nil nil)) nil)) nil) ("3" (inst -8 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (inst -7 "r") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -7 "i") (("1" (expand "nonzero_row?" (-7 2)) (("1" (skosimp -7 :preds? t) (("1" (inst -2 "j!1") (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (lemma "elemM1_prop") (("5" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "cr") (("5" (expand "rowV") (("5" (decompose-equality -1) (("1" (lemma "elemM1_fixes_pivots") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (inst -1 "cr") (("1" (assert) (("1" (inst-cp -7 "cr") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -1 "pivot(M, cr)") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep :preds? t) (("6" (lemma "elemM1_fixes_pivots") (("6" (lemma "elemM1_prop") (("6" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "_") (("6" (expand "rowV" -1) (("6" (expand "+" -1) (("6" (expand "*" -1 2) (("6" (case-replace "i = r") (("1" (inst -3 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (inst -3 "cr") (("1" (assert) (("1" (inst-cp -11 "cr") (("1" (assert) (("1" (replace -3 :hide? t) (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -13 "r") (("1" (assert) (("1" (expand "nonzero_row?" 2) (("1" (inst 2 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "pivot_prop") (("2" (inst -1 "M" "r") (("2" (flatten) (("2" (inst -1 "pivot(M, cr)") (("2" (assert) (("2" (inst -2 "r") (("2" (decompose-equality -2) (("1" (inst -1 "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, r)") (("1" (assert) (("1" (typepred "pivot(M, r)") (("1" (typepred "min({j_1: below(M`cols) | M`matrix(r, j_1) /= 0})") (("1" (replace -5 :dir rl :hide? t) (("1" (inst -3 "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, r)") (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M" "r") (("1" (flatten) (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (assert) (("1" (inst -1 "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, r)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=") (("2" (inst -1 "pivot(M, cr)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst-cp -2 "cr") (("2" (inst -2 "i") (("1" (assert) (("1" (inst-cp -11 "cr") (("1" (assert) (("1" (replace -3 :hide? t) (("1" (split -2) (("1" (replace -1 :hide? t) (("1" (inst -12 "i") (("1" (assert) (("1" (inst -1 "i") (("1" (assert) (("1" (decompose-equality -1) (("1" (expand "nonzero_row?" (-4 3)) (("1" (skosimp -4 :preds? t) (("1" (inst 4 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -1 "i") (("2" (assert) (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" (-4 1)) (("1" (skosimp -4 :preds? t) (("1" (inst 1 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep :preds? t) (("7" (lemma "elemM1_fixes_pivots") (("7" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("7" (assert) (("7" (inst -1 "cr") (("7" (assert) (("7" (inst-cp -7 "cr") (("7" (assert) (("7" (replace -1 :hide? t) (("7" (lemma "elemM1_prop") (("7" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "_") (("7" (expand "rowV") (("7" (expand "+" -1) (("7" (expand "*" -1 2) (("7" (inst -1 "i") (("7" (lift-if) (("7" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -1 "pivot(M, cr)") (("1" (replace -10) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, cr)") (("1" (replace -1 :hide? t) (("1" (inst -11 "i") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") nil (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) nil (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (+ const-decl "real" vectors "vectors/") (elemM1_fixes_pivots formula-decl nil gauss_jordan nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM1_fixes_r_pivot formula-decl nil gauss_jordan nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (Index type-eq-decl nil vectors "vectors/") (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) nil nil nil nil nil nil (zero_isnt_nonzero formula-decl nil elementary_matrices nil) nil (rref_row_inv const-decl "bool" gauss_jordan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pivot_prop formula-decl nil gauss_jordan nil) nil (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) nil nil nil nil (* const-decl "Vector" vectors "vectors/") (rowV const-decl "Vector[M`cols]" matrices nil) (elemM1_prop formula-decl nil elementary_matrices nil) nil (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) nil nil nil nil (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil)) shostak) (elemM1_rref_pivot-1 nil 3524202489 ("" (skeep :preds? t) (("" (assert) (("" (split 3) (("1" (hide-all-but (1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (lemma "elemM1_prop") (("3" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "_") (("3" (expand "rowV") (("3" (expand "+" -1) (("3" (expand "*" -1 2) (("3" (expand "rref?") (("3" (flatten) (("3" (split 1) (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -9 "i" "j") (("1" (assert) (("1" (inst-cp -5 "i") (("1" (inst -5 "j") (("1" (lift-if) (("1" (split -6) (("1" (flatten) (("1" (decompose-equality -2) (("1" (split -7) (("1" (flatten) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (replace -4) (("1" (lemma "zero_isnt_nonzero") (("1" (inst -1 "elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M" "r") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (replace -3) (("1" (expand "nonzero_row?" -6) (("1" (skosimp) (("1" (inst -2 "j!1") (("1" (replace -2 :hide? t) (("1" (expand "zero_row?" -5) (("1" (assert) (("1" (split 4) (("1" (assert) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (skosimp) (("2" (inst -1 "j!2") (("1" (inst -5 "j!2") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (split -6) (("1" (flatten) (("1" (decompose-equality -2) (("1" (replace -2) (("1" (split 3) (("1" (expand "nonzero_row?" -6) (("1" (skosimp) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (inst -3 "j!1") (("1" (assert) nil nil)) nil) ("2" (typepred "j!1") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (expand "zero_row?" -7) (("2" (inst -1 "pivot(M, r)") (("1" (inst -7 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (inst -10 "r") (("1" (assert) (("1" (case-replace "M`matrix(cr, pivot(M, r)) = 0") (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "r") (("1" (flatten) nil nil)) nil)) nil)) nil) ("2" (lemma "pivot_prop") (("2" (inst -1 "M" "cr") (("2" (flatten) (("2" (inst -1 "pivot(M, r)") (("2" (expand "rref_row_inv") (("2" (inst -11 "r") (("2" (assert) (("2" (split -11) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") nil nil)) nil)) nil) ("3" (assert) (("3" (inst -11 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (inst -12 "r") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (decompose-equality -1) (("1" (split 4) (("1" (expand "nonzero_row?" -5) (("1" (skosimp :preds? t) (("1" (inst -3 "j!1") (("1" (replace -3 :hide? t) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (skosimp :preds? t) (("2" (expand "zero_row?" -7) (("2" (inst -7 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst-cp -1 "i") (("2" (inst -1 "j") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (inst -9 "i") (("1" (assert) (("1" (split -9) (("1" (inst -1 "j") nil nil) ("2" (inst -4 "i") (("2" (lift-if) (("2" (split -4) (("1" (flatten) (("1" (replace -1) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" -4) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (replace -2 :hide? t) (("1" (expand "nonzero_row?" 2) (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (use "elemM1_fixes_r_pivot") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -11 "r") (("1" (split -11) (("1" (inst -1 "j") nil nil) ("2" (expand "nonzero_row?" 1) (("2" (inst 1 "pivot(M, cr)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "pivot_prop") (("2" (inst -1 "M" "r") (("2" (flatten) (("2" (inst -1 "pivot(M, cr)") (("2" (assert) (("2" (inst -12 "r") (("2" (expand "rref_row_inv") (("2" (split -12) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -18 "j!1") (("2" (inst -14 "j!1") nil nil)) nil)) nil)) nil) ("3" (inst -12 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -11 "i") nil nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -14 "i") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (lemma "elemM1_fixes_r_pivot") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -10 "i") (("1" (assert) (("1" (inst -10 "r") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst-cp -12 "r") (("2" (assert) (("2" (inst -11 "r") (("2" (expand "rref_row_inv") (("2" (split -11) (("1" (flatten) (("1" (inst -3 "r" "pivot(M, cr)") (("1" (assert) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (inst -12 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (inst -7 "i") (("2" (expand "rref_row_inv") (("2" (flatten) (("2" (split 1) (("1" (case-replace "i = r") (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -5 "r") (("1" (decompose-equality -5) (("1" (inst -1 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (split -9) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -11 "j!1") nil nil)) nil)) nil) ("3" (inst -9 "r") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-1 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-4 1)) (("7" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -11 "r") (("1" (assert) (("1" (split -10) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) (("1" (inst -3 "r" "pivot(M, cr)") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -12 "j!1") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -11 "i") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (inst -4 "i") (("2" (assert) (("2" (decompose-equality -4) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (split -8) (("1" (flatten) nil nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -10 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-4 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (case-replace "i = r") (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -6 "j") (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -1 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (split -10) (("1" (flatten) (("1" (inst -2 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -12 "j!1") nil nil)) nil)) nil) ("3" (inst -10 "r") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-8 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-5 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-5 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-8 1)) (("7" (grind) nil nil)) nil) ("8" (hide-all-but (-1 1)) (("8" (grind) nil nil)) nil) ("9" (hide-all-but (-1 1)) (("9" (grind) nil nil)) nil) ("10" (hide-all-but (-4 1)) (("10" (grind) nil nil)) nil) ("11" (hide-all-but (-1 1)) (("11" (grind) nil nil)) nil) ("12" (hide-all-but (-1 1)) (("12" (grind) nil nil)) nil) ("13" (hide-all-but (-4 1)) (("13" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -12 "r") (("1" (assert) (("1" (split -11) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) (("1" (inst -3 "r" "pivot(M, cr)") nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -12 "i") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (inst -5 "j") (("1" (assert) (("1" (lift-if) (("1" (split -5) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (hide -5) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (split -9) (("1" (flatten) (("1" (inst-cp -2 "r") (("1" (assert) (("1" (replace -3) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -11 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-4 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, i)") (("1" (replace -1 :hide? t) (("1" (hide -3) (("1" (split -8) (("1" (flatten) (("1" (inst -2 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -10 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-8 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-5 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-8 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-1 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-4 1)) (("7" (grind) nil nil)) nil) ("8" (hide-all-but (-1 1)) (("8" (grind) nil nil)) nil) ("9" (hide-all-but (-4 1)) (("9" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (hide -5) (("3" (inst -6 "j") (("1" (assert) (("1" (lift-if) (("1" (split -6) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -1 "k") (("1" (replace -1 :hide? t) (("1" (split -11) (("1" (flatten) (("1" (inst-cp -3 "cr" "k") (("1" (replace -4) (("1" (assert) (("1" (inst -3 "r" "k") (("1" (assert) (("1" (case-replace "i = r") (("1" (assert) (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) nil nil) ("2" (inst-cp -15 "r") (("2" (assert) (("2" (reveal -2) (("2" (inst -1 "r" "pivot(M, cr)") (("2" (assert) (("2" (replace -1) (("2" (inst -3 "cr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -14 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) *
                   M, i) = pivot(M, i)") (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst-cp -13 "i") (("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (lemma "elemM1_fixes_r_pivot") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) nil nil) ("2" (reveal -8) (("2" (inst -1 "r") (("2" (expand "rref_row_inv") (("2" (split -1) (("1" (flatten) (("1" (inst -2 "r" "pivot(M, cr)") (("1" (assert) (("1" (inst -1 "cr") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -16 "j!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") nil nil)) nil)) nil) ("3" (inst -11 "i") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "k") (("1" (replace -1 :hide? t) (("1" (split -10) (("1" (flatten) (("1" (inst -3 "j" "k") (("1" (case-replace "i = r") (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) nil nil) ("2" (inst-cp -13 "r") (("1" (assert) (("1" (reveal -2) (("1" (assert) (("1" (inst-cp -1 "cr" "pivot(M, cr)") (("1" (assert) nil nil) ("2" (assert) (("2" (replace -1) (("2" (inst -3 "cr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (inst -12 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -12 "j!1") nil nil)) nil)) nil) ("3" (inst -10 "i") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "elemM1_prop") (("4" (skeep :preds? t) (("4" (inst -2 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "i") (("4" (expand "rowV") (("4" (assert) (("4" (lift-if) (("4" (split -2) (("1" (flatten) (("1" (expand "+" -2) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (expand "nonzero_row?" 1) (("1" (inst -1 "pivot(M, r)") (("1" (inst 1 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) (("1" (inst -1 "pivot(M, r)") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "r") (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "rref?") (("2" (flatten) (("2" (expand "rref_row_inv") (("2" (inst -8 "r") (("2" (split -8) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -10 "j!1") nil nil)) nil)) nil) ("3" (inst -8 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (inst -7 "r") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -7 "i") (("1" (expand "nonzero_row?" (-7 2)) (("1" (skosimp -7 :preds? t) (("1" (inst -2 "j!1") (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (lemma "elemM1_prop") (("5" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "cr") (("5" (expand "rowV") (("5" (decompose-equality -1) (("1" (lemma "elemM1_fixes_pivots") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (inst -1 "cr") (("1" (assert) (("1" (inst-cp -7 "cr") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -1 "pivot(M, cr)") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep :preds? t) (("6" (lemma "elemM1_fixes_pivots") (("6" (lemma "elemM1_prop") (("6" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "_") (("6" (expand "rowV" -1) (("6" (expand "+" -1) (("6" (expand "*" -1 2) (("6" (case-replace "i = r") (("1" (inst -3 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (inst -3 "cr") (("1" (assert) (("1" (inst-cp -11 "cr") (("1" (assert) (("1" (replace -3 :hide? t) (("1" (lemma "elemM1_fixes_r_pivot") (("1" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -13 "r") (("1" (assert) (("1" (expand "nonzero_row?" 2) (("1" (inst 2 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "pivot_prop") (("2" (inst -1 "M" "r") (("2" (flatten) (("2" (inst -1 "pivot(M, cr)") (("2" (assert) (("2" (inst -2 "r") (("2" (decompose-equality -2) (("1" (inst -1 "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, r)") (("1" (assert) (("1" (typepred "pivot(M, r)") (("1" (typepred "min({j_1: below(M`cols) | M`matrix(r, j_1) /= 0})") (("1" (replace -5 :dir rl :hide? t) (("1" (inst -3 "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, r)") (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M" "r") (("1" (flatten) (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (assert) (("1" (inst -1 "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, r)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=") (("2" (inst -1 "pivot(M, cr)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst-cp -2 "cr") (("2" (inst -2 "i") (("1" (assert) (("1" (inst-cp -11 "cr") (("1" (assert) (("1" (replace -3 :hide? t) (("1" (split -2) (("1" (replace -1 :hide? t) (("1" (inst -12 "i") (("1" (assert) (("1" (inst -1 "i") (("1" (assert) (("1" (decompose-equality -1) (("1" (expand "nonzero_row?" (-4 3)) (("1" (skosimp -4 :preds? t) (("1" (inst 4 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -1 "i") (("2" (assert) (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" (-4 1)) (("1" (skosimp -4 :preds? t) (("1" (inst 1 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep :preds? t) (("7" (lemma "elemM1_fixes_pivots") (("7" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("7" (assert) (("7" (inst -1 "cr") (("7" (assert) (("7" (inst-cp -7 "cr") (("7" (assert) (("7" (replace -1 :hide? t) (("7" (lemma "elemM1_prop") (("7" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "_") (("7" (expand "rowV") (("7" (expand "+" -1) (("7" (expand "*" -1 2) (("7" (inst -1 "i") (("7" (lift-if) (("7" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -1 "pivot(M, cr)") (("1" (replace -10) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "pivot(M, cr)") (("1" (replace -1 :hide? t) (("1" (inst -11 "i") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (+ const-decl "real" vectors "vectors/") (elemM1_fixes_pivots formula-decl nil gauss_jordan nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM1_fixes_r_pivot formula-decl nil gauss_jordan nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (Index type-eq-decl nil vectors "vectors/") (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (zero_isnt_nonzero formula-decl nil elementary_matrices nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pivot_prop formula-decl nil gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "Vector" vectors "vectors/") (rowV const-decl "Vector[M`cols]" matrices nil) (elemM1_prop formula-decl nil elementary_matrices nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil)) shostak)) (elemM1_prod_TCC1 0 (elemM1_prod_TCC1-1 nil 3524883978 ("" (skeep :preds? t) (("" (assert) (("" (replace -1) (("" (propax) nil nil)) nil)) nil)) nil) nil nil)) (elemM1_prod 0 (elemM1_prod-1 nil 3523344726 ("" (skeep :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (expand "append1" 3 1) (("" (rewrite "every_append") (("" (replace -1) (("" (assert) (("" (expand "every" 3) (("" (expand "every" 3) (("" (expand "elemMat?" 3) (("" (rewrite "elem_prod_append1" :dir rl) (("" (expand "elemMat?" 1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (every_append formula-decl nil list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (square? const-decl "bool" matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (elemMat1? const-decl "bool" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (elem_prod_append1 formula-decl nil elementary_matrices nil) (append1 const-decl "list[T]" more_list_props nil)) shostak)) (ge1_step_TCC1 0 (ge1_step_TCC1-1 nil 3522172970 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (zero_row? const-decl "bool" elementary_matrices nil)) nil)) (ge1_step_TCC2 0 (ge1_step_TCC2-1 nil 3522172970 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (ge1_step_TCC3 0 (ge1_step_TCC3-1 nil 3522172970 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (ge1_step_TCC4 0 (ge1_step_TCC4-1 nil 3522172970 ("" (skeep :preds? t) (("" (assert) (("" (inst -8 "cr") nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (ge1_step_TCC5 0 (ge1_step_TCC5-1 nil 3522172970 ("" (grind) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (ge1_step_TCC6 0 (ge1_step_TCC6-1 nil 3522172970 ("" (skeep :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (replace -1 :hide? t) (("" (replace -1 :hide? t) (("" (inst-cp -5 "cr") (("" (assert) (("" (replace -8) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge1_step_TCC7 0 (ge1_step_TCC7-1 nil 3522172970 ("" (skeep :preds? t) (("" (assert) (("" (replace -7) (("" (replace -9) (("" (skeep :preds? t) (("" (inst -12 "i") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i skolem-const-decl "upto(r)" gauss_jordan nil) (r skolem-const-decl "{r: below(M`rows) |
         FORALL (i: below(r)): i /= cr => M`matrix(i, pivot(M, cr)) = 0}" gauss_jordan nil) (cr skolem-const-decl "{cr: below(M`rows) |
         rref?(M, cr) &
          (FORALL (i: upto(cr)): nonzero_row?(M, i)) &
           M`matrix(cr, pivot(M, cr)) = 1 &
            (FORALL (i: subrange(cr, M`rows - 1)):
               nonzero_row?(M, i) => pivot(M, cr) <= pivot(M, i))}" gauss_jordan nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (M skolem-const-decl "{M: Matrix | M`rows = OM`rows AND M`cols = OM`cols}" gauss_jordan nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (ge1_step_TCC8 0 (ge1_step_TCC8-1 nil 3523942605 ("" (skeep :preds? t) (("" (replace -1) (("" (assert) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge1_step_TCC9 0 (ge1_step_TCC9-1 nil 3524407309 ("" (skeep :preds? t) (("" (skeep 3 :preds? t) (("" (skeep 3 :preds? t) (("" (replace -17) (("" (use "elemM1_rref_pivot") (("" (assert) (("" (flatten) (("" (assert) (("" (replace -23 :dir rl) (("" (replace -4) (("" (replace -7) (("" (skeep 3 :preds? t) (("" (inst -8 "i") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (elemM1_rref_pivot formula-decl nil gauss_jordan nil)) nil)) (ge1_step_TCC10 0 (ge1_step_TCC10-1 nil 3525623063 ("" (skeep :preds? t) (("" (skeep 3 :preds? t) (("" (skeep 3 :preds? t) (("" (replace -17) (("" (use "elemM1_prod") (("" (assert) (("" (replace -6) (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (square? const-decl "bool" matrices nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (elemM1_prod formula-decl nil gauss_jordan nil)) nil)) (ge1_step_rref_pivot_TCC1 0 (ge1_step_rref_pivot_TCC1-1 nil 3524990409 ("" (subtype-tcc) nil nil) nil nil)) (ge1_step_rref_pivot_TCC2 0 (ge1_step_rref_pivot_TCC2-1 nil 3524990409 ("" (subtype-tcc) nil nil) nil nil)) (ge1_step_rref_pivot_TCC3 0 (ge1_step_rref_pivot_TCC3-1 nil 3524990409 ("" (skeep :preds? t) (("" (inst -21 "cr") nil nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil)) nil)) (ge1_step_rref_pivot_TCC4 0 (ge1_step_rref_pivot_TCC4-1 nil 3524990409 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil)) nil)) (ge1_step_rref_pivot 0 (ge1_step_rref_pivot-1 nil 3525015792 ("" (skeep :preds? t) (("" (assert) (("" (hide -3 -4) (("" (lemma "elemM1_prop") (("" (expand "ge1_step") (("" (inst -1 "M" "r" "cr" "(-M`matrix(r, pivot(M, cr)))" "_") (("1" (split 1) (("1" (skeep :preds? t) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (inst -8 "i") nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "rowV") (("2" (expand "+" -2) (("2" (expand "*" -2 2) (("2" (inst -2 "i") (("2" (lift-if) (("2" (split -2) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (inst -1 "pivot(M, r)") (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) (("1" (inst -1 "pivot(M, r)") (("1" (replace -1) (("1" (inst -9 "r") (("1" (expand "nonzero_row?" 4) (("1" (inst 4 "pivot(M, r)") (("1" (replace -2 :hide? t) (("1" (assert) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "r") (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "pivot_prop") (("2" (inst -1 "M" "r") (("2" (flatten) (("2" (inst -1 "pivot(M, cr)") (("2" (assert) (("2" (hide -1 7) (("2" (expand "rref?") (("2" (flatten) (("2" (inst -7 "r") (("2" (expand "rref_row_inv") (("2" (split -7) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -9 "j!1") nil nil)) nil)) nil) ("3" (inst -7 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil) ("3" (inst -7 "r") nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst-cp -7 "i") (("1" (expand "nonzero_row?" (-8 4)) (("1" (skosimp -8 :preds? t) (("1" (inst 4 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (lift-if) (("2" (expand "rowV") (("2" (expand "+" -4) (("2" (expand "*" -4 2) (("2" (split 1) (("1" (flatten) (("1" (inst -12 "i") (("1" (inst-cp -10 "i") (("1" (assert) nil nil) ("2" (assert) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "elemM1_fixes_pivots") (("2" (inst -1 "M" "cr" "r" "-M`matrix(r, pivot(M, cr))") (("2" (assert) (("2" (inst -1 "cr") (("2" (assert) (("2" (inst-cp -10 "cr") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (case-replace "i = r") (("1" (use "elemM1_fixes_r_pivot") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (inst -13 "r") (("1" (assert) (("1" (expand "nonzero_row?" 4) (("1" (inst 4 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "pivot_prop") (("2" (inst -1 "M" "r") (("2" (flatten) (("2" (inst -1 "pivot(M, cr)") (("2" (assert) (("2" (typepred "pivot(M, r)") (("2" (typepred "min({j_1: below(M`cols) | M`matrix(r, j_1) /= 0})") (("1" (replace -5 :dir rl :hide? t) (("1" (inst -3 "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, r)") (("1" (split -3) (("1" (assert) nil nil) ("2" (lemma "pivot_prop") (("2" (inst -1 "elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M" "r") (("2" (flatten) (("2" (inst -9 "r") (("2" (decompose-equality -9) (("1" (inst -1 "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, r)") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) (("1" (inst -1 "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, r)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=") (("2" (inst -1 "pivot(M, r)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "elemM1_fixes_pivots") (("2" (assert) (("2" (inst -1 "i") (("2" (assert) (("2" (case "nonzero_row?(M, i)") (("1" (assert) (("1" (replace -2 :hide? t) (("1" (inst -13 "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -5 "i") (("2" (assert) (("2" (decompose-equality -5) (("1" (expand "nonzero_row?" (-5 1)) (("1" (skosimp -5 :preds? t) (("1" (inst -2 "j!1") (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (replace -6) (("2" (skosimp 1 :preds? t) (("2" (inst -10 "i!1") (("1" (assert) nil nil) ("2" (hide-all-but (-1 -2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM1_prop formula-decl nil elementary_matrices nil) (minus_real_is_real application-judgement "real" reals nil) (r skolem-const-decl "{r: below(M`rows) |
         FORALL (i: below(r)): i /= cr => M`matrix(i, pivot(M, cr)) = 0}" gauss_jordan nil) (cr skolem-const-decl "{cr: below(M`rows) |
         rref?(M, cr) &
          (FORALL (i: upto(cr)): nonzero_row?(M, i)) &
           M`matrix(cr, pivot(M, cr)) = 1 &
            (FORALL (i: subrange(cr, M`rows - 1)):
               nonzero_row?(M, i) => pivot(M, cr) <= pivot(M, i))}" gauss_jordan nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (M skolem-const-decl "{M: Matrix | M`rows = OM`rows AND M`cols = OM`cols}" gauss_jordan nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (elemM1_fixes_pivots formula-decl nil gauss_jordan nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (elemM1_fixes_r_pivot formula-decl nil gauss_jordan nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (el skolem-const-decl "{el: list[ElemMat(M`rows)] | elem_product_left(OM, el) = M}" gauss_jordan nil) (i skolem-const-decl "subrange(cr, ge1_step(OM, M, el, cr, r)`1`rows - 1)" gauss_jordan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "real" vectors "vectors/") (real_times_real_is_real application-judgement "real" reals nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (pivot_prop formula-decl nil gauss_jordan nil) (sigma def-decl "real" sigma "reals/") (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Index type-eq-decl nil vectors "vectors/") (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (* const-decl "Vector" vectors "vectors/") (rowV const-decl "Vector[M`cols]" matrices nil) (i!1 skolem-const-decl "subrange(cr, ge1_step(OM, M, el, cr, r)`1`rows - 1)" gauss_jordan nil) (ge1_step const-decl "[M1:
   {M1: Matrix |
               M1`rows = OM`rows & M1`cols = OM`cols & rref?(M1, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M1, i))
             & M1`matrix(cr, pivot(M1, cr)) = 1
             & (FORALL (i: subrange(cr, M1`rows - 1)):
                  nonzero_row?(M1, i) => pivot(M1, cr) <= pivot(M1, i))
             & (FORALL (i: upto(r)):
                  i /= cr => M1`matrix(i, pivot(M1, cr)) = 0)},
 {el: list[ElemMat(OM`rows)] | elem_product_left(OM, el) = M1}]" gauss_jordan nil)) shostak)) (ge1_step_rref_TCC1 0 (ge1_step_rref_TCC1-1 nil 3524990733 ("" (subtype-tcc) nil nil) nil nil)) (ge1_step_rref 0 (ge1_step_rref-2 "" 3525711365 ("" (skeep :preds? t) (("" (assert) (("" (hide -3 -4) (("" (name-replace "M1" "ge1_step(OM, M, el, cr, r)`1") (("" (typepred "M1") (("" (expand "rref?" (-3 1)) (("" (flatten) (("" (expand "row_echelon_form_below?") (("" (flatten) (("" (split 1) (("1" (skeep :preds? t) (("1" (case-replace "i = cr") (("1" (assert) (("1" (inst -11 "j") (("1" (lemma "zero_isnt_nonzero") (("1" (inst -1 "M1" "j") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -7 "i" "j") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (inst -7 "i") (("1" (assert) (("1" (inst -7 "j") nil nil)) nil) ("2" (inst -7 "j") (("2" (expand "rref_row_inv" -7) (("2" (split -7) (("1" (flatten) (("1" (lemma "pivot_prop") (("1" (inst -3 "cr") (("1" (assert) (("1" (inst -4 "cr" "pivot(M1, i)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp + :preds? t) (("2" (inst -9 "j!1") nil nil)) nil)) nil) ("3" (inst -7 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (expand "rref_row_inv") (("3" (flatten) (("3" (case-replace "i = cr") (("1" (assert) (("1" (split 1) (("1" (skeep :preds? t) (("1" (case "j < cr") (("1" (inst -11 "j") (("1" (split -11) (("1" (flatten) (("1" (inst -2 "cr") (("1" (assert) (("1" (inst -3 "cr" "pivot(M1, cr)") (("1" (assert) nil nil) ("2" (inst -16 "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep :preds? t) (("2" (inst -13 "j_1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (inst -11 "j") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -14 "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (assert) (("2" (replace -4) (("2" (inst -15 "j") (("2" (split -15) (("1" (lemma "pivot_prop") (("1" (inst -1 "M1" "j") (("1" (flatten) (("1" (inst -1 "k") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nonzero_row?" 1) (("2" (inst 1 "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -8 "i") (("1" (split -8) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (square? const-decl "bool" matrices nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (ge1_step const-decl "[M1:
   {M1: Matrix |
               M1`rows = OM`rows & M1`cols = OM`cols & rref?(M1, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M1, i))
             & M1`matrix(cr, pivot(M1, cr)) = 1
             & (FORALL (i: subrange(cr, M1`rows - 1)):
                  nonzero_row?(M1, i) => pivot(M1, cr) <= pivot(M1, i))
             & (FORALL (i: upto(r)):
                  i /= cr => M1`matrix(i, pivot(M1, cr)) = 0)},
 {el: list[ElemMat(OM`rows)] | elem_product_left(OM, el) = M1}]" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (zero_isnt_nonzero formula-decl nil elementary_matrices nil) (j skolem-const-decl "below(1 + cr)" gauss_jordan nil) (i skolem-const-decl "below(1 + cr)" gauss_jordan nil) (cr skolem-const-decl "{cr: below(M`rows) |
         rref?(M, cr) &
          (FORALL (i: upto(cr)): nonzero_row?(M, i)) &
           M`matrix(cr, pivot(M, cr)) = 1 &
            (FORALL (i: subrange(cr, M`rows - 1)):
               nonzero_row?(M, i) => pivot(M, cr) <= pivot(M, i))}" gauss_jordan nil) (M skolem-const-decl "{M: Matrix | M`rows = OM`rows AND M`cols = OM`cols}" gauss_jordan nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (pivot_prop formula-decl nil gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i skolem-const-decl "below(1 + cr)" gauss_jordan nil) (j_1 skolem-const-decl "below(j)" gauss_jordan nil) (j skolem-const-decl "below(M1`rows)" gauss_jordan nil) (M1 skolem-const-decl "{M1: Matrix |
            M1`rows = OM`rows & M1`cols = OM`cols & rref?(M1, cr)
          & FORALL (i: upto(cr)): nonzero_row?(M1, i)
          & M1`matrix(cr, pivot(M1, cr)) = 1
          & FORALL (i: subrange(cr, M1`rows - 1)):
              nonzero_row?(M1, i) => pivot(M1, cr) <= pivot(M1, i)
          & FORALL (i: upto(r)): i /= cr => M1`matrix(i, pivot(M1, cr)) = 0}" gauss_jordan nil) (r skolem-const-decl "{r: below(M`rows) |
         FORALL (i: below(r)): i /= cr => M`matrix(i, pivot(M, cr)) = 0}" gauss_jordan nil) (j skolem-const-decl "subrange(i, M1`rows - 1)" gauss_jordan nil) (k skolem-const-decl "below(pivot(M1, i))" gauss_jordan nil) (i skolem-const-decl "below(1 + cr)" gauss_jordan nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak) (ge1_step_rref-1 nil 3525374243 ("" (skeep :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (split 1) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil) ("3" (expand "ge1_step") (("3" (lift-if) (("3" (split 1) (("1" (flatten) (("1" (assert) (("1" (expand "rref?") (("1" (flatten) (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -11 "i" "j") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "zero_isnt_nonzero") (("2" (inst -1 "M" "j") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (inst -13 "j") (("3" (lemma "zero_isnt_nonzero") (("3" (inst -1 "M" "j") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (inst -11 "i") (("1" (assert) (("1" (inst -11 "j") nil nil)) nil) ("2" (assert) (("2" (hide -5 -6 -7 -8) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (ge1_step_zeros_TCC1 0 (ge1_step_zeros_TCC1-1 nil 3525146893 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil)) (ge1_step_zeros_TCC2 0 (ge1_step_zeros_TCC2-1 nil 3525146893 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (assert) (("" (inst -5 "cr") nil nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (ge1_step_zeros 0 (ge1_step_zeros-1 nil 3525485399 ("" (skeep :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (skeep 2 :preds? t) (("" (hide -4 -5) (("" (expand "ge1_step") (("" (lift-if) (("" (split 3) (("1" (flatten) (("1" (assert) (("1" (inst -11 "i") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "elemM1_fixes_pivots") (("1" (assert) (("1" (inst -1 "cr") (("1" (assert) (("1" (inst-cp -7 "cr") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (lemma "elemM1_prop") (("1" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "i") (("1" (expand "rowV") (("1" (assert) (("1" (lift-if) (("1" (split -1) (("1" (expand "+" -1) (("1" (expand "*" -1 2) (("1" (flatten) (("1" (decompose-equality -2) (("1" (inst -1 "pivot(M, cr)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -12 "i") (("1" (assert) (("1" (inst -1 "pivot(M, cr)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM1_prop formula-decl nil elementary_matrices nil) (rowV const-decl "Vector[M`cols]" matrices nil) (+ const-decl "real" vectors "vectors/") (sigma def-decl "real" sigma "reals/") (NOT const-decl "[bool -> bool]" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (* const-decl "Matrix" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (Index type-eq-decl nil vectors "vectors/") (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "Vector" vectors "vectors/") (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (elemM1_fixes_pivots formula-decl nil gauss_jordan nil) (i skolem-const-decl "below(1 + r)" gauss_jordan nil) (r skolem-const-decl "{r: below(M`rows) |
         FORALL (i: below(r)): i /= cr => M`matrix(i, pivot(M, cr)) = 0}" gauss_jordan nil) (cr skolem-const-decl "{cr: below(M`rows) |
         rref?(M, cr) &
          (FORALL (i: upto(cr)): nonzero_row?(M, i)) &
           M`matrix(cr, pivot(M, cr)) = 1 &
            (FORALL (i: subrange(cr, M`rows - 1)):
               nonzero_row?(M, i) => pivot(M, cr) <= pivot(M, i))}" gauss_jordan nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (M skolem-const-decl "{M: Matrix | M`rows = OM`rows AND M`cols = OM`cols}" gauss_jordan nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (ge1_step const-decl "[M1:
   {M1: Matrix |
               M1`rows = OM`rows & M1`cols = OM`cols & rref?(M1, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M1, i))
             & M1`matrix(cr, pivot(M1, cr)) = 1
             & (FORALL (i: subrange(cr, M1`rows - 1)):
                  nonzero_row?(M1, i) => pivot(M1, cr) <= pivot(M1, i))
             & (FORALL (i: upto(r)):
                  i /= cr => M1`matrix(i, pivot(M1, cr)) = 0)},
 {el: list[ElemMat(OM`rows)] | elem_product_left(OM, el) = M1}]" gauss_jordan nil)) shostak)) (ge1_rec_TCC1 0 (ge1_rec_TCC1-1 nil 3520018082 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (zero_row? const-decl "bool" elementary_matrices nil)) nil)) (ge1_rec_TCC2 0 (ge1_rec_TCC2-1 nil 3520018082 ("" (skeep :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (hide -3 -4 -17 -18 -19) (("" (replace -15 :hide? t) (("" (expand "rref?") (("" (flatten) (("" (expand "ge1_step") (("" (assert) (("" (lemma "elemM1_prop") (("" (inst -1 "M" "r" "cr" "-M`matrix(r, pc)" "_") (("1" (split 2) (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (assert) (("1" (split 1) (("1" (assert) (("1" (skeep :preds? t) (("1" (inst -9 "i" "j") (("1" (assert) (("1" (expand "nonzero_row?") (("1" (skosimp :preds? t) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (split -1) (("1" (replace -1) (("1" (split 3) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (inst 3 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -5 "i") (("2" (expand "rowV") (("2" (lift-if) (("2" (split -5) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (expand "top_left_fixed?") (("1" (split 5) (("1" (inst 1 "pc") (("1" (assert) nil nil)) nil) ("2" (expand "zero_row?") (("2" (skosimp :preds? t) (("2" (inst -12 "j") (("2" (split -12) (("1" (inst -1 "j!2") nil nil) ("2" (flatten) (("2" (inst -9 "pivot(M, j)") (("1" (reveal -3) (("1" (inst -1 "j") (("1" (expand "rowV") (("1" (lift-if) (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (decompose-equality -2) (("1" (assert) (("1" (inst -1 "pivot(M, r)") (("1" (replace -1 :hide? t) (("1" (expand "+" -10) (("1" (expand "*" -10) (("1" (replace -2) (("1" (assert) (("1" (expand "bottom_left_zero?") (("1" (inst -18 "cr" "pivot(M, r)") (("1" (replace -18) (("1" (assert) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge1_rec_TCC3 0 (ge1_rec_TCC3-3 "" 3522344856 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (assert) nil nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak) (ge1_rec_TCC3-2 "" 3520021836 ("" (skeep :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (split 2) (("1" (replace -16 :hide? t) (("1" (expand "ge1_step" 1) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (assert) (("1" (lemma "elemM1_prop") (("1" (inst -1 "M" "r" "cr" "-M`matrix(r, c)" "cr") (("1" (lift-if) (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand "rowV") (("2" (decompose-equality -1) (("1" (inst -1 "c") (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (inst -11 "i") (("1" (assert) (("1" (replace -17 +) (("1" (expand "ge1_step") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (split -16) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (lemma "elemM1_prop") (("2" (inst -1 "M" "r" "cr" "-M`matrix(r, c)" "i") (("2" (lift-if) (("2" (assert) (("2" (expand "rowV") (("2" (decompose-equality -1) (("2" (inst -1 "c") (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -16 :hide? t) (("2" (lemma "elemM1_prop") (("2" (expand "ge1_step" +) (("2" (assert) (("2" (lift-if) (("2" (inst -1 "M" "r" "cr" "-M`matrix(r, c)" "i") (("2" (assert) (("2" (expand "rowV") (("2" (decompose-equality -1) (("1" (inst -1 "c") (("1" (assert) (("1" (replace -1) (("1" (split 3) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "+") (("2" (expand "*") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-5 -6 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-4 -5 -6 -10 1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (* const-decl "Vector" vectors "vectors/") (+ const-decl "real" vectors "vectors/") (Vector type-eq-decl nil vectors "vectors/") (Index type-eq-decl nil vectors "vectors/") (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (rowV const-decl "Vector[M`cols]" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma "reals/") (NOT const-decl "[bool -> bool]" booleans nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (elemM1_prop formula-decl nil elementary_matrices nil)) shostak) (ge1_rec_TCC3-1 nil 3520018082 ("" (subtype-tcc) nil nil) nil nil)) (ge1_rec_TCC4 0 (ge1_rec_TCC4-1 nil 3520018082 ("" (skeep :preds? t) (("" (assert) (("" (inst -8 "cr") nil nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (ge1_rec_TCC5 0 (ge1_rec_TCC5-1 nil 3522904305 ("" (skeep :preds? t) (("" (assert) (("" (split 1) (("1" (expand "rref?" (-14 1)) (("1" (flatten) (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -18 "i" "j") (("1" (assert) nil nil) ("2" (lemma "zero_isnt_nonzero") (("2" (inst -1 "M1" "i") (("2" (assert) nil nil)) nil)) nil) ("3" (inst -20 "j") (("3" (lemma "zero_isnt_nonzero") (("3" (inst -1 "M1" "j") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (inst -18 "i") (("1" (assert) (("1" (inst -18 "j") nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge1_rec_TCC6 0 (ge1_rec_TCC6-2 "" 3523378778 ("" (skeep :preds? t) (("" (assert) (("" (use "ge1_step_rref") (("" (assert) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (square? const-decl "bool" matrices nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (ge1_step_rref formula-decl nil gauss_jordan nil)) shostak) (ge1_rec_TCC6-1 nil 3522904305 ("" (skeep :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (hide -3 -4 -13 -14 -16) (("" (replace -12 :hide? t) (("" (expand "ge1_step") (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (replace -1) (("1" (expand "rref?") (("1" (flatten) (("1" (split 1) (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -9 "i" "j") (("1" (assert) nil nil) ("2" (lemma "zero_isnt_nonzero") (("2" (inst -1 "M" "cr") (("2" (assert) nil nil)) nil)) nil) ("3" (assert) (("3" (flatten) (("3" (inst -12 "j") (("1" (flatten) (("1" (lemma "zero_isnt_nonzero") (("1" (inst -1 "M" "j") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "zero_isnt_nonzero") (("2" (inst -1 "M" "cr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (inst -7 "i") (("1" (assert) nil nil) ("2" (assert) (("2" (skeep 3 :preds? t) (("2" (lemma "zero_or_nonzero") (("2" (inst -1 "M" "cr") (("2" (assert) (("2" (flatten) (("2" (inst -11 "j") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (inst -8 "ri") (("1" (split -8) (("1" (inst -1 "ci") nil nil) ("2" (propax) nil nil)) nil) ("2" (assert) (("2" (split -8) (("1" (flatten) (("1" (assert) (("1" (skeep 3 :preds? t) (("1" (assert) (("1" (inst -12 "rj") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonzero_row?" 1) (("2" (inst 1 "ci") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide -8 -9) (("2" (lemma "elemM1_prop") (("2" (inst -1 "M" "r" "cr" "-M`matrix(r, pivot(M, cr))" "_") (("2" (expand "rref?") (("2" (flatten) (("2" (split 4) (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep 1 :preds? t) (("1" (inst-cp -5 "i") (("1" (lift-if) (("1" (split -6) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand "rowV") (("2" (decompose-equality -1) (("2" (expand "nonzero_row?" -4) (("2" (skosimp) (("2" (inst -1 "j!1") (("2" (replace -1 :hide? t) (("2" (inst -4 "j") (("2" (lift-if) (("2" (assert) (("2" (decompose-equality -4) (("2" (inst -8 "i" "j") (("1" (assert) (("1" (split 7) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "zero_row?" 1) (("2" (skosimp) (("2" (inst -1 "j!2") (("2" (expand "zero_row?" -4) (("2" (inst -4 "j!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "zero_row?" -4) (("2" (expand "zero_row?" 6) (("2" (skosimp) (("2" (inst -1 "j!2") (("2" (inst -4 "j!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split -10) (("1" (flatten) (("1" (inst -2 "j") (("1" (flatten) (("1" (expand "nonzero_row?" -2) (("1" (skosimp) (("1" (inst -3 "j!2") (("1" (expand "zero_row?" -6) (("1" (inst -6 "j!2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "zero_row?" -5) (("2" (inst -2 "pivot(M, cr)") (("2" (inst -5 "pivot(M, cr)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "zero_or_nonzero") (("2" (inst -1 "M" "cr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep 2 :preds? t) (("2" (inst-cp -3 "i") (("2" (assert) (("2" (expand "rowV") (("2" (inst -9 "i") (("1" (decompose-equality -4) (("1" (expand "zero_row?" -9) (("1" (split -9) (("1" (expand "zero_row?" 1) (("1" (skosimp) (("1" (inst -1 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "j") (("2" (inst -5 "j") (("2" (assert) (("2" (decompose-equality -5) (("2" (inst -15 "i") (("1" (assert) (("1" (inst -15 "j") nil nil)) nil) ("2" (assert) (("2" (hide -14 -15) (("2" (split -11) (("1" (flatten) (("1" (inst -2 "j") (("1" (flatten) (("1" (expand "nonzero_row?" -2) (("1" (skosimp) (("1" (hide 3) (("1" (hide-all-but (-3 -4 -5 3)) (("1" (typepred "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, i)") (("1" (hide -1) (("1" (name-replace "mini" "min({j_1:
              below((elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) *
                      M)`cols)
              |
              (elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M)`matrix
                  (i, j_1)
               /= 0})") (("1" (replace -1) (("1" (typepred "mini") (("1" (typepred "pivot(M, i)") (("1" (name-replace "mi" "min({j_1: below(M`cols) | M`matrix(i, j_1) /= 0})") (("1" (typepred "mi") (("1" (inst -3 "mini") (("1" (assert) (("1" (inst -8 "mi") (("1" (typepred "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, j)") (("1" (name-replace "minj" "min({j_1:
              below((elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) *
                      M)`cols)
              |
              (elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M)`matrix
                  (j, j_1)
               /= 0})") (("1" (typepred "minj") (("1" (typepred "pivot(M, j)") (("1" (name-replace "mj" "min({j_1: below(M`cols) | M`matrix(j, j_1) /= 0})") (("1" (typepred "mj") (("1" (inst -3 "minj") (("1" (inst -8 "mj") (("1" (assert) (("1" (replace -10) (("1" (split -3) (("1" (split -8) (("1" (split -18) (("1" (split -14) (("1" (assert) nil nil) ("2" (inst -21 "mini") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -21 "mi") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -19 "mj") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -19 "minj") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -18 "minj") (("2" (inst -1 "minj") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (reveal 1) (("2" (inst -1 "j!1") (("2" (inst -12 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -1 "mini") (("1" (inst -9 "mini") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (reveal 6) (("2" (expand "zero_row?" 1) (("2" (skosimp) (("2" (inst -1 "j!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "zero_or_nonzero") (("2" (inst -1 "M" "cr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality -4) (("2" (hide -14) (("2" (hide -13) (("2" (hide -8) (("2" (split -9) (("1" (flatten) (("1" (inst -2 "j") (("1" (hide -13) (("1" (inst -6 "j") (("1" (assert) (("1" (decompose-equality -6) (("1" (hide-all-but (-1 -4 -5 3)) (("1" (typepred "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, i)") (("1" (name-replace "mini" "min({j_1:
              below((elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) *
                      M)`cols)
              |
              (elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M)`matrix
                  (i, j_1)
               /= 0})") (("1" (replace -2) (("1" (typepred "mini") (("1" (typepred "pivot(M, i)") (("1" (name-replace "mi" "min({j_1: below(M`cols) | M`matrix(i, j_1) /= 0})") (("1" (replace -2) (("1" (typepred "mi") (("1" (typepred "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, j)") (("1" (name-replace "minj" "min({j_1:
              below((elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) *
                      M)`cols)
              |
              (elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M)`matrix
                  (j, j_1)
               /= 0})") (("1" (replace -2) (("1" (typepred "minj") (("1" (typepred "pivot(M, j)") (("1" (name-replace "mj" "min({j_1: below(M`cols) | M`matrix(j, j_1) /= 0})") (("1" (replace -2) (("1" (typepred "mj") (("1" (inst -8 "mj") (("1" (inst -3 "minj") (("1" (inst -13 "mini") (("1" (inst -18 "mi") (("1" (split -3) (("1" (split -8) (("1" (split -13) (("1" (split -18) (("1" (assert) nil nil) ("2" (inst -22 "mi") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -22 "mini") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -20 "mj") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -20 "minj") (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-14 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-15 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (reveal -5) (("2" (expand "nonzero_row?" -1) (("2" (skosimp) (("2" (inst -16 "j!1") (("2" (assert) (("2" (inst -1 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (reveal -4) (("2" (expand "nonzero_row?" -1) (("2" (skosimp -1) (("2" (inst -1 "j!1") (("2" (inst -11 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -1 "mini") (("1" (inst -10 "mini") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal 4) (("2" (lemma "zero_or_nonzero") (("2" (inst -1 "M" "cr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (reveal 4) (("2" (expand "zero_row?" 1) (("2" (skosimp 1) (("2" (inst -1 "j!1") (("2" (inst -5 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "zero_or_nonzero") (("2" (inst -1 "M" "cr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (inst -13 "ri") (("1" (split -13) (("1" (inst -1 "ci") nil nil) ("2" (propax) nil nil)) nil) ("2" (split -9) (("1" (flatten) (("1" (hide -10) (("1" (hide -12) (("1" (inst-cp -5 "cr") (("1" (expand "rowV") (("1" (decompose-equality -6) (("1" (case-replace "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) *
M, ri) = pivot(M, ri)") (("1" (inst -2 "pivot(M, ri)") (("1" (assert) (("1" (skeep 3 :preds? t) (("1" (inst -8 "rj") (("1" (assert) (("1" (decompose-equality -8) (("1" (inst -1 "pivot(M, ri)") (("1" (replace -1) (("1" (inst -14 "rj") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (typepred "pivot(elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M, ri)") (("2" (name-replace "mini" "min({j_1:
              below((elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) *
                      M)`cols)
              |
              (elemM1(M`rows)(r, cr)(-M`matrix(r, pivot(M, cr))) * M)`matrix
                  (ri, j_1)
               /= 0})") (("1" (replace -2) (("1" (typepred "pivot(M, ri)") (("1" (name-replace "mi" "min({j_1: below(M`cols) | M`matrix(ri, j_1) /= 0})") (("1" (replace -2) (("1" (typepred "mi") (("1" (typepred "mini") (("1" (inst -3 "mi") (("1" (inst -6 "mini") (("1" (split -3) (("1" (split -6) (("1" (assert) nil nil) ("2" (inst -10 "ri") (("2" (assert) (("2" (decompose-equality -10) (("2" (inst -1 "mini") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -10 "ri") (("2" (assert) (("2" (decompose-equality -10) (("2" (inst -1 "mi") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (reveal 5) (("2" (expand "zero_row?" 1) (("2" (skosimp 1) (("2" (inst -1 "j!1") (("2" (assert) (("2" (reveal 1 -6) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (reveal 1 5 -5) (("2" (expand "zero_row?" 2) (("2" (skosimp 2) (("2" (inst -2 "j!1") (("2" (inst -4 "ri") (("2" (assert) (("2" (decompose-equality -4) (("2" (inst -1 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "zero_or_nonzero") (("3" (inst -1 "M" "cr") (("3" (assert) nil nil)) nil)) nil) ("4" (expand "nonzero_row?" 1) (("4" (expand "zero_row?" 6) (("4" (skosimp 6) (("4" (inst 1 "j!1") (("4" (inst -6 "ri") (("4" (assert) (("4" (decompose-equality -6) (("4" (inst -1 "j!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "zero_or_nonzero") (("2" (inst -1 "M" "cr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge1_rec_TCC7 0 (ge1_rec_TCC7-1 nil 3523740694 ("" (skeep :preds? t) (("" (replace -12) (("" (replace -20) (("" (propax) nil nil)) nil)) nil)) nil) nil nil)) (ge1_rec_TCC8 0 (ge1_rec_TCC8-1 nil 3525553839 ("" (skeep :preds? t) (("" (use "ge1_step_rref_pivot") (("" (assert) (("" (flatten) (("" (replace -24) (("" (replace -1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ge1_step_rref_pivot formula-decl nil gauss_jordan nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (square? const-decl "bool" matrices nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (ge1_rec_TCC9 0 (ge1_rec_TCC9-1 nil 3526156691 ("" (skeep :preds? t) (("" (assert) (("" (skeep 2 :preds? t) (("" (inst -19 "i") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil)) (ge1_rec_TCC10 0 (ge1_rec_TCC10-1 nil 3526156691 ("" (skeep :preds? t) (("" (assert) nil nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge1_TCC1 0 (ge1_TCC1-1 nil 3520052916 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (ge1_TCC2 0 (ge1_TCC2-1 nil 3520052916 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (zero_row? const-decl "bool" elementary_matrices nil)) nil)) (ge1_TCC3 0 (ge1_TCC3-1 nil 3521566625 ("" (skeep :preds? t) (("" (grind) nil nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rref? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (zero_row? const-decl "bool" elementary_matrices nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil)) nil)) (ge1_TCC4 0 (ge1_TCC4-1 nil 3522863833 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (assert) nil nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge1_TCC5 0 (ge1_TCC5-1 nil 3524407309 ("" (skeep :preds? t) (("" (assert) (("" (inst -6 "cr") nil nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (ge1_TCC6 0 (ge1_TCC6-1 nil 3526156691 ("" (skeep :preds? t) (("" (expand "elem_product_left") (("" (propax) nil nil)) nil)) nil) ((elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil)) nil)) (ge1_TCC7 0 (ge1_TCC7-1 nil 3526179896 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil)) nil)) (ge2_TCC1 0 (ge2_TCC1-1 nil 3499441985 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (zero_row? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil)) nil)) (ge2_TCC2 0 (ge2_TCC2-1 nil 3499441985 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (ge2_TCC3 0 (ge2_TCC3-1 nil 3499441985 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (ge2_TCC4 0 (ge2_TCC4-1 nil 3499441985 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (assert) (("" (inst -6 "cr") nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge2_TCC5 0 (ge2_TCC5-1 nil 3499441985 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (M!1 skolem-const-decl "Matrix" gauss_jordan nil) (j!1 skolem-const-decl "below(M!1`cols)" gauss_jordan nil) (cr!1 skolem-const-decl "{cr: below(M!1`rows) |
         rref?(M!1, cr) & (FORALL (i: below(cr)): nonzero_row?(M!1, i))}" gauss_jordan nil) (pr!1 skolem-const-decl "{pr: subrange(cr!1, M!1`rows - 1) |
         nonzero_row?(M!1, pr) &
          (FORALL (i: subrange(cr!1, M!1`rows - 1)):
             nonzero_row?(M!1, i) => pivot(M!1, pr) <= pivot(M!1, i))}" gauss_jordan nil) (i!1 skolem-const-decl "upto(cr!1)" gauss_jordan nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (zero_row? const-decl "bool" elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil)) nil)) (ge2_TCC6 0 (ge2_TCC6-2 "" 3514602780 ("" (skeep :preds? t) (("" (expand "elem_product_left") (("" (propax) nil nil)) nil)) nil) ((elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil)) shostak) (ge2_TCC6-1 nil 3499441985 ("" (skosimp* :preds? t) (("" (expand "elemMat2?") (("" (skosimp* :preds? t) (("" (expand "elemM?") (("" (flatten) (("" (expand "elemM2?" 4) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (squareMat? const-decl "bool" matrices nil) (square? const-decl "bool" matrices nil)) nil)) (ge2_TCC7 0 (ge2_TCC7-3 "" 3519344830 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (replace -11) (("" (use "elemM2_rref_pivot") (("" (assert) (("" (flatten) (("" (assert) (("" (replace -4) (("" (skeep 2 :preds? t) (("" (inst -7 "i") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((elemM2_rref_pivot formula-decl nil gauss_jordan nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak) (ge2_TCC7-2 "" 3514603338 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (hide -4) (("" (typepred "me`2") (("" (use "every_nth[ElemMat(M_1`rows)]") (("" (assert) (("" (hide 3) (("" (use "every_nth[Matrix]") (("" (assert) (("" (hide -2) (("" (skeep :preds? t) (("" (inst -2 "i") (("1" (flatten) (("1" (replace -10) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (every_nth formula-decl nil list_props nil)) shostak) (ge2_TCC7-1 nil 3514526464 ("" (subtype-tcc) nil nil) nil nil)) (ge2_TCC8 0 (ge2_TCC8-1 nil 3520018082 ("" (grind) nil nil) ((/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil)) nil)) (ge2_TCC9 0 (ge2_TCC9-1 nil 3524880323 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (expand "every") (("" (propax) nil nil)) nil)) nil)) nil) ((every adt-def-decl "boolean" list_adt nil)) nil)) (ge2_TCC10 0 (ge2_TCC10-1 nil 3524880323 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (expand "elem_product_left") (("" (expand "elem_product_left") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil)) nil)) (ge3_TCC1 0 (ge3_TCC1-1 nil 3499441985 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (assert) nil nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge3_TCC2 0 (ge3_TCC2-1 nil 3499441985 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (ge3_TCC3 0 (ge3_TCC3-1 nil 3499441985 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (ge3_TCC4 0 (ge3_TCC4-1 nil 3499441985 ("" (skeep :preds? t) (("" (assert) (("" (inst -5 "cr") nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (ge3_TCC5 0 (ge3_TCC5-1 nil 3499441985 ("" (skeep :preds? t) (("" (assert) (("" (inst -5 "cr") nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge3_TCC6 0 (ge3_TCC6-1 nil 3499441985 ("" (skeep :preds? t) (("" (assert) (("" (replace -3) (("" (propax) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge3_TCC7 0 (ge3_TCC7-1 nil 3499441985 ("" (skeep :preds? t) (("" (expand "elem_product_left") (("" (propax) nil nil)) nil)) nil) ((elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil)) nil)) (ge3_TCC8 0 (ge3_TCC8-2 "" 3519344897 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (replace -9) (("" (replace -10) (("" (use "elemM3_rref_pivot") (("" (assert) (("" (flatten) (("" (assert) (("" (replace -4) (("" (skeep 2 :preds? t) (("" (inst -8 "i") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((elemM3_rref_pivot formula-decl nil gauss_jordan nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (* const-decl "Matrix" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nzreal nonempty-type-eq-decl nil reals nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak) (ge3_TCC8-1 nil 3504335429 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 3 :preds? t) (("" (use "every_nth[ElemMat(M_1`rows)]") (("" (assert) (("" (hide 4) (("" (skeep) (("" (assert) (("" (use "every_nth[Matrix]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every_nth formula-decl nil list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (square? const-decl "bool" matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (list type-decl nil list_adt nil) (ElemMat type-eq-decl nil elementary_matrices nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil)) (ge3_TCC9 0 (ge3_TCC9-1 nil 3522644594 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (expand "elemMat?") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((elemMat? const-decl "bool" elementary_matrices nil)) nil)) (ge3_TCC10 0 (ge3_TCC10-1 nil 3524880323 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (expand "every") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((every adt-def-decl "boolean" list_adt nil)) nil)) (ge3_TCC11 0 (ge3_TCC11-1 nil 3525849170 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (expand "elem_product_left") (("" (expand "elem_product_left") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil)) nil)) (ge_rec_rref_aux_TCC1 0 (ge_rec_rref_aux_TCC1-1 nil 3525143431 ("" (subtype-tcc) nil nil) nil nil)) (ge_rec_rref_aux_TCC2 0 (ge_rec_rref_aux_TCC2-1 nil 3525143431 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil)) nil)) (ge_rec_rref_aux 0 (ge_rec_rref_aux-1 nil 3525143432 ("" (skeep :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (expand "reduced_row_echelon_form?") (("" (expand "rref?") (("" (flatten) (("" (split 1) (("1" (expand "row_echelon_form?") (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -8 "i" "j") (("1" (assert) nil nil) ("2" (assert) (("2" (inst 3 "i") nil nil)) nil) ("3" (assert) (("3" (inst 3 "i") nil nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep 2 :preds? t) (("2" (inst -7 "i") (("1" (assert) (("1" (lemma "zero_or_nonzero") (("1" (inst -1 "M" "i") (("1" (assert) (("1" (inst -8 "j") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst 4 "i") (("2" (use "zero_or_nonzero") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (case "r < cr") (("1" (inst -8 "r") (("1" (expand "rref_row_inv") (("1" (assert) (("1" (split -8) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand "row_echelon_form_below?") (("2" (flatten) (("2" (skeep :preds? t) (("2" (inst -9 "r" "j") (("2" (assert) (("2" (use "zero_or_nonzero") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst 3 "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rref? const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (cr skolem-const-decl "{cr: below(OM`rows) | rref?(M, cr)}" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (i skolem-const-decl "below(M`rows)" gauss_jordan nil) (M skolem-const-decl "(LAMBDA (N): OM`rows = N`rows AND OM`cols = N`cols)" gauss_jordan nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (j skolem-const-decl "below(M`rows)" gauss_jordan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (zero_or_nonzero formula-decl nil elementary_matrices nil) (i skolem-const-decl "below(M`rows)" gauss_jordan nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (r skolem-const-decl "below(M`rows)" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil)) shostak)) (ge_rec_rref_pivot_TCC1 0 (ge_rec_rref_pivot_TCC1-1 nil 3525151020 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (ge_rec_rref_pivot_TCC2 0 (ge_rec_rref_pivot_TCC2-1 nil 3525151020 ("" (skeep :preds? t) (("" (use "ge_rec_rref_aux") (("" (assert) nil nil)) nil)) nil) ((ge_rec_rref_aux formula-decl nil gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge_rec_rref_pivot_TCC3 0 (ge_rec_rref_pivot_TCC3-1 nil 3525151020 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (j!3 skolem-const-decl "below(M!1`cols)" gauss_jordan nil) (j!3 skolem-const-decl "below(i!2)" gauss_jordan nil) (i!2 skolem-const-decl "below(M!1`rows)" gauss_jordan nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (find_pivot_row const-decl "{i: subrange(r, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(r, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (r!1 skolem-const-decl "below(M!1`rows)" gauss_jordan nil) (cr!1 skolem-const-decl "{cr: below(OM!1`rows) |
         rref?(M!1, cr) & (FORALL (i: below(cr)): nonzero_row?(M!1, i))}" gauss_jordan nil) (j!2 skolem-const-decl "below(M!1`cols)" gauss_jordan nil) (M!1 skolem-const-decl "(LAMBDA (N): OM!1`rows = N`rows AND OM!1`cols = N`cols)" gauss_jordan nil) (OM!1 skolem-const-decl "Matrix" gauss_jordan nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil)) nil)) (ge_rec_rref_pivot_TCC4 0 (ge_rec_rref_pivot_TCC4-1 nil 3525151020 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil)) nil)) (ge_rec_rref_pivot_TCC5 0 (ge_rec_rref_pivot_TCC5-1 nil 3525151020 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil)) nil)) (ge_rec_rref_pivot_TCC6 0 (ge_rec_rref_pivot_TCC6-1 nil 3525151020 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil)) nil)) (ge_rec_rref_pivot_TCC7 0 (ge_rec_rref_pivot_TCC7-1 nil 3525151020 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (inst -20 "cr") nil nil)) nil)) nil)) nil)) nil) ((nonzero_row? const-decl "bool" elementary_matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (ge_rec_rref_pivot 0 (ge_rec_rref_pivot-1 nil 3525151101 ("" (skeep :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (expand "ge2") (("" (lift-if) (("" (split 2) (("1" (flatten) (("1" (assert) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -7 "i") (("1" (typepred "find_pivot_row(M, cr)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "find_pivot_row(M, cr)") (("2" (assert) (("2" (skeep :preds? t) (("2" (assert) (("2" (inst -6 "i") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "find_pivot_row(M, cr)") (("2" (assert) (("2" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("2" (use "elemM2_rref_pivot") (("2" (assert) (("2" (expand "same_dim?") (("2" (flatten) (("2" (assert) (("2" (replace -4) (("2" (skeep 2 :preds? t) (("2" (inst -7 "i") (("1" (assert) nil nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM2_rref_pivot formula-decl nil gauss_jordan nil) (* const-decl "Matrix" matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (i skolem-const-decl "upto(cr)" gauss_jordan nil) (cr skolem-const-decl "{cr: below(OM`rows) |
         rref?(M, cr) & (FORALL (i: below(cr)): nonzero_row?(M, i))}" gauss_jordan nil) (M skolem-const-decl "(LAMBDA (N): OM`rows = N`rows AND OM`cols = N`cols)" gauss_jordan nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (find_pivot_row const-decl "{i: subrange(r, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(r, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (square? const-decl "bool" matrices nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (ge2 const-decl "[M2:
   {M2: Matrix |
               M2`rows = M`rows & M2`cols = M`cols & rref?(M2, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M2, i))
             & (FORALL (i: subrange(cr, M2`rows - 1)):
                  nonzero_row?(M2, i) => pivot(M2, cr) <= pivot(M2, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M2}]" gauss_jordan nil)) shostak)) (ge2_rref_pivot_TCC1 0 (ge2_rref_pivot_TCC1-1 nil 3525199300 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil)) nil)) (ge2_rref_pivot_TCC2 0 (ge2_rref_pivot_TCC2-1 nil 3525199300 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil)) nil)) (ge2_rref_pivot_TCC3 0 (ge2_rref_pivot_TCC3-1 nil 3525199300 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (hide -3 -4 -8 -9 -14 -15 -19 -20 -24 -27 -28) (("" (replace -16 :hide? t) (("" (expand "ge2") (("" (lift-if) (("" (split 2) (("1" (flatten) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "elemM2_prop") (("2" (expand "rowV") (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" (-9 2)) (("1" (skosimp :preds? t) (("1" (inst -2 "j!1") (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ge2 const-decl "[M2:
   {M2: Matrix |
               M2`rows = M`rows & M2`cols = M`cols & rref?(M2, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M2, i))
             & (FORALL (i: subrange(cr, M2`rows - 1)):
                  nonzero_row?(M2, i) => pivot(M2, cr) <= pivot(M2, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M2}]" gauss_jordan nil) (rowV const-decl "Vector[M`cols]" matrices nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (M skolem-const-decl "(LAMBDA (N): OM`rows = N`rows AND OM`cols = N`cols)" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (cr skolem-const-decl "{cr: below(OM`rows) |
         rref?(M, cr) & (FORALL (i: below(cr)): nonzero_row?(M, i))}" gauss_jordan nil) (pr skolem-const-decl "{i: subrange(cr, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(cr, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (sigma def-decl "real" sigma "reals/") (real_times_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (elemM2_prop formula-decl nil elementary_matrices nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge2_rref_pivot 0 (ge2_rref_pivot-3 "" 3549346689 ("" (skeep :preds? t) (("" (assert) (("" (hide -6 -7) (("" (split 2) (("1" (hide-all-but (-3 1)) (("1" (grind) nil nil)) nil) ("2" (skeep :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (lemma "elemM2_prop") (("2" (expand "ge2") (("2" (expand "rowV") (("2" (expand "reduced_row_echelon_form?") (("2" (expand "rref?") (("2" (flatten) (("2" (expand "row_echelon_form_below?") (("2" (flatten) (("2" (split 2) (("1" (case "cr = find_pivot_row(M, cr)") (("1" (assert) (("1" (inst -10 "i") (("1" (expand "nonzero_row?" -10) (("1" (skosimp -10 :preds? t) (("1" (inst 2 "j!1") nil nil)) nil)) nil) ("2" (inst 3 "pivot(M, cr)") (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "find_pivot_row(M, cr)") (("2" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("2" (case-replace "i = cr") (("1" (inst -6 "M" "cr" "pr" "cr") (("1" (decompose-equality -6) (("1" (expand "nonzero_row?" -5) (("1" (skosimp -5 :preds? t) (("1" (inst -2 "j!1") (("1" (inst 4 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (inst -13 "i") (("1" (expand "nonzero_row?" -13) (("1" (skosimp -13 :preds? t) (("1" (inst -6 "M" "cr" "pr" "i") (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -1 "j!1") (("1" (inst 4 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (1)) (("5" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (expand "row_echelon_form?") (("3" (split 2) (("1" (skosimp 1 :preds? t) (("1" (inst -10 "i!1" "j!1") (("1" (assert) nil nil) ("2" (inst 3 "i!1") (("2" (assert) nil nil)) nil) ("3" (inst 3 "i!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp 1 :preds? t) (("2" (inst 3 "i!1") (("1" (lemma "zero_or_nonzero") (("1" (inst -1 "M" "i!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp 3 :preds? t) (("2" (inst -9 "i!1") (("1" (lemma "zero_or_nonzero") (("1" (inst -1 "M" "i!1") (("1" (assert) (("1" (inst -10 "j!1") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp 1 :preds? t) (("2" (expand "rref_row_inv" -10) (("2" (case "r!1 < cr") (("1" (inst -11 "r!1") (("1" (split -11) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (hide -10) (("2" (case-replace "i = cr") (("1" (case "cr = find_pivot_row(M, cr)") (("1" (assert) (("1" (inst 3 "pivot(M, cr)") (("1" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("2" (inst -4 "M" "cr" "pr" "cr") (("1" (decompose-equality -4) (("1" (typepred "pr") (("1" (expand "nonzero_row?" -3) (("1" (skosimp -3 :preds? t) (("1" (inst -5 "j!1") (("1" (inst 5 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-11 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-10 1)) (("7" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (inst 1 "r!1") (("3" (assert) nil nil)) nil)) nil) ("2" (inst -10 "i") (("1" (expand "nonzero_row?" -10) (("1" (skosimp -10 :preds? t) (("1" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("1" (inst -4 "M" "cr" "pr" "i") (("1" (assert) (("1" (typepred "pr") (("1" (assert) (("1" (decompose-equality -8) (("1" (inst -1 "j!1") (("1" (inst 4 "j!1") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (1)) (("7" (grind) nil nil)) nil) ("8" (inst 5 "j!1") nil nil) ("9" (inst 4 "j!1") nil nil) ("10" (hide-all-but (1)) (("10" (grind) nil nil)) nil) ("11" (hide-all-but (1)) (("11" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (assert) (("2" (assert) (("2" (inst 5 "j!1") nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "r!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("3" (typepred "pr") (("3" (expand "ge2") (("3" (lift-if) (("3" (split 1) (("1" (flatten) (("1" (assert) (("1" (inst -5 "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "elemM2_fixes_pivots") (("2" (inst -1 "M" "cr" "pr") (("2" (assert) (("2" (inst-cp -1 "cr") (("2" (inst -1 "i") (("2" (assert) (("2" (split -2) (("1" (replace -1 :hide? t) (("1" (lift-if) (("1" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (replace -2 :hide? t) (("1" (inst -5 "cr") (("1" (assert) (("1" (lemma "elemM2_prop") (("1" (inst -1 "M" "cr" "pr" "pr") (("1" (expand "rowV") (("1" (decompose-equality -1) (("1" (expand "nonzero_row?" -8) (("1" (skosimp -8 :preds? t) (("1" (inst -2 "j!1") (("1" (expand "nonzero_row?" 3) (("1" (inst 3 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :hide? t) (("2" (inst -4 "i") (("2" (assert) (("2" (lemma "elemM2_prop") (("2" (inst -1 "M" "cr" "pr" "i") (("2" (expand "rowV") (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" -7) (("1" (skosimp -7 :preds? t) (("1" (expand "nonzero_row?" 4) (("1" (inst 4 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "nonzero_row?" -4) (("2" (skosimp -4 :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (inst 1 "j!1") (("1" (lemma "elemM2_prop") (("1" (inst -1 "M" "cr" "pr" "cr") (("1" (expand "rowV") (("1" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (ge2 const-decl "[M2:
   {M2: Matrix |
               M2`rows = M`rows & M2`cols = M`cols & rref?(M2, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M2, i))
             & (FORALL (i: subrange(cr, M2`rows - 1)):
                  nonzero_row?(M2, i) => pivot(M2, cr) <= pivot(M2, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M2}]" gauss_jordan nil) (* const-decl "Matrix" matrices nil) (sigma def-decl "real" sigma "reals/") (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil) (j!1 skolem-const-decl "below(r!1)" gauss_jordan nil) (r!1 skolem-const-decl "below(M`rows)" gauss_jordan nil) (pr skolem-const-decl "{i: subrange(cr, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(cr, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (pr skolem-const-decl "{i: subrange(cr, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(cr, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (find_pivot_row const-decl "{i: subrange(r, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(r, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (M skolem-const-decl "(LAMBDA (N): OM`rows = N`rows AND OM`cols = N`cols)" gauss_jordan nil) (cr skolem-const-decl "{cr: below(OM`rows) |
         rref?(M, cr) & (FORALL (i: below(cr)): nonzero_row?(M, i))}" gauss_jordan nil) (i skolem-const-decl "upto(cr)" gauss_jordan nil) (NOT const-decl "[bool -> bool]" booleans nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (square? const-decl "bool" matrices nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (pivot_prop formula-decl nil gauss_jordan nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (pr skolem-const-decl "{i: subrange(cr, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(cr, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (zero_or_nonzero formula-decl nil elementary_matrices nil) (i!1 skolem-const-decl "below(M`rows)" gauss_jordan nil) (j!1 skolem-const-decl "below(M`rows)" gauss_jordan nil) (i!1 skolem-const-decl "below(M`rows)" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil) (rowV const-decl "Vector[M`cols]" matrices nil) (elemM2_prop formula-decl nil elementary_matrices nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (pr skolem-const-decl "{i: subrange(cr, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(cr, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (j!1 skolem-const-decl "below((elemM2(M`rows)(cr, pr) * M)`cols)" gauss_jordan nil) (elemM2_fixes_pivots formula-decl nil gauss_jordan nil)) shostak) (ge2_rref_pivot-2 "" 3547755288 ("" (skeep :preds? t) (("" (assert) (("" (hide -6 -7) (("" (split 2) (("1" (hide-all-but (-3 1)) (("1" (grind) nil nil)) nil) ("2" (skeep :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (lemma "elemM2_prop") (("2" (expand "ge2") (("2" (expand "rowV") (("2" (expand "reduced_row_echelon_form?") (("2" (expand "rref?") (("2" (flatten) (("2" (expand "row_echelon_form_below?") (("2" (flatten) (("2" (split 2) (("1" (case "cr = find_pivot_row(M, cr)") (("1" (assert) (("1" (inst -10 "i") (("1" (expand "nonzero_row?" -10) (("1" (skosimp -10 :preds? t) (("1" (inst 2 "j!1") nil nil)) nil)) nil) ("2" (inst 3 "pivot(M, cr)") (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "find_pivot_row(M, cr)") (("2" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("2" (case-replace "i = cr") (("1" (inst -6 "M" "cr" "pr" "cr") (("1" (decompose-equality -6) (("1" (expand "nonzero_row?" -5) (("1" (skosimp -5 :preds? t) (("1" (inst -2 "j!1") (("1" (inst 4 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (inst -13 "i") (("1" (expand "nonzero_row?" -13) (("1" (skosimp -13 :preds? t) (("1" (inst -6 "M" "cr" "pr" "i") (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -1 "j!1") (("1" (inst 4 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (expand "row_echelon_form?") (("3" (split 2) (("1" (skosimp 1 :preds? t) (("1" (inst -10 "i!1" "j!1") (("1" (assert) nil nil) ("2" (inst 3 "i!1") (("2" (assert) nil nil)) nil) ("3" (inst 3 "i!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp 1 :preds? t) (("2" (inst 3 "i!1") (("1" (lemma "zero_or_nonzero") (("1" (inst -1 "M" "i!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp 3 :preds? t) (("2" (inst -9 "i!1") (("1" (lemma "zero_or_nonzero") (("1" (inst -1 "M" "i!1") (("1" (assert) (("1" (inst -10 "j!1") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp 1 :preds? t) (("2" (expand "rref_row_inv" -10) (("2" (case "r!1 < cr") (("1" (inst -11 "r!1") (("1" (split -11) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (hide -10) (("2" (case-replace "i = cr") (("1" (case "cr = find_pivot_row(M, cr)") (("1" (assert) (("1" (inst 3 "pivot(M, cr)") (("1" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("2" (inst -4 "M" "cr" "pr" "cr") (("1" (decompose-equality -4) (("1" (typepred "pr") (("1" (expand "nonzero_row?" -3) (("1" (skosimp -3 :preds? t) (("1" (inst -5 "j!1") (("1" (inst 5 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-11 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-10 1)) (("7" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (inst 1 "r!1") (("3" (assert) nil nil)) nil)) nil) ("2" (inst -10 "i") (("1" (expand "nonzero_row?" -10) (("1" (skosimp -10 :preds? t) (("1" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("1" (inst -4 "M" "cr" "pr" "i") (("1" (assert) (("1" (typepred "pr") (("1" (assert) (("1" (decompose-equality -8) (("1" (inst -1 "j!1") (("1" (inst 4 "j!1") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil) ("6" (inst 5 "j!1") nil nil) ("7" (inst 4 "j!1") nil nil) ("8" (hide-all-but (1)) (("8" (grind) nil nil)) nil) ("9" (hide-all-but (1)) (("9" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (assert) (("2" (assert) (("2" (inst 5 "j!1") nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "r!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("3" (typepred "pr") (("3" (expand "ge2") (("3" (lift-if) (("3" (split 1) (("1" (flatten) (("1" (assert) (("1" (inst -5 "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "elemM2_fixes_pivots") (("2" (inst -1 "M" "cr" "pr") (("2" (assert) (("2" (inst-cp -1 "cr") (("2" (inst -1 "i") (("2" (assert) (("2" (split -2) (("1" (replace -1 :hide? t) (("1" (lift-if) (("1" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (replace -2 :hide? t) (("1" (inst -5 "cr") (("1" (assert) (("1" (lemma "elemM2_prop") (("1" (inst -1 "M" "cr" "pr" "pr") (("1" (expand "rowV") (("1" (decompose-equality -1) (("1" (expand "nonzero_row?" -8) (("1" (skosimp -8 :preds? t) (("1" (inst -2 "j!1") (("1" (expand "nonzero_row?" 3) (("1" (inst 3 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :hide? t) (("2" (inst -4 "i") (("2" (assert) (("2" (lemma "elemM2_prop") (("2" (inst -1 "M" "cr" "pr" "i") (("2" (expand "rowV") (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" -7) (("1" (skosimp -7 :preds? t) (("1" (expand "nonzero_row?" 4) (("1" (inst 4 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "nonzero_row?" -4) (("2" (skosimp -4 :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (inst 1 "j!1") (("1" (lemma "elemM2_prop") (("1" (inst -1 "M" "cr" "pr" "cr") (("1" (expand "rowV") (("1" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((elemM2_fixes_pivots formula-decl nil gauss_jordan nil) nil nil nil (elemM2_prop formula-decl nil elementary_matrices nil) (rowV const-decl "Vector[M`cols]" matrices nil) (rref? const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) nil nil nil (zero_or_nonzero formula-decl nil elementary_matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) nil (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) nil nil (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (pivot_prop formula-decl nil gauss_jordan nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) nil (square? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (NOT const-decl "[bool -> bool]" booleans nil) nil nil nil nil (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (find_pivot_row const-decl "{i: subrange(r, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(r, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) nil nil nil nil nil nil (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil) nil (/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") nil (ge2 const-decl "[M2:
   {M2: Matrix |
               M2`rows = M`rows & M2`cols = M`cols & rref?(M2, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M2, i))
             & (FORALL (i: subrange(cr, M2`rows - 1)):
                  nonzero_row?(M2, i) => pivot(M2, cr) <= pivot(M2, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M2}]" gauss_jordan nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak) (ge2_rref_pivot-1 nil 3525566458 ("" (skeep :preds? t) (("" (assert) (("" (hide -6 -7) (("" (split 2) (("1" (hide-all-but (-3 1)) (("1" (grind) nil nil)) nil) ("2" (skeep :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (lemma "elemM2_prop") (("2" (expand "ge2") (("2" (expand "rowV") (("2" (expand "reduced_row_echelon_form?") (("2" (expand "rref?") (("2" (flatten) (("2" (expand "row_echelon_form_below?") (("2" (flatten) (("2" (split 2) (("1" (case "cr = find_pivot_row(M, cr)") (("1" (assert) (("1" (inst -10 "i") (("1" (expand "nonzero_row?" -10) (("1" (skosimp -10 :preds? t) (("1" (inst 2 "j!1") nil nil)) nil)) nil) ("2" (inst 3 "pivot(M, cr)") (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "find_pivot_row(M, cr)") (("2" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("2" (case-replace "i = cr") (("1" (inst -6 "M" "cr" "pr" "cr") (("1" (decompose-equality -6) (("1" (expand "nonzero_row?" -5) (("1" (skosimp -5 :preds? t) (("1" (inst -2 "j!1") (("1" (inst 4 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (inst -13 "i") (("1" (expand "nonzero_row?" -13) (("1" (skosimp -13 :preds? t) (("1" (inst -6 "M" "cr" "pr" "i") (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -1 "j!1") (("1" (inst 4 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-9 -12 1)) (("5" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (expand "row_echelon_form?") (("3" (split 2) (("1" (skosimp 1 :preds? t) (("1" (inst -10 "i!1" "j!1") (("1" (assert) nil nil) ("2" (inst 3 "i!1") (("2" (assert) nil nil)) nil) ("3" (inst 3 "i!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp 1 :preds? t) (("2" (inst 3 "i!1") (("1" (lemma "zero_or_nonzero") (("1" (inst -1 "M" "i!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp 3 :preds? t) (("2" (inst -9 "i!1") (("1" (lemma "zero_or_nonzero") (("1" (inst -1 "M" "i!1") (("1" (assert) (("1" (inst -10 "j!1") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp 1 :preds? t) (("2" (expand "rref_row_inv" -10) (("2" (case "r!1 < cr") (("1" (inst -11 "r!1") (("1" (split -11) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -13 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (hide -10) (("2" (case-replace "i = cr") (("1" (case "cr = find_pivot_row(M, cr)") (("1" (assert) (("1" (inst 3 "pivot(M, cr)") (("1" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("1" (lemma "pivot_prop") (("1" (inst -1 "M" "cr") (("1" (flatten) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("2" (inst -4 "M" "cr" "pr" "cr") (("1" (decompose-equality -4) (("1" (typepred "pr") (("1" (expand "nonzero_row?" -3) (("1" (skosimp -3 :preds? t) (("1" (inst -5 "j!1") (("1" (inst 5 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-11 1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (-10 1)) (("7" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (inst 1 "r!1") (("3" (assert) nil nil)) nil)) nil) ("2" (inst -10 "i") (("1" (expand "nonzero_row?" -10) (("1" (skosimp -10 :preds? t) (("1" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("1" (inst -4 "M" "cr" "pr" "i") (("1" (assert) (("1" (typepred "pr") (("1" (assert) (("1" (decompose-equality -8) (("1" (inst -1 "j!1") (("1" (inst 4 "j!1") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (1)) (("7" (grind) nil nil)) nil) ("8" (inst 5 "j!1") nil nil) ("9" (inst 4 "j!1") nil nil) ("10" (hide-all-but (1)) (("10" (grind) nil nil)) nil) ("11" (hide-all-but (1)) (("11" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (assert) (("2" (assert) (("2" (inst 5 "j!1") nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "r!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("3" (typepred "pr") (("3" (expand "ge2") (("3" (lift-if) (("3" (split 1) (("1" (flatten) (("1" (assert) (("1" (inst -5 "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "elemM2_fixes_pivots") (("2" (inst -1 "M" "cr" "pr") (("2" (assert) (("2" (inst-cp -1 "cr") (("2" (inst -1 "i") (("2" (assert) (("2" (split -2) (("1" (replace -1 :hide? t) (("1" (lift-if) (("1" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (replace -2 :hide? t) (("1" (inst -5 "cr") (("1" (assert) (("1" (lemma "elemM2_prop") (("1" (inst -1 "M" "cr" "pr" "pr") (("1" (expand "rowV") (("1" (decompose-equality -1) (("1" (expand "nonzero_row?" -8) (("1" (skosimp -8 :preds? t) (("1" (inst -2 "j!1") (("1" (expand "nonzero_row?" 3) (("1" (inst 3 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :hide? t) (("2" (inst -4 "i") (("2" (assert) (("2" (lemma "elemM2_prop") (("2" (inst -1 "M" "cr" "pr" "i") (("2" (expand "rowV") (("2" (decompose-equality -1) (("1" (expand "nonzero_row?" -7) (("1" (skosimp -7 :preds? t) (("1" (expand "nonzero_row?" 4) (("1" (inst 4 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "nonzero_row?" -4) (("2" (skosimp -4 :preds? t) (("2" (expand "nonzero_row?" 1) (("2" (inst 1 "j!1") (("1" (lemma "elemM2_prop") (("1" (inst -1 "M" "cr" "pr" "cr") (("1" (expand "rowV") (("1" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((elemM2_fixes_pivots formula-decl nil gauss_jordan nil) (elemM2_prop formula-decl nil elementary_matrices nil) (rowV const-decl "Vector[M`cols]" matrices nil) (rref? const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (zero_or_nonzero formula-decl nil elementary_matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (pivot_prop formula-decl nil gauss_jordan nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (square? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (find_pivot_row const-decl "{i: subrange(r, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(r, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil) (/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") (ge2 const-decl "[M2:
   {M2: Matrix |
               M2`rows = M`rows & M2`cols = M`cols & rref?(M2, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M2, i))
             & (FORALL (i: subrange(cr, M2`rows - 1)):
                  nonzero_row?(M2, i) => pivot(M2, cr) <= pivot(M2, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M2}]" gauss_jordan nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (ge3_rref_pivot_TCC1 0 (ge3_rref_pivot_TCC1-1 nil 3525198114 ("" (skeep :preds? t) (("" (assert) nil nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge3_rref_pivot_TCC2 0 (ge3_rref_pivot_TCC2-1 nil 3525198114 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (assert) nil nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge3_rref_pivot_TCC3 0 (ge3_rref_pivot_TCC3-1 nil 3525198114 ("" (skeep :preds? t) (("" (inst -13 "cr") nil nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil)) nil)) (ge3_rref_pivot_TCC4 0 (ge3_rref_pivot_TCC4-1 nil 3525198114 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (ge3_rref_pivot 0 (ge3_rref_pivot-2 "" 3525712585 ("" (skeep :preds? t) (("" (assert) (("" (expand "ge3") (("" (case-replace "M`matrix(cr, pivot(M, cr)) = 1") (("1" (split 1) (("1" (propax) nil nil) ("2" (skeep :preds? t) (("2" (inst -8 "i") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (name-replace "dd" "(1 / M`matrix(cr, pivot(M, cr)))") (("1" (use "elemM3_fixes_pivots") (("1" (assert) (("1" (rewrite "dd" :dir rl) (("1" (inst-cp -1 "cr") (("1" (split 2) (("1" (skeep :preds? t) (("1" (inst -6 "i") (("1" (expand "nonzero_row?" (-6 1)) (("1" (skosimp :preds? t) (("1" (lemma "elemM3_prop") (("1" (expand "rowV") (("1" (inst -1 "M" "cr" "dd" "i") (("1" (lift-if) (("1" (split -1) (("1" (flatten) (("1" (expand "*" -2 2) (("1" (decompose-equality -2) (("1" (inst -1 "j!1") (("1" (inst 1 "j!1") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (rewrite "dd" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (1)) (("7" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (decompose-equality -1) (("1" (inst -1 "j!1") (("1" (inst 2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (grind) nil nil)) nil) ("5" (hide-all-but (-1 1)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (1)) (("6" (grind) nil nil)) nil) ("7" (hide-all-but (1)) (("7" (grind) nil nil)) nil) ("8" (hide-all-but (1)) (("8" (grind) nil nil)) nil) ("9" (hide-all-but (1)) (("9" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (split -5) (("1" (replace -1 :hide? t) (("1" (inst -4 "i") (("1" (assert) (("1" (replace -4 :hide? t) (("1" (inst -7 "i") (("1" (assert) (("1" (lemma "elemM3_prop") (("1" (inst -1 "M" "cr" "dd" "i") (("1" (expand "rowV") (("1" (decompose-equality -1) (("1" (expand "nonzero_row?" (-4 3)) (("1" (skosimp :preds? t) (("1" (inst 4 "j!1") (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (lemma "elemM3_prop") (("2" (inst -1 "M" "cr" "dd" "cr") (("2" (expand "rowV") (("2" (expand "*" -1 2) (("2" (decompose-equality -1) (("1" (inst -8 "cr") (("1" (expand "nonzero_row?" (-8 1)) (("1" (skosimp :preds? t) (("1" (inst 1 "j!1") (("1" (inst -2 "j!1") (("1" (assert) (("1" (replace -2 :hide? t) (("1" (expand "dd" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "pivot_prop") (("2" (inst -1 "M" "cr") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (inst -3 "cr") nil nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (M skolem-const-decl "Matrix" gauss_jordan nil) (cr skolem-const-decl "{cr: below(M`rows) |
         rref?(M, cr) &
          (FORALL (i: upto(cr)): nonzero_row?(M, i)) &
           (FORALL (i: subrange(cr, M`rows - 1)):
              nonzero_row?(M, i) => pivot(M, cr) <= pivot(M, i))}" gauss_jordan nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (square? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (i skolem-const-decl "subrange(cr, ge3(M, cr)`1`rows - 1)" gauss_jordan nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nzreal nonempty-type-eq-decl nil reals nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (j!1 skolem-const-decl "below((elemM3(M`rows)(cr)(dd) * M)`cols)" gauss_jordan nil) (i skolem-const-decl "subrange(cr, ge3(M, cr)`1`rows - 1)" gauss_jordan nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (elemM3_prop formula-decl nil elementary_matrices nil) (* const-decl "Vector" vectors "vectors/") (j!1 skolem-const-decl "below(M`cols)" gauss_jordan nil) (sigma def-decl "real" sigma "reals/") (real_times_real_is_real application-judgement "real" reals nil) (Index type-eq-decl nil vectors "vectors/") (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rowV const-decl "Vector[M`cols]" matrices nil) (NOT const-decl "[bool -> bool]" booleans nil) (dd skolem-const-decl "nzreal" gauss_jordan nil) (elemM3_fixes_pivots formula-decl nil gauss_jordan nil) (pivot_prop formula-decl nil gauss_jordan nil) (ge3 const-decl "[M3:
   {M3: Matrix |
               M3`rows = M`rows & M3`cols = M`cols & rref?(M3, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M3, i))
             & M3`matrix(cr, pivot(M3, cr)) = 1
             & (FORALL (i: subrange(cr, M3`rows - 1)):
                  nonzero_row?(M3, i) => pivot(M3, cr) <= pivot(M3, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M3}]" gauss_jordan nil)) shostak) (ge3_rref_pivot-1 nil 3525204231 ("" (skeep :preds? t) (("" (assert) (("" (expand "ge3") (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (assert) (("1" (replace -4) (("1" (skeep :preds? t) (("1" (inst -8 "i") (("1" (assert) nil nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "elemM3_rref_pivot") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replace -3) (("2" (split 2) (("1" (hide-all-but (-5 1)) (("1" (grind) nil nil)) nil) ("2" (use "elemM3_fixes_pivots") (("2" (assert) (("2" (inst -1 "cr") (("2" (split -1) (("1" (replace -1 :hide? t) (("1" (use "elemM3_prop") (("1" (expand "rowV") (("1" (expand "*" -1 2) (("1" (decompose-equality -1) (("1" (inst -1 "pivot(M, cr)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "cr") nil nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (inst -7 "i") (("1" (assert) nil nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") (real_times_real_is_real application-judgement "real" reals nil) (elemM3_prop formula-decl nil elementary_matrices nil) (* const-decl "Vector" vectors "vectors/") (NOT const-decl "[bool -> bool]" booleans nil) (Index type-eq-decl nil vectors "vectors/") (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rowV const-decl "Vector[M`cols]" matrices nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (nzreal nonempty-type-eq-decl nil reals nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (square? const-decl "bool" matrices nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (/= const-decl "boolean" notequal nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (ge3_ge2_rref_pivot_TCC1 0 (ge3_ge2_rref_pivot_TCC1-1 nil 3525157815 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (replace -19 :hide? t) (("" (replace -19 :hide? t) (("" (replace -19 :hide? t) (("" (use "ge2_rref_pivot") (("" (assert) (("" (flatten) (("" (replace -6) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (square? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (ge2_rref_pivot formula-decl nil gauss_jordan nil)) nil)) (ge3_ge2_rref_pivot_TCC2 0 (ge3_ge2_rref_pivot_TCC2-1 nil 3525157815 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil)) nil)) (ge3_ge2_rref_pivot_TCC3 0 (ge3_ge2_rref_pivot_TCC3-1 nil 3525157815 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil)) nil)) (ge3_ge2_rref_pivot_TCC4 0 (ge3_ge2_rref_pivot_TCC4-1 nil 3525157815 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (inst -30 "cr") nil nil)) nil)) nil)) nil)) nil) ((nonzero_row? const-decl "bool" elementary_matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (ge3_ge2_rref_pivot_TCC5 0 (ge3_ge2_rref_pivot_TCC5-1 nil 3525157815 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (ge3_ge2_rref_pivot 0 (ge3_ge2_rref_pivot-1 nil 3525157815 ("" (skeep :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (use "ge3_rref_pivot") (("1" (assert) nil nil) ("2" (hide 3) (("2" (assert) (("2" (use "ge2_rref_pivot") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (hide -6 -7) (("3" (expand "reduced_row_echelon_form?") (("3" (expand "rref?") (("3" (flatten) (("3" (expand "row_echelon_form_below?") (("3" (flatten) (("3" (expand "row_echelon_form?") (("3" (assert) (("3" (split 2) (("1" (skeep :preds? t) (("1" (inst -8 "i" "j") (("1" (assert) nil nil) ("2" (inst 3 "i") (("2" (assert) nil nil)) nil) ("3" (inst 3 "i") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep 2 :preds? t) (("2" (inst -7 "i") (("1" (lemma "zero_or_nonzero") (("1" (inst -1 "M" "i") (("1" (assert) (("1" (inst -8 "j") nil nil)) nil)) nil)) nil) ("2" (lemma "zero_or_nonzero") (("2" (inst -1 "M" "i") (("2" (assert) (("2" (inst 4 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (inst 2 "r") (("3" (inst -8 "r") (("1" (expand "rref_row_inv") (("1" (split -8) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (skeep :preds? t) (("2" (inst -10 "j") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cr skolem-const-decl "{cr: below(OM`rows) |
         rref?(M, cr) & (FORALL (i: below(cr)): nonzero_row?(M, i))}" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (M skolem-const-decl "(LAMBDA (N): OM`rows = N`rows AND OM`cols = N`cols)" gauss_jordan nil) (= const-decl "[T, T -> boolean]" equalities nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (square? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (ge2 const-decl "[M2:
   {M2: Matrix |
               M2`rows = M`rows & M2`cols = M`cols & rref?(M2, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M2, i))
             & (FORALL (i: subrange(cr, M2`rows - 1)):
                  nonzero_row?(M2, i) => pivot(M2, cr) <= pivot(M2, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M2}]" gauss_jordan nil) (find_pivot_row const-decl "{i: subrange(r, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(r, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (ge3_rref_pivot formula-decl nil gauss_jordan nil)) shostak)) (ge_rec_rref_TCC1 0 (ge_rec_rref_TCC1-1 nil 3525116310 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (replace -27 :hide? t) (("" (replace -27 :hide? t) (("" (replace -27 :hide? t) (("" (replace -27 :hide? t) (("" (replace -27 :hide? t) (("" (use "ge3_ge2_rref_pivot") (("" (assert) (("" (flatten) (("" (replace -6) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ge3_ge2_rref_pivot formula-decl nil gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (square? const-decl "bool" matrices nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge_rec_rref_TCC2 0 (ge_rec_rref_TCC2-1 nil 3525151607 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil) (ge1 const-decl "[M1:
   {M1: Matrix |
               M1`rows = M`rows & M1`cols = M`cols & rref?(M1, cr + 1)
             & (FORALL (i: upto(cr)): nonzero_row?(M1, i))
             & M1`matrix(cr, pivot(M1, cr)) = 1},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M1}]" gauss_jordan nil)) nil)) (ge_rec_rref 0 (ge_rec_rref-1 nil 3525725709 ("" (skeep :preds? t) (("" (assert) (("" (hide -6 -7) (("" (name-replace "M1" "ge1(ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1, cr)`1") (("" (typepred "M1") (("" (flatten) (("" (assert) (("" (expand "reduced_row_echelon_form?" -) (("" (flatten) (("" (expand "rref?" +) (("" (expand "row_echelon_form?") (("" (flatten) (("" (split 2) (("1" (expand "row_echelon_form_below?") (("1" (replace -11) (("1" (skeep :preds? t) (("1" (skeep :preds? t) (("1" (inst -15 "i") (("1" (assert) (("1" (lemma "nonzero_isnt_zero") (("1" (inst -1 "M1" "i") (("1" (assert) (("1" (inst -15 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (expand "rref_row_inv") (("2" (flatten) (("2" (inst -16 "i") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replace -17) (("2" (skeep :preds? t) (("2" (inst -18 "j") (("2" (split -18) (("1" (expand "zero_row?" -1) (("1" (inst -1 "k") nil nil)) nil) ("2" (assert) (("2" (inst -1 "i") (("1" (lemma "pivot_prop") (("1" (inst -1 "M1" "j") (("1" (flatten) (("1" (inst -1 "k") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "pivot_prop") (("2" (inst -1 "M1" "i") (("2" (flatten) (("2" (inst -1 "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (square? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (ge1 const-decl "[M1:
   {M1: Matrix |
               M1`rows = M`rows & M1`cols = M`cols & rref?(M1, cr + 1)
             & (FORALL (i: upto(cr)): nonzero_row?(M1, i))
             & M1`matrix(cr, pivot(M1, cr)) = 1},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M1}]" gauss_jordan nil) (ge3 const-decl "[M3:
   {M3: Matrix |
               M3`rows = M`rows & M3`cols = M`cols & rref?(M3, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M3, i))
             & M3`matrix(cr, pivot(M3, cr)) = 1
             & (FORALL (i: subrange(cr, M3`rows - 1)):
                  nonzero_row?(M3, i) => pivot(M3, cr) <= pivot(M3, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M3}]" gauss_jordan nil) (ge2 const-decl "[M2:
   {M2: Matrix |
               M2`rows = M`rows & M2`cols = M`cols & rref?(M2, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M2, i))
             & (FORALL (i: subrange(cr, M2`rows - 1)):
                  nonzero_row?(M2, i) => pivot(M2, cr) <= pivot(M2, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M2}]" gauss_jordan nil) (find_pivot_row const-decl "{i: subrange(r, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(r, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil) (zero_row? const-decl "bool" elementary_matrices nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (M skolem-const-decl "(LAMBDA (N): OM`rows = N`rows AND OM`cols = N`cols)" gauss_jordan nil) (cr skolem-const-decl "{cr: below(OM`rows) |
         rref?(M, cr) & (FORALL (i: below(cr)): nonzero_row?(M, i))}" gauss_jordan nil) (M1 skolem-const-decl "{M1: Matrix |
            M1`rows = ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1`rows
          & M1`cols = ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1`cols
          & rref?(M1, 1 + cr) & FORALL (i: upto(cr)): nonzero_row?(M1, i)
          & M1`matrix(cr, pivot(M1, cr)) = 1}" gauss_jordan nil) (i skolem-const-decl "below(M1`rows)" gauss_jordan nil) (j skolem-const-decl "subrange(i, M1`rows - 1)" gauss_jordan nil) (k skolem-const-decl "below(pivot(M1, i))" gauss_jordan nil) (pivot_prop formula-decl nil gauss_jordan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (nonzero_isnt_zero formula-decl nil elementary_matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)) (ge1_ge3_ge2_prod 0 (ge1_ge3_ge2_prod-1 nil 3525764861 ("" (skeep :preds? t) (("" (assert) (("" (split 2) (("1" (expand "ge1") (("1" (typepred "ge1_rec(ge3
                                              (ge2(M, cr, find_pivot_row(M, cr))`1,
                                               cr)`1,
                                              ge3
                                              (ge2(M, cr, find_pivot_row(M, cr))`1,
                                               cr)`1,
                                              null,
                                              cr,
                                              0)`2") (("1" (rewrite "every_append") (("1" (rewrite "every_append") (("1" (rewrite "every_append") (("1" (hide -2) (("1" (case-replace "ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1`rows = OM`rows") (("1" (replace -2) (("1" (hide -2) (("1" (typepred "ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`2") (("1" (case-replace "ge2(M, cr, find_pivot_row(M, cr))`1`rows = OM`rows") (("1" (replace -2 :hide? t) (("1" (typepred "ge2(M, cr, find_pivot_row(M, cr))`2") (("1" (replace -6) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6) (("2" (rewrite "elem_prod_append" :dir rl) (("1" (rewrite "elem_prod_append" :dir rl) (("1" (rewrite "elem_prod_append" :dir rl) (("1" (typepred "ge2(M, cr, find_pivot_row(M, cr))`2") (("1" (replace -8 :hide? t) (("1" (replace -2 :hide? t) (("1" (typepred "ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`2") (("1" (replace -2 :hide? t) (("1" (typepred "ge1(ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1,
                            cr)`2") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "ge1(ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1, cr)`2") (("2" (typepred "elem_product_left(elem_product_left(OM, emlist),
                                          ge2
                                          (M,
                                           cr,
                                           find_pivot_row(M, cr))`2)") (("1" (replace -1 :hide? t) (("1" (typepred "ge3(ge2(M, cr, find_pivot_row(M, cr))`1,
                              cr)`1") (("1" (replace -1 :hide? t) (("1" (hide -1 -2 -3 -4 -5 -6) (("1" (typepred "elem_product_left(OM, emlist)") (("1" (replace -1 :hide? t) (("1" (typepred "ge2(M, cr, find_pivot_row(M, cr))`1") (("1" (replace -1 :hide? t) (("1" (replace -8) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "elem_product_left(OM, emlist)") (("2" (replace -1 :hide? t) (("2" (typepred "ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1") (("2" (replace -1 :hide? t) (("2" (hide -1 -2 -3 -4 -5 -6) (("2" (typepred "ge2(M, cr, find_pivot_row(M, cr))`1") (("2" (replace -1 :hide? t) (("2" (replace -7) (("2" (typepred "ge2(M, cr, find_pivot_row(M, cr))`2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`2") (("3" (hide -2) (("3" (typepred "elem_product_left(elem_product_left(OM, emlist),
                                          ge2
                                          (M,
                                           cr,
                                           find_pivot_row(M, cr))`2)") (("1" (replace -1 :hide? t) (("1" (typepred "elem_product_left(OM, emlist)") (("1" (replace -1 :hide? t) (("1" (replace -4) (("1" (typepred "ge2(M, cr, find_pivot_row(M, cr))`1") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (typepred "ge2(M, cr, find_pivot_row(M, cr))`2") (("2" (typepred "elem_product_left(OM, emlist)") (("2" (replace -1 :hide? t) (("2" (replace -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "every_append") (("2" (typepred "ge1(ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1, cr)`2") (("1" (hide -2) (("1" (typepred "ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`2") (("1" (hide -2) (("1" (typepred "ge2(M, cr, find_pivot_row(M, cr))`1") (("1" (replace -1 :hide? t) (("1" (hide -1 -2 -3 -4) (("1" (typepred "elem_product_left(OM, emlist)") (("1" (replace -1 :hide? t) (("1" (replace -4) (("1" (replace -2) (("1" (typepred "ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1") (("1" (replace -1 :hide? t) (("1" (hide -2 -3 -4 -5 -6) (("1" (typepred "ge2(M, cr, find_pivot_row(M, cr))`1") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "ge2(M, cr, find_pivot_row(M, cr))`2") (("3" (typepred "elem_product_left(OM, emlist)") (("3" (replace -1 :hide? t) (("3" (replace -4) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "every_append") (("2" (rewrite "every_append") (("2" (replace -1) (("2" (typepred "ge1(ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1, cr)`2") (("1" (hide -2) (("1" (typepred "ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1") (("1" (replace -1 :hide? t) (("1" (hide -1 -2 -3 -4 -5) (("1" (typepred "ge2(M, cr, find_pivot_row(M, cr))`1") (("1" (replace -1 :hide? t) (("1" (hide -1 -2 -3 -4) (("1" (replace -1) (("1" (typepred "ge2(M, cr, find_pivot_row(M, cr))`2") (("1" (replace -1 :hide? t) (("1" (typepred "ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`2") (("1" (typepred "ge2(M, cr, find_pivot_row(M, cr))`1") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elem_prod_append formula-decl nil elementary_matrices nil) (ge1 const-decl "[M1:
   {M1: Matrix |
               M1`rows = M`rows & M1`cols = M`cols & rref?(M1, cr + 1)
             & (FORALL (i: upto(cr)): nonzero_row?(M1, i))
             & M1`matrix(cr, pivot(M1, cr)) = 1},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M1}]" gauss_jordan nil) (append def-decl "list[T]" list_props nil) (every_append formula-decl nil list_props nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") (* const-decl "Matrix" matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (square? const-decl "bool" matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (ge3 const-decl "[M3:
   {M3: Matrix |
               M3`rows = M`rows & M3`cols = M`cols & rref?(M3, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M3, i))
             & M3`matrix(cr, pivot(M3, cr)) = 1
             & (FORALL (i: subrange(cr, M3`rows - 1)):
                  nonzero_row?(M3, i) => pivot(M3, cr) <= pivot(M3, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M3}]" gauss_jordan nil) (ge2 const-decl "[M2:
   {M2: Matrix |
               M2`rows = M`rows & M2`cols = M`cols & rref?(M2, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M2, i))
             & (FORALL (i: subrange(cr, M2`rows - 1)):
                  nonzero_row?(M2, i) => pivot(M2, cr) <= pivot(M2, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M2}]" gauss_jordan nil) (find_pivot_row const-decl "{i: subrange(r, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(r, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (ge1_rec def-decl "[M1:
   {M1: Matrix |
               M1`rows = OM`rows & M1`cols = OM`cols & rref?(M1, cr + 1)
             & (FORALL (i: upto(cr)): nonzero_row?(M1, i))
             & M1`matrix(cr, pivot(M1, cr)) = 1},
 {el: list[ElemMat(OM`rows)] | elem_product_left(OM, el) = M1}]" gauss_jordan nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil)) shostak)) (ge1_ge3_ge2_iter_TCC1 0 (ge1_ge3_ge2_iter_TCC1-1 nil 3525231823 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (ge1_ge3_ge2_iter_TCC2 0 (ge1_ge3_ge2_iter_TCC2-1 nil 3525231823 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 3 :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (ge1_ge3_ge2_iter 0 (ge1_ge3_ge2_iter-2 "" 3526156599 ("" (skeep :preds? t) (("" (assert) (("" (use "ge3_ge2_rref_pivot") (("" (assert) (("" (flatten) (("" (hide -3 -4) (("" (typepred "ge1(ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1, cr)`1") (("" (hide -11 -12) (("" (expand "reduced_row_echelon_form?" 2) (("" (expand "rref?" -3) (("" (flatten) (("" (split 2) (("1" (expand "row_echelon_form?") (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -7 "i" "j") (("1" (assert) nil nil) ("2" (split 4) (("1" (assert) nil nil) ("2" (skosimp 1 :preds? t) (("2" (inst -10 "i!1") nil nil)) nil)) nil) ("3" (assert) (("3" (skosimp 4 :preds? t) (("3" (inst -10 "i!1") nil nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (assert) (("2" (split 4) (("1" (inst -5 "i") (("1" (lemma "zero_or_nonzero") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (skosimp 1 :preds? t) (("2" (inst -8 "i!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (split 1) (("1" (assert) (("1" (split 3) (("1" (inst -6 "r") (("1" (expand "rref_row_inv" -6) (("1" (flatten) (("1" (skosimp 3 :preds? t) (("1" (inst -8 "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (skosimp 1 :preds? t) (("2" (inst -8 "i!1") nil nil)) nil)) nil)) nil) ("2" (skosimp 1 :preds? t) (("2" (split 4) (("1" (inst -7 "r") (("1" (expand "rref_row_inv" -7) (("1" (assert) (("1" (split -7) (("1" (flatten) (("1" (inst -2 "j!1") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (inst -9 "j!2") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (skosimp 1 :preds? t) (("2" (inst -9 "i!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (M skolem-const-decl "(LAMBDA (N): OM`rows = N`rows AND OM`cols = N`cols)" gauss_jordan nil) (cr skolem-const-decl "{cr: below(OM`rows) |
         rref?(M, cr) & (FORALL (i: below(cr)): nonzero_row?(M, i))}" gauss_jordan nil) (i skolem-const-decl "below(ge1(ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1, cr)`1`rows)" gauss_jordan nil) (j skolem-const-decl "below(ge1(ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1, cr)`1`rows)" gauss_jordan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (i skolem-const-decl "below(ge1(ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1, cr)`1`rows)" gauss_jordan nil) (zero_or_nonzero formula-decl nil elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (j!1 skolem-const-decl "below(r)" gauss_jordan nil) (r skolem-const-decl "below(ge1(ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1, cr)`1`rows)" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (ge1 const-decl "[M1:
   {M1: Matrix |
               M1`rows = M`rows & M1`cols = M`cols & rref?(M1, cr + 1)
             & (FORALL (i: upto(cr)): nonzero_row?(M1, i))
             & M1`matrix(cr, pivot(M1, cr)) = 1},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M1}]" gauss_jordan nil) (ge3 const-decl "[M3:
   {M3: Matrix |
               M3`rows = M`rows & M3`cols = M`cols & rref?(M3, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M3, i))
             & M3`matrix(cr, pivot(M3, cr)) = 1
             & (FORALL (i: subrange(cr, M3`rows - 1)):
                  nonzero_row?(M3, i) => pivot(M3, cr) <= pivot(M3, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M3}]" gauss_jordan nil) (ge2 const-decl "[M2:
   {M2: Matrix |
               M2`rows = M`rows & M2`cols = M`cols & rref?(M2, cr)
             & (FORALL (i: upto(cr)): nonzero_row?(M2, i))
             & (FORALL (i: subrange(cr, M2`rows - 1)):
                  nonzero_row?(M2, i) => pivot(M2, cr) <= pivot(M2, i))},
 {el: list[ElemMat(M`rows)] | elem_product_left(M, el) = M2}]" gauss_jordan nil) (find_pivot_row const-decl "{i: subrange(r, M`rows - 1) |
         nonzero_row?(M, i) &
          (FORALL (j: subrange(r, M`rows - 1)):
             nonzero_row?(M, j) => pivot(M, i) <= pivot(M, j))}" gauss_jordan nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (square? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (ge3_ge2_rref_pivot formula-decl nil gauss_jordan nil)) shostak) (ge1_ge3_ge2_iter-1 nil 3525574546 ("" (skeep :preds? t) (("" (assert) (("" (use "ge3_ge2_rref_pivot") (("" (assert) (("" (flatten) (("" (hide -3 -4) (("" (typepred "ge1(ge3(ge2(M, cr, find_pivot_row(M, cr))`1, cr)`1, cr)`1") (("" (hide -9 -10) (("" (expand "reduced_row_echelon_form?" 2) (("" (expand "rref?" -2) (("" (flatten) (("" (split 2) (("1" (expand "row_echelon_form?") (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (split 1) (("1" (skeep :preds? t) (("1" (inst -6 "i" "j") (("1" (assert) nil nil) ("2" (split 4) (("1" (expand "same_dim?" -5) (("1" (flatten) (("1" (replace -5) (("1" (hide-all-but (-2 1 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp 1 :preds? t) (("2" (inst -10 "i!1") (("2" (assert) (("2" (name-replace "pr" "find_pivot_row(M, cr)" :hide? t) (("2" (name-replace "g32" "ge3(ge2(M, cr, pr)`1, cr)`1") (("2" (typepred "ge1(g32, cr)`1") (("2" (expand "rref?" -2) (("2" (flatten) (("2" (inst -3 "i!1") (("2" (expand "rref_row_inv" -3) (("2" (split -3) (("1" (flatten) (("1" (expand "nonzero_row?" 1) (("1" (inst 1 "pivot(ge1(g32, cr)`1, i!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skosimp 1 :preds? t) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (gaussian_elimination_rec_TCC1 0 (gaussian_elimination_rec_TCC1-1 nil 3499441985 ("" (subtype-tcc) nil nil) nil nil)) (gaussian_elimination_rec_TCC2 0 (gaussian_elimination_rec_TCC2-1 nil 3499441985 ("" (skeep :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (postpone) nil nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (gaussian_elimination_rec_TCC3 0 (gaussian_elimination_rec_TCC3-1 nil 3499441985 ("" (skeep :preds? t) (("" (expand "reduced_row_echelon_form?") (("" (flatten) (("" (expand "row_echelon_form?") (("" (expand "rref?") (("" (expand "row_echelon_form_below?") (("" (flatten) (("" (assert) (("" (split 1) (("1" (propax) nil nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (inst -14 "i") (("2" (lemma "nonzero_isnt_zero") (("2" (inst -1 "M" "i") (("2" (assert) (("2" (inst -14 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (expand "rref_row_inv" 1) (("3" (flatten) (("3" (inst -15 "i") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (replace -16) (("3" (skeep :preds? t) (("3" (lemma "pivot_prop") (("3" (case-replace "j = i") (("1" (inst -2 "M" "i") (("1" (flatten) (("1" (inst -2 "k") nil nil)) nil)) nil) ("2" (inst -18 "j") (("2" (assert) (("2" (split -18) (("1" (assert) (("1" (expand "zero_row?" -1) (("1" (inst -1 "k") nil nil)) nil)) nil) ("2" (inst -1 "i") (("2" (inst -2 "M" "j") (("2" (flatten) (("2" (inst -2 "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((reduced_row_echelon_form? const-decl "bool" gauss_jordan nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (/= const-decl "boolean" notequal nil) (pivot const-decl "{j: below(M`cols) | j = min({j: below(M`cols) | M`matrix(i, j) /= 0})}" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (OM skolem-const-decl "Matrix" gauss_jordan nil) (M skolem-const-decl "(LAMBDA (N): OM`rows = N`rows AND OM`cols = N`cols)" gauss_jordan nil) (i skolem-const-decl "below(M`rows)" gauss_jordan nil) (k skolem-const-decl "below(pivot(M, i))" gauss_jordan nil) (j skolem-const-decl "subrange(i, M`rows - 1)" gauss_jordan nil) (zero_row? const-decl "bool" elementary_matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pivot_prop formula-decl nil gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonzero_isnt_zero formula-decl nil elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (gaussian_elimination_rec_TCC4 0 (gaussian_elimination_rec_TCC4-1 nil 3499441985 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (use "ge_rec_rref") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ge_rec_rref formula-decl nil gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (square? const-decl "bool" matrices nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (gaussian_elimination_rec_TCC5 0 (gaussian_elimination_rec_TCC5-3 "" 3519345553 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (use "ge1_ge3_ge2_prod") (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (square? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (ge1_ge3_ge2_prod formula-decl nil gauss_jordan nil)) shostak) (gaussian_elimination_rec_TCC5-2 "" 3515121469 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (hide -7 1) (("" (use "every_nth[ElemMat(M`rows)]") (("" (assert) (("" (hide 2) (("" (skeep :preds? t) (("" (expand "ge3") (("" (lift-if) (("" (assert) (("" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (typepred "emlist") (("2" (case-replace "i = 0" :hide? t) (("1" (expand "nth") (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1 3)) (("2" (use "every_nth[Matrix]") (("2" (replace -2 :hide? t) (("2" (assert) (("2" (expand "nth" 2) (("2" (case-replace "(elemM3(M`rows)(r)(1 / M`matrix(r, c)) * M)`rows = M`rows") (("1" (inst -2 "i-1") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzreal nonempty-type-eq-decl nil reals nil) (elemMat3? const-decl "bool" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma "reals/") (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (length def-decl "nat" list_props nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (ElemMat type-eq-decl nil elementary_matrices nil) (list type-decl nil list_adt nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (every_nth formula-decl nil list_props nil)) shostak) (gaussian_elimination_rec_TCC5-1 nil 3499441985 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (case-replace "ge3((M, emlist), r, c)`1`rows = M`rows" :hide? t) (("" (hide-all-but (-4 1)) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((every_nth formula-decl nil list_props nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (nzreal nonempty-type-eq-decl nil reals nil) (nth def-decl "T" list_props nil) (sigma def-decl "real" sigma "reals/") (real_times_real_is_real application-judgement "real" reals nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil)) (gaussian_elimination_rec_TCC6 0 (gaussian_elimination_rec_TCC6-2 "" 3520404294 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak) (gaussian_elimination_rec_TCC6-1 nil 3499441985 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (hide 1) (("" (grind) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (gaussian_elimination_rec_TCC7 0 (gaussian_elimination_rec_TCC7-3 "" 3521950447 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (assert) (("" (use "ge1_ge3_ge2_iter") (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ge1_ge3_ge2_iter formula-decl nil gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (rref? const-decl "bool" gauss_jordan nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (square? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak) (gaussian_elimination_rec_TCC7-2 "" 3520404389 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) (("" (expand "find_pivot") (("" (typepred "choose! (q: [subrange(cr, M`rows - 1), subrange(cc, M`cols - 1)]):
         M`matrix(q) /= 0") (("1" (name-replace "ch" "choose! (q: [subrange(cr, M`rows - 1), subrange(cc, M`cols - 1)]):
         M`matrix(q) /= 0") (("1" (case "ch = (pr, pc)") (("1" (assert) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (apply-extensionality) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "/=" -1) (("2" (expand "reduced_row_echelon_form?") (("2" (expand "rref?" +) (("2" (split 1) (("1" (expand "row_echelon_form_below?") (("1" (split 1) (("1" (skosimp :preds? t) (("1" (expand "rref?") (("1" (flatten) (("1" (expand "row_echelon_form_below?") (("1" (flatten) (("1" (inst -14 "i!1" "j!1") (("1" (assert) nil nil) ("2" (expand "nonzero_row?") (("2" (skosimp :preds? t) (("2" (inst -5 "(i!1, j!2)") (("1" (expand "bottom_left_zero?") (("1" (replace -11 :actuals? t :hide? t) (("1" (replace -11 :actuals? t :hide? t) (("1" (hide -14 -15 -16 -17) (("1" (inst -13 "i!1" "j!2") (("1" (assert) nil nil) ("2" (inst -11 "i!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -13 "i!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (expand "bottom_left_zero?") (("3" (expand "nonzero_row?") (("3" (skosimp :preds? t) (("3" (inst -16 "i!1" "j!2") (("3" (inst -5 "(i!1, j!2)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp :preds? t) (("2" (assert) (("2" (expand "rref?") (("2" (flatten) (("2" (expand "row_echelon_form_below?") (("2" (flatten) (("2" (inst -12 "i!1") (("1" (assert) nil nil) ("2" (expand "bottom_left_zero?") (("2" (expand "zero_row?") (("2" (skosimp :preds? t) (("2" (inst -14 "i!1" "j!1") (("1" (inst -3 "(i!1, j!1)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (expand "rref?") (("2" (flatten) (("2" (expand "row_echelon_form_below?") (("2" (flatten) (("2" (inst -14 "ri") (("1" (assert) (("1" (split -14) (("1" (inst -1 "ci") nil nil) ("2" (propax) nil nil)) nil)) nil) ("2" (inst -3 "(ri, ci)") (("1" (expand "bottom_left_zero?") (("1" (inst -13 "ri" "ci") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (typepred "q`1") (("3" (typepred "q`2") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak) (gaussian_elimination_rec_TCC7-1 nil 3499441985 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (hide 1) (("" (grind) nil nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (gaussian_elimination_rec_TCC8 0 (gaussian_elimination_rec_TCC8-4 "" 3520404443 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (use "ge1_ge3_ge2_prod") (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (square? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (ge1_ge3_ge2_prod formula-decl nil gauss_jordan nil)) shostak) (gaussian_elimination_rec_TCC8-3 "" 3519346739 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (expand "same_dim?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak) (gaussian_elimination_rec_TCC8-2 "" 3515477714 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (use "every_nth[ElemMat(ge3((M, emlist), r, c)`1`rows)]") (("" (assert) (("" (hide 3) (("" (use "every_nth[Matrix]") (("" (assert) (("" (hide -8) (("" (case "ge2(ge3((M, emlist), r, c), cr, r)`1`rows = M`rows") (("1" (replace -1 :actuals? t) (("1" (case "length(ge2(ge3((M, emlist), r, c), cr, r)`2) = 0") (("1" (skeep :preds? t) (("1" (assert) nil nil)) nil) ("2" (skeep 2 :preds? t) (("2" (expand "ge2" 2) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (expand "ge3" 1) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (inst -5 "i") (("1" (flatten) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil) ("2" (expand "ge2" -3) (("2" (expand "ge3" -3) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "nth" 2) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (flatten) (("2" (inst -4 "i-1") (("1" (flatten) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "ge2" -2) (("2" (expand "ge3" -2) (("2" (expand "length" -2) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "nth" 2) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (flatten) (("2" (expand "ge3" 2) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (inst -4 "i-1") (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (assert) (("2" (expand "ge2" -2) (("2" (expand "ge3" -2) (("2" (expand "length" -2) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "nth" 2) (("2" (lift-if) (("2" (split 2) (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (flatten) (("2" (inst -3 "i - 2") (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (assert) (("2" (expand "ge2" -1) (("2" (expand "length" -1) (("2" (expand "ge3" -1) (("2" (expand "length" -1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil) ("5" (hide 2) (("5" (use "every_nth[ElemMat(M`rows)]") (("5" (assert) (("5" (hide 2) (("5" (skeep) (("5" (case-replace "ge3((M, emlist), r, c)`1`rows = M`rows") (("1" (expand "ge3" 1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzreal nonempty-type-eq-decl nil reals nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nth def-decl "T" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (elemMat1? const-decl "bool" elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (length def-decl "nat" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (ElemMat type-eq-decl nil elementary_matrices nil) (list type-decl nil list_adt nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (every_nth formula-decl nil list_props nil)) shostak) (gaussian_elimination_rec_TCC8-1 nil 3499441985 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (square? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil)) (gaussian_elimination_rec_TCC9 0 (gaussian_elimination_rec_TCC9-2 "" 3520404466 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (expand "same_dim?") (("" (skeep 2 :preds? t) (("" (skeep 2 :preds? t) (("" (assert) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) shostak) (gaussian_elimination_rec_TCC9-1 nil 3499441985 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (hide-all-but (2 -4)) (("" (grind) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (gaussian_elimination_TCC1 0 (gaussian_elimination_TCC1-1 nil 3499441985 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (rref? const-decl "bool" gauss_jordan nil)) nil)) (gaussian_elimination_TCC2 0 (gaussian_elimination_TCC2-1 nil 3499441985 ("" (skeep :preds? t) (("" (expand "elem_product_left") (("" (propax) nil nil)) nil)) nil) ((elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil)) nil)) (gaussian_elimination_TCC3 0 (gaussian_elimination_TCC3-1 nil 3519751838 ("" (skeep :preds? t) (("" (name-replace "ger" "gaussian_elimination_rec(M, M, 0, null[ElemMat(M`rows)])`1") (("" (typepred "ger") (("" (expand "rref?") (("" (expand "row_echelon_form_below?") (("" (flatten) (("" (expand "reduced_row_echelon_form?") (("" (split 1) (("1" (expand "row_echelon_form?") (("1" (split 1) (("1" (propax) nil nil) ("2" (skeep :preds? t) (("2" (inst -5 "i") (("2" (lemma "zero_or_nonzero") (("2" (inst -1 "ger" "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (inst -7 "r") (("2" (expand "rref_row_inv") (("2" (split -7) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (skosimp + :preds? t) (("2" (inst -7 "r" "j!1") (("2" (assert) (("2" (lemma "zero_or_nonzero") (("2" (inst -1 "ger" "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rref? const-decl "bool" gauss_jordan nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (square? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (gaussian_elimination_rec def-decl "[Mr:
   {M1: (LAMBDA (N): OM`rows = N`rows AND OM`cols = N`cols) |
            rref?(M1, M1`rows)},
 {el: list[ElemMat(OM`rows)] | elem_product_left(OM, el) = Mr}]" gauss_jordan nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (zero_or_nonzero formula-decl nil elementary_matrices nil) (row_echelon_form? const-decl "bool" gauss_jordan nil) (rref_row_inv const-decl "bool" gauss_jordan nil) (reduced_row_echelon_form? const-decl "bool" gauss_jordan nil) (row_echelon_form_below? const-decl "bool" gauss_jordan nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil)))
