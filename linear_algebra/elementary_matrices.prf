(elementary_matrices (sigma_1_nz_TCC1 0 (sigma_1_nz_TCC1-1 nil 3555093765 ("" (subtype-tcc) nil nil) nil nil)) (sigma_1_nz_TCC2 0 (sigma_1_nz_TCC2-1 nil 3555093765 ("" (subtype-tcc) nil nil) nil nil)) (sigma_1_nz_TCC3 0 (sigma_1_nz_TCC3-1 nil 3555093765 ("" (assuming-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (integer nonempty-type-from-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (sigma_1_nz 0 (sigma_1_nz-1 nil 3555093814 ("" (skeep) (("" (lemma "sigma_middle[below(n)]") (("" (inst -1 "LAMBDA (x: below(n)): IF x = i THEN a ELSE 0 ENDIF" "n-1" "i" "0") (("" (assert) (("" (replace -1 :hide? t) (("" (assert) (("" (lemma "sigma_restrict_eq[below(n)]") (("" (inst-cp -1 "LAMBDA (x: below(n)): IF x = i THEN a ELSE 0 ENDIF" "LAMBDA
   (x: below(n)): 0" "i-1" "0") (("" (split -2) (("1" (replace -1 :hide? t) (("1" (inst -1 "LAMBDA (x: below(n)): IF x = i THEN a ELSE 0 ENDIF" "LAMBDA
     (x: below(n)): 0" "n-1" "i+1") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(n)]") (("1" (rewrite "sigma_zero[below(n)]") nil nil)) nil)) nil) ("2" (hide 2) (("2" (grind :if-match nil) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (inst 2 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sigma_middle formula-decl nil sigma "reals/") (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sigma_zero formula-decl nil sigma "reals/") (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_nat application-judgement "nat" vectors "vectors/") (restrict const-decl "[T -> real]" sigma "reals/") (i skolem-const-decl "below(n)" elementary_matrices nil) (n skolem-const-decl "posnat" elementary_matrices nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (sigma_restrict_eq formula-decl nil sigma "reals/") (T_low type-eq-decl nil sigma "reals/") (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (T_high type-eq-decl nil sigma "reals/") (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (sigma_2_sum_lt 0 (sigma_2_sum_lt-1 nil 3555098543 ("" (skeep :preds? t) (("" (hide-all-but (-4 1)) (("" (lemma "sigma_middle[below(n)]") (("" (inst-cp -1 "LAMBDA (x: below(n)):
                    IF x = i THEN a ELSIF x = j THEN b ELSE 0 ENDIF" "n-1" "i" "0") (("" (assert) (("" (replace -2 :hide? t) (("" (inst -1 "LAMBDA (x: below(n)):
                    IF x = i THEN a ELSIF x = j THEN b ELSE 0 ENDIF" "n-1" "j" "i+1") (("" (assert) (("" (replace -1 :hide? t) (("" (assert) (("" (lemma "sigma_restrict_eq[below(n)]") (("" (inst-cp -1 "LAMBDA (x: below(n)): IF x = i THEN a ELSIF x = j THEN b ELSE 0 ENDIF" "LAMBDA
       (x: below(n)): 0" "i-1" "0") (("" (split -2) (("1" (replace -1 :hide? t) (("1" (inst-cp -1 "LAMBDA (x: below(n)): IF x = i THEN a ELSIF x = j THEN b ELSE 0 ENDIF" "LAMBDA
           (x: below(n)): 0" "j-1" "i+1") (("1" (split -2) (("1" (replace -1 :hide? t) (("1" (inst -1 "LAMBDA (x: below(n)): IF x = i THEN a ELSIF x = j THEN b ELSE 0 ENDIF" "LAMBDA
               (x: below(n)): 0" "n-1" "j+1") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(n)]") (("1" (rewrite "sigma_zero[below(n)]") (("1" (rewrite "sigma_zero[below(n)]") nil nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst 2 "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma "reals/") (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_low type-eq-decl nil sigma "reals/") (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (n skolem-const-decl "posnat" elementary_matrices nil) (i skolem-const-decl "below(n)" elementary_matrices nil) (j skolem-const-decl "{j: below(n) | i < j}" elementary_matrices nil) (restrict const-decl "[T -> real]" sigma "reals/") (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (sigma_zero formula-decl nil sigma "reals/") (sigma_nat application-judgement "nat" vectors "vectors/") (sigma_restrict_eq formula-decl nil sigma "reals/") (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_middle formula-decl nil sigma "reals/") (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil)) shostak)) (sigma_2_sum 0 (sigma_2_sum-1 nil 3555098717 ("" (skeep :preds? t) (("" (hide -) (("" (case "i < j") (("1" (use "sigma_2_sum_lt") nil nil) ("2" (lemma "sigma_2_sum_lt") (("2" (inst -1 "n" "j" "i" "b" "a") (("1" (assert) (("1" (case-replace "(LAMBDA (x: below(n)):
                     IF x = j THEN b ELSIF x = i THEN a ELSE 0 ENDIF) =
       (LAMBDA (x: below(n)):
                     IF x = i THEN a ELSIF x = j THEN b ELSE 0 ENDIF)") (("1" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_plus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (n skolem-const-decl "posnat" elementary_matrices nil) (i skolem-const-decl "below(n)" elementary_matrices nil) (j skolem-const-decl "{j: below(n) | i /= j}" elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_2_sum_lt formula-decl nil elementary_matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil)) shostak)) (zero_or_nonzero 0 (zero_or_nonzero-1 nil 3522729752 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (zero_row? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil)) shostak)) (zero_isnt_nonzero 0 (zero_isnt_nonzero-1 nil 3522729758 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (zero_row? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil)) shostak)) (nonzero_isnt_zero 0 (nonzero_isnt_zero-1 nil 3522729771 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (nonzero_row? const-decl "bool" elementary_matrices nil) (zero_row? const-decl "bool" elementary_matrices nil)) shostak)) (elemM1?_TCC1 0 (elemM1?_TCC1-1 nil 3492633163 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (elemM1?_TCC2 0 (elemM1?_TCC2-1 nil 3492633163 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (elemM2?_TCC1 0 (elemM2?_TCC1-1 nil 3492633163 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil)) (elemM2?_TCC2 0 (elemM2?_TCC2-1 nil 3492633163 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil)) (elemM3?_TCC1 0 (elemM3?_TCC1-1 nil 3492633163 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil)) (elemM3?_TCC2 0 (elemM3?_TCC2-1 nil 3492633163 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil)) (elemM3?_TCC3 0 (elemM3?_TCC3-1 nil 3492633163 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil)) (elm1_judgement 0 (elm1_judgement-1 nil 3500317945 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM1? const-decl "bool" elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil)) nil)) (elm2_judgement 0 (elm2_judgement-1 nil 3500318534 ("" (judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (elemM2? const-decl "bool" elementary_matrices nil) (elemM2? const-decl "bool" elementary_matrices nil)) nil)) (elm3_judgement 0 (elm3_judgement-1 nil 3500318534 ("" (judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil)) nil)) (elm_judgement 0 (elm_judgement-1 nil 3500318534 ("" (judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemMat1? const-decl "bool" elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemM2? const-decl "bool" elementary_matrices nil) (elemM2? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemM? const-decl "bool" elementary_matrices nil)) nil)) (elemM1_TCC1 0 (elemM1_TCC1-1 nil 3492635698 ("" (skolem-typepred) (("" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) (("3" (inst 1 "i!1" "j!1") (("3" (skolem-typepred) (("3" (prop) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((square? const-decl "bool" matrices nil) (squareMat? const-decl "bool" matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM1? const-decl "bool" elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (below type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (elemM2_TCC1 0 (elemM2_TCC1-1 nil 3492635698 ("" (skolem-typepred) (("" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (expand "elemMat2?") (("3" (inst 1 "i!1" "j!1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ((square? const-decl "bool" matrices nil) (squareMat? const-decl "bool" matrices nil) (elemM2? const-decl "bool" elementary_matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemMat2? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (below type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (elemM3_TCC1 0 (elemM3_TCC1-1 nil 3492635698 ("" (skolem-typepred) (("" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (expand "elemMat3?") (("3" (inst 1 "i!1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ((square? const-decl "bool" matrices nil) (squareMat? const-decl "bool" matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemMat3? const-decl "bool" elementary_matrices nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (below type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (elemM1_invertible 0 (elemM1_invertible-2 "" 3520306768 ("" (skolem-typepred) (("" (expand "invertible?") (("" (expand "elemM1?") (("" (skolem-typepred) (("" (inst 1 "elemM1(M!1`rows)(i!1, j!1)(-(M!1`matrix(i!1, j!1)))") (("1" (prop) (("1" (grind) nil nil) ("2" (expand "inverse?") (("2" (prop) (("1" (expand "elemM1?") (("1" (expand "elemM1") (("1" (expand "*") (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (apply-extensionality :hide? t) (("1" (expand "I") (("1" (lift-if) (("1" (prop) (("1" (lemma "sigma_middle[below(M!1`cols)]") (("1" (inst? :subst ("low" "0" "high" "M!1`cols-1" "i" "x!1")) (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M!1`cols)):
                 (M!1`matrix(x!1, k_1) *
                   IF (k_1 = x!2) THEN 1
                   ELSIF ((k_1 = i!1) AND (x!2 = j!1))
                     THEN -(M!1`matrix(i!1, j!1))
                   ELSE 0
                   ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "x!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (inst -1 "LAMBDA (k_1: below(M!1`cols)):
                 (M!1`matrix(x!1, k_1) *
                   IF (k_1 = x!2) THEN 1
                   ELSIF ((k_1 = i!1) AND (x!2 = j!1))
                     THEN -(M!1`matrix(i!1, j!1))
                   ELSE 0
                   ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "M!1`cols-1" "x!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst -5 "x!1" "x!1") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp) (("2" (assert) (("2" (inst -5 "x!1" "n!1") (("1" (assert) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil) ("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (skolem-typepred) (("2" (inst -7 "x!1" "n!1") (("2" (assert) (("2" (assert) (("2" (prop) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (lift-if) (("2" (assert) nil nil)) nil) ("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil) ("3" (hide -5 2) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil) ("3" (hide -5 2) (("3" (grind) nil nil)) nil) ("4" (hide -6 2) (("4" (grind) nil nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil)) nil) ("2" (case-replace "x!1 = i!1") (("1" (inst -5 "i!1" _) (("1" (case "x!2 = j!1") (("1" (replace -1) (("1" (lemma "sigma_middle[below(M!1`cols)]") (("1" (inst? :subst ("low" "0" "high" "M!1`cols-1" "i" "min(i!1,j!1)")) (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_middle[below(M!1`cols)]") (("1" (inst? :subst ("low" "min(i!1,j!1)+1" "high" "M!1`cols-1" "i" "max(i!1, j!1)")) (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M!1`cols)):
                    (M!1`matrix(i!1, k_1) *
                      IF (k_1 = j!1) THEN 1
                      ELSIF (k_1 = i!1) THEN -(M!1`matrix(i!1, j!1))
                      ELSE 0
                      ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "min(i!1,j!1)-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst-cp -1 "LAMBDA (k_1: below(M!1`cols)):
                    (M!1`matrix(i!1, k_1) *
                      IF (k_1 = j!1) THEN 1
                      ELSIF (k_1 = i!1) THEN -(M!1`matrix(i!1, j!1))
                      ELSE 0
                      ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "max(i!1,j!1)-1" "min(i!1,j!1)+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst -1 "LAMBDA (k_1: below(M!1`cols)):
                    (M!1`matrix(i!1, k_1) *
                      IF (k_1 = j!1) THEN 1
                      ELSIF (k_1 = i!1) THEN -(M!1`matrix(i!1, j!1))
                      ELSE 0
                      ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "M!1`cols-1" "max(i!1,j!1)+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (expand "max") (("1" (assert) (("1" (inst -7 "i!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "max") (("2" (assert) (("2" (assert) (("2" (inst -6 "i!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skolem-typepred) (("2" (expand "max") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (flatten) (("2" (inst 2 "max(i!1,j!1)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (hide -1) (("2" (skolem-typepred) (("2" (expand "min") (("2" (lift-if) (("2" (bddsimp -1) (("1" (assert) (("1" (expand "max") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "max") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (flatten) (("2" (inst 2 "min(i!1,j!1)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (hide -1) (("2" (skolem-typepred) (("2" (expand "min") (("2" (lift-if) (("2" (bddsimp -2) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil) ("4" (hide -1 -7 3) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil) ("4" (hide -1 -7 3) (("4" (grind) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`cols)):
               (M!1`matrix(i!1, k_1) *
                 IF (k_1 = x!2) THEN 1
                 ELSIF ((k_1 = i!1) AND (x!2 = j!1))
                   THEN -(M!1`matrix(i!1, j!1))
                 ELSE 0
                 ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (hide 4) (("2" (skolem-typepred) (("2" (inst -7 "n!1") (("1" (assert) (("1" (assert) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`cols)):
               (M!1`matrix(x!1, k_1) *
                 IF (k_1 = x!2) THEN 1
                 ELSIF ((k_1 = i!1) AND (x!2 = j!1))
                   THEN -(M!1`matrix(i!1, j!1))
                 ELSE 0
                 ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (hide 4) (("2" (skolem-typepred) (("2" (inst -6 "x!1" "n!1") (("1" (assert) (("1" (prop) (("1" (assert) nil nil) ("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 4) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -4 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (grind) nil nil)) nil) ("3" (skolem-typepred) (("3" (flatten) (("3" (assert) (("3" (hide -9) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (skolem-typepred) (("4" (flatten) (("4" (assert) nil nil)) nil)) nil) ("5" (hide -4) (("5" (grind) nil nil)) nil)) nil) ("3" (hide -4) (("3" (grind) nil nil)) nil) ("4" (hide -4) (("4" (grind) nil nil)) nil) ("5" (hide -4) (("5" (grind) nil nil)) nil) ("6" (hide -4) (("6" (grind) nil nil)) nil) ("7" (hide -4) (("7" (skolem-typepred) (("7" (flatten) (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (hide -4) (("8" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "elemM1") (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (apply-extensionality :hide? t) (("1" (expand "I") (("1" (assert) (("1" (expand "*") (("1" (lift-if) (("1" (prop) (("1" (expand "elemM1?") (("1" (lemma "sigma_middle[below(M!1`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
               (IF (x!1 = k_1) THEN 1
                ELSIF ((x!1 = i!1) AND (k_1 = j!1))
                  THEN -(M!1`matrix(i!1, j!1))
                ELSE 0
                ENDIF
                 * M!1`matrix(k_1, x!2))" "M!1`rows-1" "x!1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (x!1 = k_1) THEN 1
                  ELSIF ((x!1 = i!1) AND (k_1 = j!1))
                    THEN -(M!1`matrix(i!1, j!1))
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, x!2))" "LAMBDA (k_1: below(M!1`rows)): 0" "x!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "sigma_eq[below(M!1`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (x!1 = k_1) THEN 1
                  ELSIF ((x!1 = i!1) AND (k_1 = j!1))
                    THEN -(M!1`matrix(i!1, j!1))
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, x!2))" "LAMBDA (k_1: below(M!1`rows)): 0" "M!1`rows-1" "x!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") (("1" (replace -1 :hide? t) (("1" (inst -5 "x!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem-typepred) (("2" (lift-if) (("2" (prop) (("1" (inst -8 "n!1" "x!2") (("1" (assert) nil nil)) nil) ("2" (inst -9 "n!1" "x!2") (("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (inst -7 "n!1" "x!2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil) ("3" (hide -5 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem-typepred) (("2" (lift-if) (("2" (prop) (("1" (inst -8 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil) ("2" (inst -9 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil) ("3" (assert) nil nil) ("4" (inst -7 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5 2) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5 2) (("3" (grind) (("3" (typepred "x!2") (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (hide -5 2) (("4" (grind) nil nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "elemM1?") (("2" (case "x!1 = i!1") (("1" (case "x!2 = j!1") (("1" (replace -1) (("1" (replace -2) (("1" (lemma "sigma_middle[below(M!1`rows)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M!1`rows)):
               (IF (i!1 = k_1) THEN 1
                ELSIF (k_1 = j!1) THEN -(M!1`matrix(i!1, j!1))
                ELSE 0
                ENDIF
                 * M!1`matrix(k_1, j!1))" "M!1`rows-1" "min(i!1,j!1)" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
               (IF (i!1 = k_1) THEN 1
                ELSIF (k_1 = j!1) THEN -(M!1`matrix(i!1, j!1))
                ELSE 0
                ENDIF
                 * M!1`matrix(k_1, j!1))" "M!1`rows-1" "max(i!1,j!1)" "min(i!1,j!1)+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`rows)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (i!1 = k_1) THEN 1
                  ELSIF (k_1 = j!1) THEN -(M!1`matrix(i!1, j!1))
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, j!1))" "LAMBDA (k_1: below(M!1`rows)): 0" "min(i!1, j!1) - 1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst-cp -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (i!1 = k_1) THEN 1
                  ELSIF (k_1 = j!1) THEN -(M!1`matrix(i!1, j!1))
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, j!1))" "LAMBDA (k_1: below(M!1`rows)): 0" "max(i!1, j!1)-1" "min(i!1, j!1)+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (i!1 = k_1) THEN 1
                  ELSIF (k_1 = j!1) THEN -(M!1`matrix(i!1, j!1))
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, j!1))" "LAMBDA (k_1: below(M!1`rows)): 0" "M!1`rows-1" "max(i!1, j!1)+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (expand "max") (("1" (assert) (("1" (inst -7 "j!1" "j!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "max") (("2" (assert) (("2" (inst -6 "j!1" "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skolem-typepred) (("2" (expand "max") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (skolem-typepred) (("2" (expand "min") (("2" (expand "max") (("2" (assert) (("2" (lift-if) (("2" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (hide -1) (("2" (skolem-typepred) (("2" (expand "min") (("2" (lift-if) (("2" (bddsimp -2) (("1" (inst -9 "n!1" "j!1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (hide -1) (("2" (grind) nil nil)) nil)) nil) ("3" (hide -1 -6 3) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil) ("4" (hide -6 3) (("4" (grind) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq[below(M!1`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
               (IF (x!1 = k_1) THEN 1
                ELSIF ((x!1 = i!1) AND (k_1 = j!1))
                  THEN -(M!1`matrix(i!1, j!1))
                ELSE 0
                ENDIF
                 * M!1`matrix(k_1, x!2))" "LAMBDA (k_1: below(M!1`rows)): 0" "M!1`rows-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") nil nil)) nil) ("2" (skolem-typepred) (("2" (assert) (("2" (hide 4) (("2" (lift-if) (("2" (prop) (("1" (inst -8 "n!1" "x!2") (("1" (assert) nil nil) ("2" (assert) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -8 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (inst -7 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5 4) (("3" (typepred "x!2") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq[below(M!1`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
               (IF (x!1 = k_1) THEN 1
                ELSIF ((x!1 = i!1) AND (k_1 = j!1))
                  THEN -(M!1`matrix(i!1, j!1))
                ELSE 0
                ENDIF
                 * M!1`matrix(k_1, x!2))" "LAMBDA (k_1: below(M!1`rows)): 0" "M!1`rows-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") nil nil)) nil) ("2" (skolem-typepred) (("2" (lift-if) (("2" (hide 4) (("2" (prop) (("1" (inst -7 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil) ("2" (inst -6 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil) ("3" (inst -6 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 4) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -4 4) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -4 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((invertible? const-decl "bool" matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (T_low type-eq-decl nil sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (sigma def-decl "real" sigma "reals/") (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (I const-decl "(identity?)" matrices nil) (identity? const-decl "bool" matrices nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (x!2 skolem-const-decl "below(M!1`rows)" elementary_matrices nil) (x!1 skolem-const-decl "below(M!1`rows)" elementary_matrices nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (subrange type-eq-decl nil integers nil) (n!1 skolem-const-decl "subrange(1 + x!1, M!1`cols - 1)" elementary_matrices nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (sigma_zero formula-decl nil sigma "reals/") (sigma_eq formula-decl nil sigma "reals/") (sigma_middle formula-decl nil sigma "reals/") (n!1 skolem-const-decl "subrange(0, M!1`cols - 1)" elementary_matrices nil) (n!1 skolem-const-decl "subrange(0, M!1`cols - 1)" elementary_matrices nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "Matrix" matrices nil) (elemM1? const-decl "bool" elementary_matrices nil) (sigma_nat application-judgement "nat" vectors "vectors/") (x!2 skolem-const-decl "below(((# rows := M!1`rows,
          cols := M!1`rows,
          matrix
            := LAMBDA (k, l: below(M!1`rows)):
                 IF k = l THEN 1
                 ELSIF k = i!1 AND l = j!1 THEN -(M!1`matrix(i!1, j!1))
                 ELSE 0
                 ENDIF #)
        * M!1)`cols)" elementary_matrices nil) (x!1 skolem-const-decl "below(((# rows := M!1`rows,
          cols := M!1`rows,
          matrix
            := LAMBDA (k, l: below(M!1`rows)):
                 IF k = l THEN 1
                 ELSIF k = i!1 AND l = j!1 THEN -(M!1`matrix(i!1, j!1))
                 ELSE 0
                 ENDIF #)
        * M!1)`rows)" elementary_matrices nil) (n!1 skolem-const-decl "subrange(0, min(i!1, j!1) - 1)" elementary_matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (j!1 skolem-const-decl "{j: below(M!1`rows) | i!1 /= j}" elementary_matrices nil) (i!1 skolem-const-decl "below(M!1`rows)" elementary_matrices nil) (M!1 skolem-const-decl "ElemM1" elementary_matrices nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (inverse? const-decl "bool" matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ElemM1 type-eq-decl nil elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak) (elemM1_invertible-1 nil 3492633168 ("" (skolem-typepred) (("" (expand "invertible?") (("" (expand "elemM1?") (("" (skolem-typepred) (("" (inst 1 "elemM1(M!1`rows)(i!1, j!1)(-(M!1`matrix(i!1, j!1)))") (("1" (prop) (("1" (grind) nil nil) ("2" (expand "inverse?") (("2" (prop) (("1" (expand "elemM1?") (("1" (expand "elemM1") (("1" (expand "*") (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (apply-extensionality :hide? t) (("1" (expand "I") (("1" (lift-if) (("1" (prop) (("1" (lemma "sigma_middle[below(M!1`cols)]") (("1" (inst? :subst ("low" "0" "high" "M!1`cols-1" "i" "x!1")) (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M!1`cols)):
                 (M!1`matrix(x!1, k_1) *
                   IF (k_1 = x!2) THEN 1
                   ELSIF ((k_1 = i!1) AND (x!2 = j!1))
                     THEN -(M!1`matrix(i!1, j!1))
                   ELSE 0
                   ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "x!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (inst -1 "LAMBDA (k_1: below(M!1`cols)):
                 (M!1`matrix(x!1, k_1) *
                   IF (k_1 = x!2) THEN 1
                   ELSIF ((k_1 = i!1) AND (x!2 = j!1))
                     THEN -(M!1`matrix(i!1, j!1))
                   ELSE 0
                   ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "M!1`cols-1" "x!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst -5 "x!1" "x!1") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp) (("2" (assert) (("2" (inst -5 "x!1" "n!1") (("1" (assert) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil) ("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (skolem-typepred) (("2" (inst -7 "x!1" "n!1") (("2" (assert) (("2" (assert) (("2" (prop) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (lift-if) (("2" (assert) nil nil)) nil) ("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil) ("3" (hide -5 2) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil) ("3" (hide -5 2) (("3" (grind) nil nil)) nil) ("4" (hide -6 2) (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (case-replace "x!1 = i!1") (("1" (inst -5 "i!1" _) (("1" (case "x!2 = j!1") (("1" (replace -1) (("1" (lemma "sigma_middle[below(M!1`cols)]") (("1" (inst? :subst ("low" "0" "high" "M!1`cols-1" "i" "min(i!1,j!1)")) (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_middle[below(M!1`cols)]") (("1" (inst? :subst ("low" "min(i!1,j!1)+1" "high" "M!1`cols-1" "i" "max(i!1, j!1)")) (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M!1`cols)):
                    (M!1`matrix(i!1, k_1) *
                      IF (k_1 = j!1) THEN 1
                      ELSIF (k_1 = i!1) THEN -(M!1`matrix(i!1, j!1))
                      ELSE 0
                      ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "min(i!1,j!1)-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst-cp -1 "LAMBDA (k_1: below(M!1`cols)):
                    (M!1`matrix(i!1, k_1) *
                      IF (k_1 = j!1) THEN 1
                      ELSIF (k_1 = i!1) THEN -(M!1`matrix(i!1, j!1))
                      ELSE 0
                      ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "max(i!1,j!1)-1" "min(i!1,j!1)+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst -1 "LAMBDA (k_1: below(M!1`cols)):
                    (M!1`matrix(i!1, k_1) *
                      IF (k_1 = j!1) THEN 1
                      ELSIF (k_1 = i!1) THEN -(M!1`matrix(i!1, j!1))
                      ELSE 0
                      ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "M!1`cols-1" "max(i!1,j!1)+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (expand "max") (("1" (assert) (("1" (inst -7 "i!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "max") (("2" (assert) (("2" (assert) (("2" (inst -6 "i!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skolem-typepred) (("2" (expand "max") (("2" (lift-if) (("2" (assert) (("2" (bddsimp -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (flatten) (("2" (inst 2 "max(i!1,j!1)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (hide -1) (("2" (skolem-typepred) (("2" (expand "min") (("2" (lift-if) (("2" (bddsimp -1) (("1" (assert) (("1" (expand "max") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "max") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (flatten) (("2" (inst 2 "min(i!1,j!1)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (hide -1) (("2" (skolem-typepred) (("2" (expand "min") (("2" (lift-if) (("2" (bddsimp -2) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil) ("4" (hide -1 -7 3) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil) ("4" (hide -1 -7 3) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq[below(M!1`cols)]") (("2" (inst -1 "LAMBDA (k_1: below(M!1`cols)):
               (M!1`matrix(i!1, k_1) *
                 IF (k_1 = x!2) THEN 1
                 ELSIF ((k_1 = i!1) AND (x!2 = j!1))
                   THEN -(M!1`matrix(i!1, j!1))
                 ELSE 0
                 ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (hide 4) (("2" (skolem-typepred) (("2" (inst -7 "n!1") (("1" (assert) (("1" (assert) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq[below(M!1`cols)]") (("2" (inst -1 "LAMBDA (k_1: below(M!1`cols)):
               (M!1`matrix(x!1, k_1) *
                 IF (k_1 = x!2) THEN 1
                 ELSIF ((k_1 = i!1) AND (x!2 = j!1))
                   THEN -(M!1`matrix(i!1, j!1))
                 ELSE 0
                 ENDIF)" "LAMBDA (k_1: below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (hide 4) (("2" (skolem-typepred) (("2" (inst -6 "x!1" "n!1") (("1" (assert) (("1" (prop) (("1" (assert) nil nil) ("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (grind) nil nil)) nil) ("3" (skolem-typepred) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil) ("4" (skolem-typepred) (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil) ("3" (hide -4) (("3" (grind) nil nil)) nil) ("4" (hide -4) (("4" (grind) nil nil)) nil) ("5" (hide -4) (("5" (grind) nil nil)) nil) ("6" (hide -4) (("6" (grind) nil nil)) nil) ("7" (hide -4) (("7" (skolem-typepred) (("7" (flatten) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "elemM1") (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (apply-extensionality :hide? t) (("1" (expand "I") (("1" (assert) (("1" (expand "*") (("1" (lift-if) (("1" (prop) (("1" (expand "elemM1?") (("1" (lemma "sigma_middle[below(M!1`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
               (IF (x!1 = k_1) THEN 1
                ELSIF ((x!1 = i!1) AND (k_1 = j!1))
                  THEN -(M!1`matrix(i!1, j!1))
                ELSE 0
                ENDIF
                 * M!1`matrix(k_1, x!2))" "M!1`rows-1" "x!1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (x!1 = k_1) THEN 1
                  ELSIF ((x!1 = i!1) AND (k_1 = j!1))
                    THEN -(M!1`matrix(i!1, j!1))
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, x!2))" "LAMBDA (k_1: below(M!1`rows)): 0" "x!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "sigma_eq[below(M!1`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (x!1 = k_1) THEN 1
                  ELSIF ((x!1 = i!1) AND (k_1 = j!1))
                    THEN -(M!1`matrix(i!1, j!1))
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, x!2))" "LAMBDA (k_1: below(M!1`rows)): 0" "M!1`rows-1" "x!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") (("1" (replace -1 :hide? t) (("1" (inst -5 "x!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem-typepred) (("2" (lift-if) (("2" (prop) (("1" (inst -8 "n!1" "x!2") (("1" (assert) nil nil)) nil) ("2" (inst -9 "n!1" "x!2") (("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (inst -7 "n!1" "x!2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil) ("3" (hide -5 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem-typepred) (("2" (lift-if) (("2" (prop) (("1" (inst -8 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil) ("2" (inst -9 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil) ("3" (assert) nil nil) ("4" (inst -7 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5 2) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5 2) (("3" (grind) (("3" (typepred "x!2") (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (hide -5 2) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "elemM1?") (("2" (case "x!1 = i!1") (("1" (case "x!2 = j!1") (("1" (replace -1) (("1" (replace -2) (("1" (lemma "sigma_middle[below(M!1`rows)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M!1`rows)):
               (IF (i!1 = k_1) THEN 1
                ELSIF (k_1 = j!1) THEN -(M!1`matrix(i!1, j!1))
                ELSE 0
                ENDIF
                 * M!1`matrix(k_1, j!1))" "M!1`rows-1" "min(i!1,j!1)" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
               (IF (i!1 = k_1) THEN 1
                ELSIF (k_1 = j!1) THEN -(M!1`matrix(i!1, j!1))
                ELSE 0
                ENDIF
                 * M!1`matrix(k_1, j!1))" "M!1`rows-1" "max(i!1,j!1)" "min(i!1,j!1)+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`rows)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (i!1 = k_1) THEN 1
                  ELSIF (k_1 = j!1) THEN -(M!1`matrix(i!1, j!1))
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, j!1))" "LAMBDA (k_1: below(M!1`rows)): 0" "min(i!1, j!1) - 1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst-cp -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (i!1 = k_1) THEN 1
                  ELSIF (k_1 = j!1) THEN -(M!1`matrix(i!1, j!1))
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, j!1))" "LAMBDA (k_1: below(M!1`rows)): 0" "max(i!1, j!1)-1" "min(i!1, j!1)+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (i!1 = k_1) THEN 1
                  ELSIF (k_1 = j!1) THEN -(M!1`matrix(i!1, j!1))
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, j!1))" "LAMBDA (k_1: below(M!1`rows)): 0" "M!1`rows-1" "max(i!1, j!1)+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (expand "max") (("1" (assert) (("1" (inst -7 "j!1" "j!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "max") (("2" (assert) (("2" (inst -6 "j!1" "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skolem-typepred) (("2" (expand "max") (("2" (assert) (("2" (lift-if) (("2" (bddsimp -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (skolem-typepred) (("2" (expand "min") (("2" (expand "max") (("2" (assert) (("2" (lift-if) (("2" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (hide -1) (("2" (skolem-typepred) (("2" (expand "min") (("2" (lift-if) (("2" (bddsimp -2) (("1" (inst -9 "n!1" "j!1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (hide -1) (("2" (grind) nil nil)) nil)) nil) ("3" (hide -1 -6 3) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil) ("4" (hide -6 3) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq[below(M!1`rows)]") (("2" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
               (IF (x!1 = k_1) THEN 1
                ELSIF ((x!1 = i!1) AND (k_1 = j!1))
                  THEN -(M!1`matrix(i!1, j!1))
                ELSE 0
                ENDIF
                 * M!1`matrix(k_1, x!2))" "LAMBDA (k_1: below(M!1`rows)): 0" "M!1`rows-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") nil nil)) nil) ("2" (skolem-typepred) (("2" (assert) (("2" (hide 4) (("2" (lift-if) (("2" (prop) (("1" (inst -8 "n!1" "x!2") (("1" (assert) nil nil) ("2" (assert) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -8 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (inst -7 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5 4) (("3" (typepred "x!2") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq[below(M!1`rows)]") (("2" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
               (IF (x!1 = k_1) THEN 1
                ELSIF ((x!1 = i!1) AND (k_1 = j!1))
                  THEN -(M!1`matrix(i!1, j!1))
                ELSE 0
                ENDIF
                 * M!1`matrix(k_1, x!2))" "LAMBDA (k_1: below(M!1`rows)): 0" "M!1`rows-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") nil nil)) nil) ("2" (skolem-typepred) (("2" (lift-if) (("2" (hide 4) (("2" (prop) (("1" (inst -7 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil) ("2" (inst -6 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil) ("3" (inst -6 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 4) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -4 4) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (ElemM1 type-eq-decl nil elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (inverse? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sigma_nat application-judgement "nat" vectors "vectors/") (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (sigma_middle formula-decl nil sigma "reals/") (sigma_eq formula-decl nil sigma "reals/") (sigma_zero formula-decl nil sigma "reals/") (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (identity? const-decl "bool" matrices nil) (I const-decl "(identity?)" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma def-decl "real" sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (T_low type-eq-decl nil sigma "reals/") (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (invertible? const-decl "bool" matrices nil)) shostak)) (elemM2_invertible 0 (elemM2_invertible-2 "" 3520306846 ("" (skolem-typepred) (("" (expand "invertible?") (("" (expand "elemM2?") (("" (skolem-typepred) (("" (inst 1 "M!1") (("" (expand "inverse?") (("" (assert) (("" (case "(M!1 * M!1) = I(M!1`rows)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (apply-extensionality :hide? t) (("3" (expand "*") (("3" (expand "I") (("3" (expand "elemM2?") (("3" (lift-if) (("3" (prop) (("1" (case "x!1 = i!1") (("1" (lemma "sigma_middle[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "M!1`cols-1" "j!1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst-cp -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "j!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "j!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst-cp -6 "i!1" "j!1") (("1" (inst -6 "j!1" "i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst -8 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -6 2) (("2" (grind) nil nil)) nil) ("3" (hide -6 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst -9 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -6 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -6 2) (("2" (grind) nil nil)) nil) ("3" (hide -6 2) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -6 2) (("2" (grind) nil nil)) nil) ("3" (hide -6 2) (("3" (grind) nil nil)) nil) ("4" (hide -6 2) (("4" (grind) nil nil)) nil) ("5" (hide -6 2) (("5" (grind) nil nil)) nil)) nil) ("2" (hide -6 2) (("2" (grind) nil nil)) nil)) nil) ("2" (case "x!1 = j!1") (("1" (lemma "sigma_middle[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "M!1`cols-1" "i!1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst-cp -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "i!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "i!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst-cp -6 "i!1" "j!1") (("1" (inst -6 "j!1" "i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst -8 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (assert) (("2" (inst -9 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (assert) nil nil)) nil) ("2" (assert) (("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil) ("4" (hide -6 3) (("4" (grind) nil nil)) nil) ("5" (hide -6 3) (("5" (grind) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil) ("2" (lemma "sigma_middle[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "M!1`cols-1" "x!1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst-cp -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "x!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "x!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst -5 "x!1" "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst -7 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst -8 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5 4) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5 4) (("3" (grind) (("3" (typepred "x!2") (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (hide -5 4) (("4" (grind) nil nil)) nil) ("5" (hide -5 4) (("5" (grind) (("5" (typepred "x!2") (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "x!1 = i!1") (("1" (case "x!2 = j!1") (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(i!1, k) * M!1`matrix(k, j!1))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (skolem-typepred) (("2" (case "n!1 = i!1") (("1" (inst -7 "i!1" "n!1") (("1" (assert) nil nil)) nil) ("2" (case "n!1 = j!1") (("1" (inst -7 "n!1" "j!1") (("1" (assert) nil nil)) nil) ("2" (inst-cp -6 "i!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 3) (("2" (grind) nil nil)) nil) ("3" (hide -4 3) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -4 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (skolem-typepred) (("2" (case "n!1 = x!1") (("1" (inst -8 "x!1" "n!1") (("1" (assert) nil nil)) nil) ("2" (replace -3 :hide? t) (("2" (inst-cp -6 "n!1" "x!2") (("1" (assert) (("1" (prop) (("1" (replace -1 :dir rl :hide? t) (("1" (inst -7 "i!1" "n!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5 4) (("3" (grind) nil nil)) nil) ("4" (hide -5 4) (("4" (grind) nil nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case "x!1 = j!1") (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(j!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (skolem-typepred) (("2" (case "n!1 = i!1") (("1" (replace -1 :hide? t) (("1" (inst -6 "i!1" "x!2") (("1" (assert) nil nil) ("2" (assert) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -6 "j!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -4 4) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -4 4) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -4 4) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (skolem-typepred) (("2" (inst-cp -6 "x!1" "n!1") (("2" (assert) (("2" (prop) (("2" (inst -8 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 5) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -4 5) (("3" (grind) nil nil)) nil) ("4" (hide -4 5) (("4" (grind) (("4" (typepred "x!1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -4 5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((invertible? const-decl "bool" matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (* const-decl "Matrix" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (identity? const-decl "bool" matrices nil) (I const-decl "(identity?)" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma "reals/") (elemM2? const-decl "bool" elementary_matrices nil) (sigma_middle formula-decl nil sigma "reals/") (sigma_eq formula-decl nil sigma "reals/") (sigma_zero formula-decl nil sigma "reals/") (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_nat application-judgement "nat" vectors "vectors/") (real_plus_real_is_real application-judgement "real" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma "reals/") (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_low type-eq-decl nil sigma "reals/") (j!1 skolem-const-decl "{j: below(M!1`rows) | i!1 /= j}" elementary_matrices nil) (i!1 skolem-const-decl "below(M!1`rows)" elementary_matrices nil) (x!2 skolem-const-decl "below((M!1 * M!1)`cols)" elementary_matrices nil) (x!1 skolem-const-decl "below((M!1 * M!1)`rows)" elementary_matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (M!1 skolem-const-decl "ElemM2" elementary_matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (inverse? const-decl "bool" matrices nil) (ElemM2 type-eq-decl nil elementary_matrices nil) (elemM2? const-decl "bool" elementary_matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak) (elemM2_invertible-1 nil 3492745295 ("" (skolem-typepred) (("" (expand "invertible?") (("" (expand "elemM2?") (("" (skolem-typepred) (("" (inst 1 "M!1") (("" (expand "inverse?") (("" (assert) (("" (case "(M!1 * M!1) = I(M!1`rows)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (apply-extensionality :hide? t) (("3" (expand "*") (("3" (expand "I") (("3" (expand "elemM2?") (("3" (lift-if) (("3" (prop) (("1" (case "x!1 = i!1") (("1" (lemma "sigma_middle[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "M!1`cols-1" "j!1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst-cp -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "j!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "j!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst-cp -6 "i!1" "j!1") (("1" (inst -6 "j!1" "i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst -8 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -6 2) (("2" (grind) nil nil)) nil) ("3" (hide -6 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst -9 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -6 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -6 2) (("2" (grind) nil nil)) nil) ("3" (hide -6 2) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -6 2) (("2" (grind) nil nil)) nil) ("3" (hide -6 2) (("3" (grind) nil nil)) nil) ("4" (hide -6 2) (("4" (grind) nil nil)) nil) ("5" (hide -6 2) (("5" (grind) nil nil)) nil)) nil)) nil) ("2" (case "x!1 = j!1") (("1" (lemma "sigma_middle[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "M!1`cols-1" "i!1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst-cp -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "i!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "i!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst-cp -6 "i!1" "j!1") (("1" (inst -6 "j!1" "i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst -8 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (assert) (("2" (inst -9 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -6 3) (("2" (grind) nil nil)) nil) ("3" (assert) nil nil)) nil) ("2" (assert) (("2" (hide -6 3) (("2" (grind) nil nil)) nil)) nil) ("3" (hide -6 3) (("3" (grind) nil nil)) nil) ("4" (hide -6 3) (("4" (grind) nil nil)) nil) ("5" (hide -6 3) (("5" (grind) nil nil)) nil)) nil)) nil) ("2" (lemma "sigma_middle[below(M!1`cols)]") (("2" (inst -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "M!1`cols-1" "x!1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst-cp -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "x!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "x!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst -5 "x!1" "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst -7 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (inst -8 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5 4) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5 4) (("3" (grind) (("3" (typepred "x!2") (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (hide -5 4) (("4" (grind) nil nil)) nil) ("5" (hide -5 4) (("5" (grind) (("5" (typepred "x!2") (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "x!1 = i!1") (("1" (case "x!2 = j!1") (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(i!1, k) * M!1`matrix(k, j!1))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (skolem-typepred) (("2" (case "n!1 = i!1") (("1" (inst -7 "i!1" "n!1") (("1" (assert) nil nil)) nil) ("2" (case "n!1 = j!1") (("1" (inst -7 "n!1" "j!1") (("1" (assert) nil nil)) nil) ("2" (inst-cp -6 "i!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 3) (("2" (grind) nil nil)) nil) ("3" (hide -4 3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq[below(M!1`cols)]") (("2" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (skolem-typepred) (("2" (case "n!1 = x!1") (("1" (inst -8 "x!1" "n!1") (("1" (assert) nil nil)) nil) ("2" (replace -3 :hide? t) (("2" (inst-cp -6 "n!1" "x!2") (("1" (assert) (("1" (prop) (("1" (replace -1 :dir rl :hide? t) (("1" (inst -7 "i!1" "n!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 4) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -5 4) (("3" (grind) nil nil)) nil) ("4" (hide -5 4) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "x!1 = j!1") (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(j!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (skolem-typepred) (("2" (case "n!1 = i!1") (("1" (replace -1 :hide? t) (("1" (inst -6 "i!1" "x!2") (("1" (assert) nil nil) ("2" (assert) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -6 "j!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -4 4) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -4 4) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sigma_eq[below(M!1`cols)]") (("2" (inst -1 "LAMBDA (k: below(M!1`cols)):
                 (M!1`matrix(x!1, k) * M!1`matrix(k, x!2))" "LAMBDA (k:
                 below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (skolem-typepred) (("2" (inst-cp -6 "x!1" "n!1") (("2" (assert) (("2" (prop) (("2" (inst -8 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 5) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -4 5) (("3" (grind) nil nil)) nil) ("4" (hide -4 5) (("4" (grind) (("4" (typepred "x!1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (ElemM2 type-eq-decl nil elementary_matrices nil) (inverse? const-decl "bool" matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (T_low type-eq-decl nil sigma "reals/") (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_high type-eq-decl nil sigma "reals/") (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_nat application-judgement "nat" vectors "vectors/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (subrange type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (sigma_zero formula-decl nil sigma "reals/") (sigma_eq formula-decl nil sigma "reals/") (integer nonempty-type-from-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (sigma_middle formula-decl nil sigma "reals/") (sigma def-decl "real" sigma "reals/") (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (I const-decl "(identity?)" matrices nil) (identity? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (invertible? const-decl "bool" matrices nil)) shostak)) (elemM3_invertible 0 (elemM3_invertible-2 "" 3520307266 ("" (skeep :preds? t) (("" (expand "invertible?") (("" (expand "elemM3?") (("" (skosimp) (("" (expand "elemM3?") (("" (inst 1 "elemM3(M`rows)(i!1)(1/M`matrix(i!1,i!1))") (("1" (prop) (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (expand "elemM3") (("2" (expand "inverse?") (("2" (expand "I") (("2" (expand "*") (("2" (split 1) (("1" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_1_nz") (("1" (inst -1 "M`cols" "x!2" "1") (("1" (case-replace "(LAMBDA (x: below(M`cols)): IF x = x!2 THEN 1 ELSE 0
ENDIF) = (LAMBDA (k_1: below(M`cols)):
             M`matrix(x!2, k_1) *
              IF k_1 = x!2
                THEN IF k_1 = i!1 THEN 1 / M`matrix(i!1, i!1) ELSE 1 ENDIF
              ELSE 0
              ENDIF)") (("1" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (assert) (("1" (inst -4 "x!2" "x!3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (inst -6 "i!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (inst -6 "i!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (assert) (("2" (hide -2 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -2 "x!1" "x!2") (("2" (assert) (("2" (prop) (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil) ("2" (lemma "sigma_1_nz") (("2" (inst -1 "M`cols" "x!2" "0") (("2" (case-replace "(LAMBDA (x: below(M`cols)): 0) = (LAMBDA (k_1: below(M`cols)):
             M`matrix(x!1, k_1) *
              IF k_1 = x!2
                THEN IF k_1 = i!1 THEN 1 / M`matrix(i!1, i!1) ELSE 1 ENDIF
              ELSE 0
              ENDIF)") (("1" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (assert) (("2" (reveal -3) (("2" (inst -1 "k_1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (reveal -2) (("2" (inst -1 "k_1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (lemma "sigma_zero[below(M`cols)]") (("3" (inst -1 "M`cols-1" "0") (("3" (case-replace "(LAMBDA (i: below(M`cols)): 0) = (LAMBDA (k_1: below(M`cols)):
             M`matrix(x!1, k_1) * IF k_1 = x!2 THEN 1 ELSE 0 ENDIF)") (("3" (apply-extensionality :hide? t) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (inst -5 "i!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) (("5" (assert) nil nil)) nil)) nil) ("2" (hide -2) (("2" (grind) nil nil)) nil) ("3" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_1_nz") (("1" (inst -1 "M`rows" "x!2" "1") (("1" (case-replace "(LAMBDA (x: below(M`rows)): IF x = x!2 THEN 1 ELSE 0
ENDIF) = (LAMBDA (k_1: below(M`rows)):
             IF x!2 = k_1
               THEN IF x!2 = i!1 THEN 1 / M`matrix(i!1, i!1) ELSE 1 ENDIF
             ELSE 0
             ENDIF
              * M`matrix(k_1, x!2))") (("1" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (inst -3 "x!3" "x!2") (("1" (ground) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (inst -6 "i!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (inst -6 "i!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (hide -2 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -2 "x!1" "x!2") (("1" (lemma "sigma_zero[below(M`rows)]") (("1" (inst -1 "M`rows-1" "0") (("1" (case-replace "(LAMBDA (i: below(M`rows)): 0) = (LAMBDA (k_1: below(M`rows)):
             IF x!1 = k_1
               THEN IF x!1 = i!1 THEN 1 / M`matrix(i!1, i!1) ELSE 1 ENDIF
             ELSE 0
             ENDIF
              * M`matrix(k_1, x!2))") (("1" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (ground) nil nil)) nil) ("2" (skeep) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (assert) (("3" (reveal -3) (("3" (inst -1 "i!1" "i!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (assert) (("4" (hide-all-but (-4 1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (reveal -2) (("2" (inst -1 "i!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) (("3" (hide-all-but (-4 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (grind) nil nil)) nil) ("3" (skeep) (("3" (replace -1 :hide? t) (("3" (replace -1 :hide? t) (("3" (inst -3 "k_1" "k_1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (assert) (("4" (hide -1 -2 -4) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "i!1" "i!1") (("2" (assert) nil nil)) nil) ("3" (assert) (("3" (hide -2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((elemM3? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (x!2 skolem-const-decl "below(M`cols)" elementary_matrices nil) (x!1 skolem-const-decl "below(M`rows)" elementary_matrices nil) (T_low type-eq-decl nil sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (sigma def-decl "real" sigma "reals/") (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_1_nz formula-decl nil elementary_matrices nil) (sigma_nat application-judgement "nat" vectors "vectors/") (x!2 skolem-const-decl "below(M`rows)" elementary_matrices nil) (sigma_zero formula-decl nil sigma "reals/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (I const-decl "(identity?)" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (M skolem-const-decl "ElemM3" elementary_matrices nil) (i!1 skolem-const-decl "below(M`rows)" elementary_matrices nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (inverse? const-decl "bool" matrices nil) (ElemM3 type-eq-decl nil elementary_matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (invertible? const-decl "bool" matrices nil)) shostak) (elemM3_invertible-1 nil 3492821906 ("" (skolem-typepred) (("" (expand "invertible?") (("" (expand "elemM3?") (("" (skolem-typepred) (("" (inst 1 "elemM3(M!1`rows)(i!1)(1/M!1`matrix(i!1,i!1))") (("1" (prop) (("1" (grind) nil nil) ("2" (expand "inverse?") (("2" (expand "elemM3?") (("2" (prop) (("1" (expand "*") (("1" (expand "I") (("1" (prop) (("1" (grind) nil nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (prop) (("1" (expand "elemM3") (("1" (case "x!1 = i!1") (("1" (lemma "sigma_middle[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) *
                 IF (k = x!2)
                   THEN IF (k = i!1) THEN (1 / M!1`matrix(i!1, i!1))
                        ELSE 1
                        ENDIF
                 ELSE 0
                 ENDIF)" "M!1`cols-1" "i!1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) *
                 IF (k = x!2)
                   THEN IF (k = i!1) THEN (1 / M!1`matrix(i!1, i!1))
                        ELSE 1
                        ENDIF
                 ELSE 0
                 ENDIF)" "LAMBDA (k: below(M!1`cols)): 0" "i!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) *
                 IF (k = x!2)
                   THEN IF (k = i!1) THEN (1 / M!1`matrix(i!1, i!1))
                        ELSE 1
                        ENDIF
                 ELSE 0
                 ENDIF)" "LAMBDA (k: below(M!1`cols)): 0" "M!1`cols-1" "i!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem-typepred) (("2" (inst -7 "x!1" "n!1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem-typepred) (("2" (assert) (("2" (inst -6 "i!1" "i!1") (("2" (assert) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem-typepred) (("2" (inst -7 "x!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem-typepred) (("2" (inst -6 "i!1" "i!1") (("2" (assert) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil) ("3" (hide -5 2) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -5 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (skolem-typepred) (("3" (flatten) (("3" (inst -9 "i!1" "i!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (hide -5) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_middle[below(M!1`cols)]") (("2" (inst -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) *
                 IF (k = x!2)
                   THEN IF (k = i!1) THEN (1 / M!1`matrix(i!1, i!1))
                        ELSE 1
                        ENDIF
                 ELSE 0
                 ENDIF)" "M!1`cols-1" "x!1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`cols)]") (("1" (inst-cp -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) *
                 IF (k = x!2)
                   THEN IF (k = i!1) THEN (1 / M!1`matrix(i!1, i!1))
                        ELSE 1
                        ENDIF
                 ELSE 0
                 ENDIF)" "LAMBDA (k: below(M!1`cols)): 0" "x!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (inst-cp -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) *
                 IF (k = x!2)
                   THEN IF (k = i!1) THEN (1 / M!1`matrix(i!1, i!1))
                        ELSE 1
                        ENDIF
                 ELSE 0
                 ENDIF)" "LAMBDA (k: below(M!1`cols)): 0" "M!1`cols-1" "x!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (hide -1) (("1" (use "sigma_zero[below(M!1`cols)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst -4 "x!1" "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skolem-typepred) (("2" (inst -7 "x!1" "n!1") (("1" (assert) nil nil) ("2" (hide -3 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skolem-typepred) (("2" (flatten) (("2" (inst -8 "i!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -4 3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skolem-typepred) (("2" (inst -7 "x!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skolem-typepred) (("2" (flatten) (("2" (inst -8 "i!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -4 3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -4 3) (("2" (grind) nil nil)) nil) ("3" (hide -4 3) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -4 3) (("2" (grind) nil nil)) nil) ("3" (hide 3) (("3" (skolem-typepred) (("3" (flatten) (("3" (inst -8 "i!1" "i!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide -4 3) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq[below(M!1`cols)]") (("2" (inst -1 "LAMBDA (k: below(M!1`cols)):
               (M!1`matrix(x!1, k) *
                 elemM3(M!1`rows)(i!1)((1 / M!1`matrix(i!1, i!1)))`matrix(k, x!2)
                 )" "LAMBDA (k: below(M!1`cols)): 0" "M!1`cols-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`cols)]") nil nil)) nil) ("2" (hide 3) (("2" (skolem-typepred) (("2" (expand "elemM3") (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (inst -7 "x!1" "n!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (inst -6 "x!1" "n!1") (("1" (assert) nil nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skolem-typepred) (("2" (inst -4 "i!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (grind) nil nil)) nil) ("4" (hide 3) (("4" (skolem-typepred) (("4" (hide -4) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (grind) nil nil)) nil) ("3" (skolem-typepred) (("3" (inst -6 "i!1" "i!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide -3) (("4" (grind) nil nil)) nil) ("5" (skolem-typepred) (("5" (expand "elemM3") (("5" (assert) (("5" (hide -6) (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("6" (hide -3) (("6" (grind) nil nil)) nil) ("7" (hide -3) (("7" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "elemM3") (("2" (expand "I") (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (expand "*") (("1" (prop) (("1" (lemma "sigma_middle[below(M!1`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
               (IF (x!1 = k_1)
                  THEN IF (x!1 = i!1) THEN (1 / M!1`matrix(i!1, i!1))
                       ELSE 1
                       ENDIF
                ELSE 0
                ENDIF
                 * M!1`matrix(k_1, x!2))" "M!1`rows-1" "x!1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (x!1 = k_1)
                    THEN IF (x!1 = i!1) THEN (1 / M!1`matrix(i!1, i!1))
                         ELSE 1
                         ENDIF
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, x!2))" "LAMBDA (k_1: below(M!1`rows)): 0" "x!1-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") (("1" (replace -1 :hide? t) (("1" (lemma "sigma_eq[below(M!1`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (x!1 = k_1)
                    THEN IF (x!1 = i!1) THEN (1 / M!1`matrix(i!1, i!1))
                         ELSE 1
                         ENDIF
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, x!2))" "LAMBDA (k_1: below(M!1`rows)): 0" "M!1`rows-1" "x!1+1") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (inst -5 "i!1" "i!1") (("1" (assert) nil nil)) nil) ("2" (inst -4 "x!1" "x!2") (("1" (assert) nil nil) ("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem-typepred) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem-typepred) (("2" (flatten) (("2" (inst -8 "i!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -4 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem-typepred) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem-typepred) (("2" (flatten) (("2" (inst -8 "i!1" "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -4 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -4 2) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -4 2) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -4 2) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -4 2) (("3" (grind) (("3" (typepred "x!2") (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skolem-typepred) (("4" (flatten) (("4" (inst -8 "i!1" "i!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide -4 2) (("5" (grind) nil nil)) nil)) nil)) nil) ("2" (lemma "sigma_eq[below(M!1`rows)]") (("2" (inst -1 "LAMBDA (k_1: below(M!1`rows)):
                 (IF (x!1 = k_1)
                    THEN IF (x!1 = i!1) THEN (1 / M!1`matrix(i!1, i!1))
                         ELSE 1
                         ENDIF
                  ELSE 0
                  ENDIF
                   * M!1`matrix(k_1, x!2))" "LAMBDA (k_1: below(M!1`rows)): 0" "M!1`rows-1" "0") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (use "sigma_zero[below(M!1`rows)]") nil nil)) nil) ("2" (hide 3) (("2" (skolem-typepred) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (inst -7 "n!1" "x!2") (("1" (assert) nil nil) ("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -6 "n!1" "x!2") (("1" (assert) nil nil) ("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil) ("3" (inst -5 "n!1" "x!2") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 3) (("2" (grind) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (skolem-typepred) (("3" (flatten) (("3" (inst -7 "i!1" "i!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide -3 3) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (grind) nil nil)) nil) ("3" (skolem-typepred) (("3" (flatten) (("3" (inst -8 "i!1" "i!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide -3) (("4" (grind) nil nil)) nil)) nil) ("4" (skolem-typepred) (("4" (flatten) (("4" (inst -8 "i!1" "i!1") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (hide -3) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "elemM3?") (("2" (inst -3 "i!1" "i!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide -3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (ElemM3 type-eq-decl nil elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (inverse? const-decl "bool" matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (I const-decl "(identity?)" matrices nil) (T_low type-eq-decl nil sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (sigma def-decl "real" sigma "reals/") (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (subrange type-eq-decl nil integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_zero formula-decl nil sigma "reals/") (sigma_eq formula-decl nil sigma "reals/") (sigma_middle formula-decl nil sigma "reals/") (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (invertible? const-decl "bool" matrices nil)) shostak)) (elemM1_prop_TCC1 0 (elemM1_prop_TCC1-1 nil 3520642214 ("" (subtype-tcc) nil nil) ((elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (elemM1_prop_TCC2 0 (elemM1_prop_TCC2-1 nil 3520642214 ("" (subtype-tcc) nil nil) ((elemM1 const-decl "ElemMat1(n)" elementary_matrices nil)) nil)) (elemM1_prop_TCC3 0 (elemM1_prop_TCC3-1 nil 3520642214 ("" (subtype-tcc) nil nil) ((elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (elemM1_prop_TCC4 0 (elemM1_prop_TCC4-1 nil 3520642214 ("" (subtype-tcc) nil nil) ((elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (elemM1_prop 0 (elemM1_prop-1 nil 3520646591 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (lift-if) (("" (prop) (("1" (replace -1 :hide? t) (("1" (expand "rowV") (("1" (apply-extensionality :hide? t) (("1" (expand "elemM1") (("1" (expand "*") (("1" (expand "+") (("1" (lemma "sigma_middle[below(M`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
             IF i = k_1 THEN 1 ELSIF k_1 = j THEN a ELSE 0 ENDIF *
              M`matrix(k_1, x!1)" "M`rows-1" "i" "0") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (lemma "sigma_restrict_eq[below(M`rows)]") (("1" (case "i < j") (("1" (lemma "sigma_middle[below(M`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
             IF i = k_1 THEN 1 ELSIF k_1 = j THEN a ELSE 0 ENDIF *
              M`matrix(k_1, x!1)" "M`rows-1" "j" "i+1") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (inst-cp -2 "LAMBDA (k_1: below(M`rows)):
              IF i = k_1 THEN 1 ELSIF k_1 = j THEN a ELSE 0 ENDIF *
               M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "i-1" "0") (("1" (expand "restrict") (("1" (split -3) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") (("1" (inst-cp -2 "LAMBDA (k_1: below(M`rows)):
              IF i = k_1 THEN 1 ELSIF k_1 = j THEN a ELSE 0 ENDIF *
               M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "j-1" "i+1") (("1" (split -3) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") (("1" (inst -2 "LAMBDA (k_1: below(M`rows)):
              IF i = k_1 THEN 1 ELSIF k_1 = j THEN a ELSE 0 ENDIF *
               M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "M`rows-1" "j+1") (("1" (split -2) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") nil nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (grind) (("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (inst 2 "0") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (grind) (("3" (typepred "x!1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst 2 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_middle[below(M`rows)]") (("2" (inst -1 "LAMBDA (k_1: below(M`rows)):
             IF i = k_1 THEN 1 ELSIF k_1 = j THEN a ELSE 0 ENDIF *
              M`matrix(k_1, x!1)" "i-1" "j" "0") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (assert) (("2" (inst-cp -1 "LAMBDA (k_1: below(M`rows)):
              IF i = k_1 THEN 1 ELSIF k_1 = j THEN a ELSE 0 ENDIF *
               M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "j-1" "0") (("1" (expand "restrict") (("1" (typepred "x!1") (("1" (split -3) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") (("1" (inst-cp -2 "LAMBDA (k_1: below(M`rows)):
              IF i = k_1 THEN 1 ELSIF k_1 = j THEN a ELSE 0 ENDIF *
               M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "M`rows-1" "i+1") (("1" (split -3) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") (("1" (inst -2 "LAMBDA (k_1: below(M`rows)):
              IF i = k_1 THEN 1 ELSIF k_1 = j THEN a ELSE 0 ENDIF *
               M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "i-1" "j+1") (("1" (split -2) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") nil nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst 2 "0") (("2" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (grind) (("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "rowV") (("2" (apply-extensionality 2 :hide? t) (("1" (expand "elemM1") (("1" (expand "*") (("1" (typepred "x!1") (("1" (lemma "sigma_middle[below(M`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
             IF k = k_1 THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "M`rows-1" "k" "0") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "sigma_restrict_eq[below(M`rows)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M`rows)):
              IF k = k_1 THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "k-1" "0") (("1" (expand "restrict") (("1" (split -2) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
              IF k = k_1 THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "M`rows-1" "k+1") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") nil nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst 2 "0") (("2" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rowV const-decl "Vector[M`cols]" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (T_low type-eq-decl nil sigma "reals/") (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_high type-eq-decl nil sigma "reals/") (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (x!1 skolem-const-decl "below((elemM1(M`rows)(i, j)(a) * M)`cols)" elementary_matrices nil) (sigma_zero formula-decl nil sigma "reals/") (sigma_nat application-judgement "nat" vectors "vectors/") (sigma def-decl "real" sigma "reals/") (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (restrict const-decl "[T -> real]" sigma "reals/") (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sigma_restrict_eq formula-decl nil sigma "reals/") (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_middle formula-decl nil sigma "reals/") (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (a skolem-const-decl "real" elementary_matrices nil) (j skolem-const-decl "{j: below(M`rows) | i /= j}" elementary_matrices nil) (i skolem-const-decl "below(M`rows)" elementary_matrices nil) (M skolem-const-decl "Matrix" elementary_matrices nil) (Index type-eq-decl nil vectors "vectors/") (Vector type-eq-decl nil vectors "vectors/") (+ const-decl "real" vectors "vectors/") (* const-decl "Vector" vectors "vectors/") (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (k skolem-const-decl "below(M`rows)" elementary_matrices nil) (x!1 skolem-const-decl "below((elemM1(M`rows)(i, j)(a) * M)`cols)" elementary_matrices nil)) shostak)) (elemM2_prop_TCC1 0 (elemM2_prop_TCC1-1 nil 3520625977 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (elemM2_prop_TCC2 0 (elemM2_prop_TCC2-1 nil 3520625977 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil)) nil)) (elemM2_prop_TCC3 0 (elemM2_prop_TCC3-1 nil 3520625977 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (elemM2_prop_TCC4 0 (elemM2_prop_TCC4-1 nil 3520625977 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (elemM2_prop_TCC5 0 (elemM2_prop_TCC5-1 nil 3520625977 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (elemM2_prop 0 (elemM2_prop-1 nil 3520625983 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (lift-if) (("" (lemma "sigma_middle[below(M`rows)]") (("1" (prop) (("1" (replace -1 :hide? t) (("1" (apply-extensionality :hide? t) (("1" (expand "rowV") (("1" (expand "elemM2") (("1" (expand "*") (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
             IF k_1 = j THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "M`rows-1" "j" "0") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "sigma_restrict_eq[below(M`rows)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M`rows)):
              IF k_1 = j THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "j-1" "0") (("1" (expand "restrict") (("1" (assert) (("1" (split -2) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
              IF k_1 = j THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "M`rows-1" "1+j") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") nil nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) (("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "rowV") (("2" (apply-extensionality :hide? t) (("1" (expand "elemM2") (("1" (expand "*") (("1" (replace -1 :hide? t) (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
             IF k_1 = i THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "M`rows-1" "i" "0") (("1" (typepred "x!1") (("1" (assert) (("1" (replace -2 :hide? t) (("1" (assert) (("1" (lemma "sigma_restrict_eq[below(M`rows)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M`rows)):
              IF k_1 = i THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "i-1" "0") (("1" (expand "restrict") (("1" (split -2) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
              IF k_1 = i THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "M`rows-1" "1+i") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") nil nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil) ("3" (expand "rowV") (("3" (apply-extensionality 2 :hide? t) (("1" (expand "elemM2") (("1" (expand "*") (("1" (typepred "x!1") (("1" (inst -2 "LAMBDA (k_1: below(M`rows)):
             IF k = k_1 THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "M`rows-1" "k" "0") (("1" (assert) (("1" (replace -2 :hide? t) (("1" (assert) (("1" (lemma "sigma_restrict_eq[below(M`rows)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M`rows)):
              IF k = k_1 THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "k-1" "0") (("1" (expand "restrict") (("1" (split -2) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
              IF k = k_1 THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "M`rows-1" "1+k") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") nil nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sigma_middle formula-decl nil sigma "reals/") (x!1 skolem-const-decl "below((elemM2(M`rows)(i, j) * M)`cols)" elementary_matrices nil) (x!1 skolem-const-decl "below((elemM2(M`rows)(i, j) * M)`cols)" elementary_matrices nil) (k skolem-const-decl "below(M`rows)" elementary_matrices nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (M skolem-const-decl "Matrix" elementary_matrices nil) (i skolem-const-decl "below(M`rows)" elementary_matrices nil) (j skolem-const-decl "{j: below(M`rows) | i /= j}" elementary_matrices nil) (x!1 skolem-const-decl "Index[(elemM2(M`rows)(i, j) * M)`cols]" elementary_matrices nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma def-decl "real" sigma "reals/") (sigma_nat application-judgement "nat" vectors "vectors/") (sigma_zero formula-decl nil sigma "reals/") (restrict const-decl "[T -> real]" sigma "reals/") (sigma_restrict_eq formula-decl nil sigma "reals/") (T_low type-eq-decl nil sigma "reals/") (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_high type-eq-decl nil sigma "reals/") (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Vector type-eq-decl nil vectors "vectors/") (rowV const-decl "Vector[M`cols]" matrices nil) (Index type-eq-decl nil vectors "vectors/") (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (= const-decl "[T, T -> boolean]" equalities nil)) shostak)) (elemM3_prop_TCC1 0 (elemM3_prop_TCC1-1 nil 3520642214 ("" (subtype-tcc) nil nil) ((elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (elemM3_prop_TCC2 0 (elemM3_prop_TCC2-1 nil 3520642214 ("" (subtype-tcc) nil nil) ((elemM3 const-decl "ElemMat3(n)" elementary_matrices nil)) nil)) (elemM3_prop_TCC3 0 (elemM3_prop_TCC3-1 nil 3520642214 ("" (subtype-tcc) nil nil) ((elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (elemM3_prop_TCC4 0 (elemM3_prop_TCC4-1 nil 3520642214 ("" (subtype-tcc) nil nil) ((elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (elemM3_prop 0 (elemM3_prop-1 nil 3520648145 ("" (skeep :preds? t) (("" (skeep 2 :preds? t) (("" (apply-extensionality 2 :hide? t) (("1" (typepred "x!1") (("1" (expand "rowV") (("1" (lift-if) (("1" (expand "elemM3") (("1" (prop) (("1" (expand "*") (("1" (lemma "sigma_middle[below(M`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
             IF k = k_1 THEN IF k = i THEN c ELSE 1 ENDIF ELSE 0 ENDIF *
              M`matrix(k_1, x!1)" "M`rows-1" "k" "0") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "sigma_restrict_eq[below(M`rows)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M`rows)):
              IF i = k_1 THEN c ELSE 0 ENDIF * M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "i-1" "0") (("1" (expand "restrict") (("1" (split -2) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
              IF i = k_1 THEN c ELSE 0 ENDIF * M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "M`rows-1" "i+1") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") nil nil)) nil) ("2" (apply-extensionality :hide? t) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst 2 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (expand "*") (("2" (lemma "sigma_middle[below(M`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
             IF k = k_1 THEN IF k = i THEN c ELSE 1 ENDIF ELSE 0 ENDIF *
              M`matrix(k_1, x!1)" "M`rows-1" "k" "0") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "sigma_restrict_eq[below(M`rows)]") (("1" (inst-cp -1 "LAMBDA (k_1: below(M`rows)):
              IF k = k_1 THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "k-1" "0") (("1" (expand "restrict") (("1" (split -2) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") (("1" (inst -1 "LAMBDA (k_1: below(M`rows)):
              IF k = k_1 THEN 1 ELSE 0 ENDIF * M`matrix(k_1, x!1)" "LAMBDA
              (k_1: below(M`rows)): 0" "M`rows-1" "k+1") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (rewrite "sigma_zero[below(M`rows)]") nil nil)) nil) ("2" (apply-extensionality :hide? t) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst 2 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ((sigma def-decl "real" sigma "reals/") (sigma_middle formula-decl nil sigma "reals/") (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_restrict_eq formula-decl nil sigma "reals/") (restrict const-decl "[T -> real]" sigma "reals/") (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_nat application-judgement "nat" vectors "vectors/") (sigma_zero formula-decl nil sigma "reals/") (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma "reals/") (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_low type-eq-decl nil sigma "reals/") (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (c skolem-const-decl "nzreal" elementary_matrices nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (i skolem-const-decl "below(M`rows)" elementary_matrices nil) (k skolem-const-decl "below(M`rows)" elementary_matrices nil) (M skolem-const-decl "Matrix" elementary_matrices nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Vector type-eq-decl nil vectors "vectors/") (rowV const-decl "Vector[M`cols]" matrices nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "Vector" vectors "vectors/") (Index type-eq-decl nil vectors "vectors/") (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (elem_prod_TCC1 0 (elem_prod_TCC1-1 nil 3520623927 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (elemM2? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemMat1? const-decl "bool" elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil)) nil)) (elem_prod 0 (elem_prod-1 nil 3521821858 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (elemM2? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemMat1? const-decl "bool" elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (elem_product_left_TCC1 0 (elem_product_left_TCC1-2 "" 3519333526 ("" (skolem 1 ("M" _)) (("" (induct "el") (("1" (grind) nil nil) ("2" (skosimp* :preds? t) (("2" (assert) (("2" (rewrite "every_nth") (("2" (rewrite "every_nth") (("2" (skosimp* :preds? t) (("2" (expand "square?") (("2" (expand "squareMat?" -5) (("2" (assert) (("2" (expand "nth" 1) (("2" (assert) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst -7 "i!1-1") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp :preds? t) (("3" (skosimp :preds? t) (("3" (rewrite "every_nth") (("3" (inst -3 "0") (("1" (expand "nth" -3) (("1" (flatten) (("1" (expand "square?") (("1" (assert) (("1" (expand "squareMat?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp :preds? t) (("4" (skosimp :preds? t) (("4" (rewrite "every_nth") (("4" (inst -3 "0") (("1" (flatten) (("1" (expand "square?" -3) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (list_induction formula-decl nil list_adt nil)) shostak) (elem_product_left_TCC1-1 nil 3500317452 ("" (skolem 1 ("M" _)) (("" (induct "el") (("1" (grind) nil nil) ("2" (skosimp* :preds? t) (("2" (assert) (("2" (rewrite "every_nth") (("2" (rewrite "every_nth") (("2" (rewrite "every_nth") nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (skosimp* :preds? t) (("3" (typepred "car[ElemMat(M`rows)](el!2)") (("3" (expand "square?") (("3" (expand "squareMat?" -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2 3) (("4" (skosimp* :preds? t) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Mat type-eq-decl nil matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (list_induction formula-decl nil list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (every_nth formula-decl nil list_props nil)) nil)) (elem_product_left_TCC2 0 (elem_product_left_TCC2-1 nil 3500317452 ("" (skeep :preds? t) (("" (rewrite "every_nth") (("" (inst -1 "0") (("1" (expand "nth") (("1" (flatten) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((every_nth formula-decl nil list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (square? const-decl "bool" matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (ElemMat type-eq-decl nil elementary_matrices nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (elemM1? const-decl "bool" elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemM2? const-decl "bool" elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (M skolem-const-decl "Matrix" elementary_matrices nil) (el skolem-const-decl "list[ElemMat(M`rows)]" elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (elem_product_left_TCC3 0 (elem_product_left_TCC3-3 "" 3547745712 ("" (skeep :preds? t) (("" (case-replace "(car[ElemMat(M`rows)](el) * M)`rows = M`rows") (("1" (split 2) (("1" (assert) (("1" (rewrite "every_nth") nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide -1 3) (("2" (grind) (("2" (typepred "car[ElemMat(M`rows)](el)") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -1 3) (("3" (typepred "car[ElemMat(M`rows)](el)") (("3" (grind) nil nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (* const-decl "Matrix" matrices nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (square? const-decl "bool" matrices nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (elemMat3? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (elemM2? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemMat1? const-decl "bool" elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil)) shostak) (elem_product_left_TCC3-2 "" 3519335815 ("" (skeep :preds? t) (("" (case-replace "(car[ElemMat(M`rows)](el) * M)`rows = M`rows") (("1" (replace -2) (("1" (assert) nil nil)) nil) ("2" (hide -1 3) (("2" (grind) (("2" (typepred "car[ElemMat(M`rows)](el)") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -1 3) (("3" (typepred "car[ElemMat(M`rows)](el)") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (square? const-decl "bool" matrices nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (every_nth formula-decl nil list_props nil) (TRUE const-decl "bool" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (elemMat3? const-decl "bool" elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemMat1? const-decl "bool" elementary_matrices nil)) shostak) (elem_product_left_TCC3-1 nil 3500317452 ("" (skosimp* :preds? t) (("" (typepred "v!1(prod!1, cdr[ElemMat(prod!1`rows)](el!1))") (("1" (assert) nil nil) ("2" (expand "length" 1 2) (("2" (assert) (("2" (replace -1 :actuals? t) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "every_nth") nil nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (every_nth formula-decl nil list_props nil) (Mat type-eq-decl nil matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (square? const-decl "bool" matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil)) nil)) (elem_product_left_TCC4 0 (elem_product_left_TCC4-1 nil 3500317452 ("" (skeep :preds? t) (("" (expand "length" 2 2) (("" (assert) (("" (case "(car(el) * M)`rows = M`rows") (("1" (replace -1 :actuals? t) (("1" (assert) nil nil)) nil) ("2" (typepred "car(el)") (("2" (hide-all-but (-1 -2 -3 1)) (("2" (grind) nil nil)) nil)) nil) ("3" (typepred "car(el)") (("3" (hide-all-but (-1 -2 -3 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((length def-decl "nat" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (* const-decl "Matrix" matrices nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma "reals/") (elemMat3? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (elemM2? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemMat1? const-decl "bool" elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (elem_product_left_TCC5 0 (elem_product_left_TCC5-2 "" 3547747078 ("" (skeep :preds? t) (("" (typepred "v(car[ElemMat(M`rows)](el) * M,
                    cdr[ElemMat((car(el) * M)`rows)](el))") (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (typepred "car[ElemMat(M`rows)](el)") (("1" (hide -4) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (case "(car[ElemMat(M`rows)](el) * M)`rows = M`rows") (("1" (expand "length" 1 2) (("1" (assert) (("1" (replace -1 :actuals? t) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "car[ElemMat(M`rows)](el)") (("2" (hide -4 2) (("2" (grind) nil nil)) nil)) nil) ("3" (typepred "car[ElemMat(M`rows)](el)") (("3" (hide -4 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (assert) (("3" (typepred "car[ElemMat(M`rows)](el)") (("3" (rewrite "every_nth") (("1" (assert) (("1" (rewrite "every_nth") (("1" (grind) nil nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (assert) nil nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (* const-decl "Matrix" matrices nil) (Mat type-eq-decl nil matrices nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (Matrix type-eq-decl nil matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemM1? const-decl "bool" elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemM2? const-decl "bool" elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (every_nth formula-decl nil list_props nil)) shostak) (elem_product_left_TCC5-1 nil 3520184066 ("" (skeep :preds? t) (("" (typepred "v(car[ElemMat(M`rows)](el) * M,
                cdr[ElemMat((car(el) * M)`rows)](el))") (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (typepred "car[ElemMat(M`rows)](el)") (("1" (hide -4) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (case "(car[ElemMat(M`rows)](el) * M)`rows = M`rows") (("1" (expand "length" 1 2) (("1" (assert) (("1" (replace -1 :actuals? t) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "car[ElemMat(M`rows)](el)") (("2" (hide -4 2) (("2" (grind) nil nil)) nil)) nil) ("3" (typepred "car[ElemMat(M`rows)](el)") (("3" (hide -4 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (assert) (("3" (typepred "car[ElemMat(M`rows)](el)") (("3" (hide -4 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Mat type-eq-decl nil matrices nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (Matrix type-eq-decl nil matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemMat1? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemMat2? const-decl "bool" elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (sigma def-decl "real" sigma "reals/") (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (list_induction formula-decl nil list_adt nil) (every_nth formula-decl nil list_props nil)) nil)) (elem_prod_append_aux_TCC1 0 (elem_prod_append_aux_TCC1-3 "" 3547748874 ("" (skeep :preds? t) (("" (assert) (("" (rewrite "every_nth") (("" (rewrite "every_nth") (("" (assert) (("" (skeep :preds? t) (("" (inst -4 "i") (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (ElemMat type-eq-decl nil elementary_matrices nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (every_nth formula-decl nil list_props nil)) shostak) (elem_prod_append_aux_TCC1-2 "" 3547747119 ("" (skeep :preds? t) (("" (assert) (("" (rewrite "every_nth") (("" (rewrite "every_nth") nil nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (ElemMat type-eq-decl nil elementary_matrices nil) (list type-decl nil list_adt nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (every_nth formula-decl nil list_props nil)) shostak) (elem_prod_append_aux_TCC1-1 nil 3520438795 ("" (skeep :preds? t) (("" (assert) (("" (replace -2 :actuals? t) (("" (propax) nil nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (ElemMat type-eq-decl nil elementary_matrices nil) (list type-decl nil list_adt nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (every_nth formula-decl nil list_props nil)) nil)) (elem_prod_append_aux_TCC2 0 (elem_prod_append_aux_TCC2-1 nil 3520438795 ("" (skeep :preds? t) (("" (replace -2 :dir rl :actuals? t :hide? t) (("" (case "elem_product_left(M, el1)`rows = M`rows") (("1" (replace -1 :actuals? t) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Matrix type-eq-decl nil matrices nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (square? const-decl "bool" matrices nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil)) nil)) (elem_prod_append_aux_TCC3 0 (elem_prod_append_aux_TCC3-1 nil 3522731559 ("" (skeep :preds? t) (("" (rewrite "every_append") (("" (replace -2 :dir rl :actuals? t :hide? t) (("" (assert) nil nil)) nil)) nil)) nil) ((every_append formula-decl nil list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (square? const-decl "bool" matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (ElemMat type-eq-decl nil elementary_matrices nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (elem_prod_append_aux 0 (elem_prod_append_aux-1 nil 3520439505 ("" (skolem 1 ("n" "_" "_" "el2") :skolem-typepreds? t) (("" (induct "el1") (("1" (grind) nil nil) ("2" (skeep :preds? t) (("2" (skeep :preds? t) (("2" (expand "elem_product_left" 1 2) (("2" (expand "append" +) (("2" (expand "elem_product_left" 1 3) (("2" (inst?) (("2" (hide-all-but (-1 -3 -4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep :preds? t) (("3" (assert) (("3" (rewrite "every_append") (("3" (replace -2 :actuals? t) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep :preds? t) (("4" (case "elem_product_left(M, el1)`rows = n") (("1" (replace -1 :actuals? t) (("1" (propax) nil nil)) nil) ("2" (hide -1 2) (("2" (grind) nil nil)) nil) ("3" (replace -2 :actuals? t) (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep :preds? t) (("5" (replace -2 :actuals? t) (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (n skolem-const-decl "posnat" elementary_matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (el2 skolem-const-decl "list[ElemMat(n)]" elementary_matrices nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (append def-decl "list[T]" list_props nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (list_induction formula-decl nil list_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elemMat3? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (elemM2? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemMat1? const-decl "bool" elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil) (* const-decl "Matrix" matrices nil) (cons1_var skolem-const-decl "ElemMat(n)" elementary_matrices nil) (M skolem-const-decl "{M: Matrix | M`rows = n}" elementary_matrices nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (every_append formula-decl nil list_props nil)) shostak)) (elem_prod_append_TCC1 0 (elem_prod_append_TCC1-1 nil 3522731559 ("" (skeep :preds? t) (("" (case "elem_product_left(M, el1)`rows = M`rows") (("1" (replace -1 :actuals? t) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ((elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (Mat type-eq-decl nil matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (Matrix type-eq-decl nil matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (elem_prod_append_TCC2 0 (elem_prod_append_TCC2-1 nil 3522731559 ("" (skeep :preds? t) (("" (rewrite "every_append") (("" (assert) nil nil)) nil)) nil) ((every_append formula-decl nil list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (square? const-decl "bool" matrices nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Square type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (ElemMat type-eq-decl nil elementary_matrices nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil)) nil)) (elem_prod_append 0 (elem_prod_append-1 nil 3520182334 ("" (lemma "elem_prod_append_aux") (("" (skeep) (("" (inst -1 "M`rows" "M" "el1" "el2") nil nil)) nil)) nil) ((ElemMat type-eq-decl nil elementary_matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (elem_prod_append_aux formula-decl nil elementary_matrices nil)) shostak)) (elem_prod_append1_TCC1 0 (elem_prod_append1_TCC1-1 nil 3520224542 ("" (skeep :preds? t) (("" (expand "append1") (("" (rewrite "every_append") (("" (assert) (("" (replace -2 :actuals? t) (("" (assert) (("" (expand "every" +) (("" (expand "every" +) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((append1 const-decl "list[T]" more_list_props nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ElemMat type-eq-decl nil elementary_matrices nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (every_append formula-decl nil list_props nil)) nil)) (elem_prod_append1_TCC2 0 (elem_prod_append1_TCC2-1 nil 3520224542 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (square? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (squareMat? const-decl "bool" matrices nil) (SquareMat type-eq-decl nil matrices nil) (elemMat? const-decl "bool" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (elemMat3? const-decl "bool" elementary_matrices nil) (elemM3? const-decl "bool" elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (elemM2? const-decl "bool" elementary_matrices nil) (/= const-decl "boolean" notequal nil) (elemMat1? const-decl "bool" elementary_matrices nil) (elemM1? const-decl "bool" elementary_matrices nil)) nil)) (elem_prod_append1 0 (elem_prod_append1-1 nil 3520224542 ("" (skeep :preds? t) (("" (expand "append1") (("" (use "elem_prod_append") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (replace -8) (("1" (expand "elem_product_left" 1) (("1" (expand "elem_product_left" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "every" 1) (("2" (expand "every" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((append1 const-decl "list[T]" more_list_props nil) (elem_product_left def-decl "Mat(M`rows, M`cols)" elementary_matrices nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (e skolem-const-decl "ElemMat(M`rows)" elementary_matrices nil) (ElemMat type-eq-decl nil elementary_matrices nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (elemMat? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (M skolem-const-decl "Matrix" elementary_matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (square? const-decl "bool" matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Matrix type-eq-decl nil matrices nil) (real nonempty-type-from-decl nil reals nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (elem_prod_append formula-decl nil elementary_matrices nil)) shostak)) (M1rows_TCC1 0 (M1rows_TCC1-1 nil 3552273894 ("" (subtype-tcc) nil nil) ((elemM1 const-decl "ElemMat1(n)" elementary_matrices nil)) nil)) (M1rows 0 (M1rows-1 nil 3552274679 ("" (skeep :preds? t) (("" (hide -) (("" (lemma "elemM1_prop") (("" (inst -1 "M" "i" "j" "a" _) (("" (expand "rows2matrix") (("" (apply-extensionality 2 :hide? t) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (apply-extensionality 1 :hide? t) (("1" (expand "rows") (("1" (lift-if) (("1" (prop) (("1" (replace -1 :hide? t) (("1" (inst -1 "i") (("1" (rewrite "add_comm") (("1" (replace -1 :dir rl :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "x!1") (("1" (assert) (("1" (expand "rowV" -1) (("1" (decompose-equality -1) (("1" (inst?) nil nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "x!1") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (rowV const-decl "Vector[M`cols]" matrices nil) (* const-decl "Vector" vectors "vectors/") (+ const-decl "real" vectors "vectors/") (rows const-decl "Vector_of_Vectors[M`cols, M`rows]" matrices nil) (Vector_of_Vectors type-eq-decl nil vect_of_vect nil) (Vector type-eq-decl nil vectors "vectors/") (Index type-eq-decl nil vectors "vectors/") (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma "reals/") (real_plus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (add_comm formula-decl nil vectors "vectors/") (NOT const-decl "[bool -> bool]" booleans nil) (x!1 skolem-const-decl "below((elemM1(M`rows)(i, j)(a) * M)`rows)" elementary_matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (M skolem-const-decl "Matrix" elementary_matrices nil) (i skolem-const-decl "below(M`rows)" elementary_matrices nil) (j skolem-const-decl "{j: below(M`rows) | i /= j}" elementary_matrices nil) (a skolem-const-decl "real" elementary_matrices nil) (rows2matrix const-decl "Matrix" matrices nil) (elemM1_prop formula-decl nil elementary_matrices nil)) shostak)) (M2rows_TCC1 0 (M2rows_TCC1-1 nil 3553007807 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil)) nil)) (M2rows 0 (M2rows-1 nil 3553007815 ("" (skeep :preds? t) (("" (hide -) (("" (lemma "elemM2_prop") (("" (inst -1 "M" "i" "j" _) (("" (expand "rows2matrix") (("" (apply-extensionality 2 :hide? t) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (apply-extensionality 1 :hide? t) (("1" (expand "rows") (("1" (lift-if) (("1" (prop) (("1" (replace -1 :hide? t) (("1" (inst -1 "j") (("1" (assert) (("1" (replace -1 :dir rl :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "i") (("2" (replace -1 :dir rl :hide? t) (("2" (replace -1 :dir rl :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (assert) (("3" (inst -1 "x!1") (("3" (assert) (("3" (expand "rowV" -1) (("3" (decompose-equality -1) (("1" (inst?) nil nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (rowV const-decl "Vector[M`cols]" matrices nil) (rows const-decl "Vector_of_Vectors[M`cols, M`rows]" matrices nil) (Vector_of_Vectors type-eq-decl nil vect_of_vect nil) (Vector type-eq-decl nil vectors "vectors/") (Index type-eq-decl nil vectors "vectors/") (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil) (ElemMat2 type-eq-decl nil elementary_matrices nil) (elemMat2? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma "reals/") (real_plus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (M skolem-const-decl "Matrix" elementary_matrices nil) (i skolem-const-decl "below(M`rows)" elementary_matrices nil) (j skolem-const-decl "{j: below(M`rows) | i /= j}" elementary_matrices nil) (rows2matrix const-decl "Matrix" matrices nil) (elemM2_prop formula-decl nil elementary_matrices nil)) shostak)) (M3rows_TCC1 0 (M3rows_TCC1-1 nil 3553007807 ("" (subtype-tcc) nil nil) ((elemM3 const-decl "ElemMat3(n)" elementary_matrices nil)) nil)) (M3rows 0 (M3rows-1 nil 3553008393 ("" (skeep :preds? t) (("" (hide -) (("" (lemma "elemM3_prop") (("" (inst -1 "M" "i" "c" _) (("" (expand "rows2matrix") (("" (apply-extensionality 2 :hide? t) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (apply-extensionality 1 :hide? t) (("1" (expand "rows") (("1" (lift-if) (("1" (prop) (("1" (replace -1 :hide? t) (("1" (inst -1 "i") (("1" (replace -1 :dir rl :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -1 "x!1") (("1" (assert) (("1" (expand "rowV" -1) (("1" (decompose-equality -1) (("1" (inst?) nil nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "x!1") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Matrix type-eq-decl nil matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (rowV const-decl "Vector[M`cols]" matrices nil) (* const-decl "Vector" vectors "vectors/") (rows const-decl "Vector_of_Vectors[M`cols, M`rows]" matrices nil) (Vector_of_Vectors type-eq-decl nil vect_of_vect nil) (Vector type-eq-decl nil vectors "vectors/") (Index type-eq-decl nil vectors "vectors/") (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil) (ElemMat3 type-eq-decl nil elementary_matrices nil) (elemMat3? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "Matrix" matrices nil) (= const-decl "[T, T -> boolean]" equalities nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma "reals/") (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (x!1 skolem-const-decl "below((elemM3(M`rows)(i)(c) * M)`rows)" elementary_matrices nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (M skolem-const-decl "Matrix" elementary_matrices nil) (i skolem-const-decl "below(M`rows)" elementary_matrices nil) (c skolem-const-decl "nzreal" elementary_matrices nil) (rows2matrix const-decl "Matrix" matrices nil) (elemM3_prop formula-decl nil elementary_matrices nil)) shostak)) (M1cols_TCC1 0 (M1cols_TCC1-1 nil 3553024236 ("" (subtype-tcc) nil nil) ((elemM1 const-decl "ElemMat1(n)" elementary_matrices nil)) nil)) (M1cols 0 (M1cols-1 nil 3553024271 ("" (skeep :preds? t) (("" (hide -) (("" (expand "*") (("" (expand "cols2matrix") (("" (expand "colV") (("" (expand "cols") (("" (assert) (("" (split 2) (("1" (grind) nil nil) ("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (expand "+") (("1" (prop) (("1" (expand "elemM1") (("1" (replace -1 :hide? t) (("1" (lemma "sigma_2_sum") (("1" (inst -1 "M`cols" "j" "i" "M`matrix(x!1, j)" "a * M`matrix(x!1, i)") (("1" (case-replace "(LAMBDA (x: below(M`cols)):
              IF x = j THEN M`matrix(x!1, j)
              ELSIF x = i THEN a * M`matrix(x!1, i)
              ELSE 0
              ENDIF) = (LAMBDA (k: below(M`cols)):
             M`matrix(x!1, k) *
              IF k = j THEN 1 ELSIF k = i THEN a ELSE 0 ENDIF)") (("1" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "elemM1") (("2" (assert) (("2" (lemma "sigma_1_nz") (("2" (inst -1 "M`cols" "x!2" "M`matrix(x!1, x!2)") (("2" (case-replace "(LAMBDA (x: below(M`cols)):
              IF x = x!2 THEN M`matrix(x!1, x!2) ELSE 0 ENDIF) = 
   (LAMBDA (k: below(M`cols)):
             M`matrix(x!1, k) * IF k = x!2 THEN 1 ELSE 0 ENDIF)") (("2" (apply-extensionality :hide? t) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cols2matrix const-decl "Matrix" matrices nil) (cols const-decl "Vector_of_Vectors[M`rows, M`cols]" matrices nil) (elemM1 const-decl "ElemMat1(n)" elementary_matrices nil) (real_plus_real_is_real application-judgement "real" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (sigma_2_sum formula-decl nil elementary_matrices nil) (sigma_1_nz formula-decl nil elementary_matrices nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (M skolem-const-decl "Matrix" elementary_matrices nil) (i skolem-const-decl "below(M`cols)" elementary_matrices nil) (j skolem-const-decl "{j: below(M`cols) | i /= j}" elementary_matrices nil) (a skolem-const-decl "real" elementary_matrices nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (sigma def-decl "real" sigma "reals/") (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (Index type-eq-decl nil vectors "vectors/") (Vector type-eq-decl nil vectors "vectors/") (+ const-decl "real" vectors "vectors/") (ElemMat1 type-eq-decl nil elementary_matrices nil) (elemMat1? const-decl "bool" elementary_matrices nil) (SquareMat type-eq-decl nil matrices nil) (squareMat? const-decl "bool" matrices nil) (Square type-eq-decl nil matrices nil) (square? const-decl "bool" matrices nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Matrix type-eq-decl nil matrices nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (colV const-decl "Vector[M`rows]" matrices nil) (* const-decl "Matrix" matrices nil) (* const-decl "Vector" vectors "vectors/")) shostak)) (M2cols_TCC1 0 (M2cols_TCC1-1 nil 3553024236 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil)) nil)) (M2cols 0 (M2cols-1 nil 3555101300 ("" (skeep :preds? t) (("" (hide -) (("" (expand "elemM2") (("" (expand "*") (("" (expand "cols2matrix") (("" (apply-extensionality 2 :hide? t) (("" (expand "cols") (("" (expand "colV") (("" (lift-if) (("" (assert) (("" (prop) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "sigma_1_nz") (("1" (inst -1 "M`cols" "i" "M`matrix(x!1, i)") (("1" (case-replace "(LAMBDA (x: below(M`cols)):
              IF x = i THEN M`matrix(x!1, i) ELSE 0 ENDIF) = 
  (LAMBDA (k_1: below(M`cols)):
             M`matrix(x!1, k_1) *
              IF k_1 = j AND k_1 /= i AND k_1 /= j THEN 1
              ELSIF k_1 = i THEN 1
              ELSE 0
              ENDIF)") (("1" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 :hide? t) (("2" (lemma "sigma_1_nz") (("2" (inst -1 "M`cols" "j" "M`matrix(x!1, j)") (("2" (case-replace "(LAMBDA (x: below(M`cols)):
              IF x = j THEN M`matrix(x!1, j) ELSE 0 ENDIF) = 
  (LAMBDA (k_1: below(M`cols)):
             M`matrix(x!1, k_1) *
              IF k_1 = i AND k_1 /= i AND k_1 /= j THEN 1
              ELSIF k_1 = j THEN 1
              ELSE 0
              ENDIF)") (("2" (apply-extensionality :hide? t) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "sigma_1_nz") (("3" (inst -1 "M`cols" "x!2" "M`matrix(x!1, x!2)") (("3" (case-replace "(LAMBDA (x: below(M`cols)):
              IF x = x!2 THEN M`matrix(x!1, x!2) ELSE 0 ENDIF) = 
  (LAMBDA (k_1: below(M`cols)):
             M`matrix(x!1, k_1) *
              IF k_1 = x!2 AND k_1 /= i AND k_1 /= j THEN 1 ELSE 0 ENDIF)") (("3" (apply-extensionality :hide? t) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((* const-decl "Matrix" matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (colV const-decl "Vector[M`rows]" matrices nil) (cols const-decl "Vector_of_Vectors[M`rows, M`cols]" matrices nil) (Vector_of_Vectors type-eq-decl nil vect_of_vect nil) (Vector type-eq-decl nil vectors "vectors/") (Index type-eq-decl nil vectors "vectors/") (/= const-decl "boolean" notequal nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sigma def-decl "real" sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (T_low type-eq-decl nil sigma "reals/") (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_1_nz formula-decl nil elementary_matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (cols2matrix const-decl "Matrix" matrices nil) (elemM2 const-decl "ElemMat2(n)" elementary_matrices nil)) shostak)) (M3cols_TCC1 0 (M3cols_TCC1-1 nil 3553024236 ("" (subtype-tcc) nil nil) ((elemM3 const-decl "ElemMat3(n)" elementary_matrices nil)) nil)) (M3cols 0 (M3cols-1 nil 3555102615 ("" (skeep :preds? t) (("" (hide -) (("" (expand "elemM3") (("" (expand "*") (("" (expand "cols2matrix") (("" (apply-extensionality 2 :hide? t) (("" (expand "cols") (("" (expand "colV") (("" (assert) (("" (lift-if) (("" (prop) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (lemma "sigma_1_nz") (("1" (inst -1 "M`cols" "i" "c * M`matrix(x!1, i)") (("1" (case-replace "(LAMBDA (x: below(M`cols)):
              IF x = i THEN c * M`matrix(x!1, i) ELSE 0 ENDIF) =
   (LAMBDA (k_1: below(M`cols)):
             M`matrix(x!1, k_1) * IF k_1 = i THEN c ELSE 0 ENDIF)") (("1" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sigma_1_nz") (("2" (inst -1 "M`cols" "x!2" "M`matrix(x!1, x!2)") (("2" (case-replace "(LAMBDA (x: below(M`cols)):
              IF x = x!2 THEN M`matrix(x!1, x!2) ELSE 0 ENDIF) =
   (LAMBDA (k_1: below(M`cols)):
             M`matrix(x!1, k_1) * IF k_1 = x!2 THEN 1 ELSE 0 ENDIF)") (("2" (apply-extensionality :hide? t) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((* const-decl "Vector" vectors "vectors/") (* const-decl "Matrix" matrices nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Matrix type-eq-decl nil matrices nil) (colV const-decl "Vector[M`rows]" matrices nil) (cols const-decl "Vector_of_Vectors[M`rows, M`cols]" matrices nil) (Vector_of_Vectors type-eq-decl nil vect_of_vect nil) (Vector type-eq-decl nil vectors "vectors/") (Index type-eq-decl nil vectors "vectors/") (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sigma def-decl "real" sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (T_low type-eq-decl nil sigma "reals/") (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_1_nz formula-decl nil elementary_matrices nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (cols2matrix const-decl "Matrix" matrices nil) (elemM3 const-decl "ElemMat3(n)" elementary_matrices nil)) shostak)))
